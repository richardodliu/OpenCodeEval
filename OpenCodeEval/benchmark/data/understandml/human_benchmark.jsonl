{"id": 1, "difficulty": "easy", "category": "Linear Algebra", "title": "Matrix-Vector Dot Product", "description": "Write a Python function that computes the dot product of a matrix and a vector. The function should return a list representing the resulting vector if the operation is valid, or -1 if the matrix and vector dimensions are incompatible. A matrix (a list of lists) can be dotted with a vector (a list) only if the number of columns in the matrix equals the length of the vector. For example, an n x m matrix requires a vector of length m.", "inputs": ["matrix_dot_vector(a = [[1, 2], [2, 4]], b = [1, 2])"], "outputs": ["[5, 10]"], "reasoning": ["Row 1: (1 * 1) + (2 * 2) = 1 + 4 = 5; Row 2: (1 * 2) + (2 * 4) = 2 + 8 = 10"], "import_code": "", "output_constrains": "Your code should return a list where each element is the dot product of a row of 'a' with 'b'. If the number of columns in 'a' does not match the length of 'b', return -1.", "entry_point": "matrix_dot_vector", "starter_code": "def matrix_dot_vector(a: list[list[int|float]], b: list[int|float]) -> list[int|float]:", "reference_code": "def matrix_dot_vector(a: list[list[int|float]], b: list[int|float]) -> list[int|float]:\n    if len(a[0]) != len(b):\n        return -1\n    result = []\n    for row in a:\n        total = 0\n        for i in range(len(row)):\n            total += row[i] * b[i]\n        result.append(total)\n    return result", "test_cases": ["assert matrix_dot_vector([[1, 2, 3], [2, 4, 5], [6, 8, 9]], [1, 2, 3]) == [14, 25, 49]", "assert matrix_dot_vector([[1, 2], [2, 4], [6, 8], [12, 4]], [1, 2, 3]) == -1", "assert matrix_dot_vector([[1.5, 2.5], [3.0, 4.0]], [2, 1]) == [5.5, 10.0]"]}
{"id": 2, "difficulty": "easy", "category": "Linear Algebra", "title": "Transpose of a Matrix", "description": "Write a Python function that computes the transpose of a given matrix.", "inputs": ["transpose_matrix(a = [[1,2,3],[4,5,6]])"], "outputs": ["[[1,4],[2,5],[3,6]]"], "reasoning": ["Row 1: (1 * 1) + (2 * 2) = 1 + 4 = 5; Row 2: (1 * 2) + (2 * 4) = 2 + 8 = 10"], "import_code": "", "output_constrains": "", "entry_point": "transpose_matrix", "starter_code": "def transpose_matrix(a: list[list[int|float]]) -> list[list[int|float]]:", "reference_code": "def transpose_matrix(a: list[list[int|float]]) -> list[list[int|float]]:\n    return [list(i) for i in zip(*a)]", "test_cases": ["assert transpose_matrix([[1,2],[3,4],[5,6]]) == [[1, 3, 5], [2, 4, 6]]", "assert transpose_matrix([[1,2,3],[4,5,6]]) == [[1, 4], [2, 5], [3, 6]]", "assert transpose_matrix([[1,2],[3,4]]) == [[1, 3], [2, 4]]"]}
{"id": 3, "difficulty": "easy", "category": "Linear Algebra", "title": "Reshape Matrix", "description": "Write a Python function that reshapes a given matrix into a specified shape. if it can not be reshaped return back an empty list \"[]\".", "inputs": ["reshape_matrix(a = [[1,2,3,4],[5,6,7,8]], new_shape = (4, 2))"], "outputs": ["[[1, 2], [3, 4], [5, 6], [7, 8]]"], "reasoning": ["The given matrix is reshaped from 2x4 to 4x2."], "import_code": "import numpy as np", "output_constrains": "Return python list after reshaping by using numpy's tolist() method.", "entry_point": "reshape_matrix", "starter_code": "def reshape_matrix(a: list[list[int|float]], new_shape: tuple[int, int]) -> list[list[int|float]]:", "reference_code": "def reshape_matrix(a: list[list[int|float]], new_shape: tuple[int, int]) -> list[list[int|float]]:\n    # Not compatible case\n    if len(a)*len(a[0]) != new_shape[0]*new_shape[1]:\n        return []\n    return np.array(a).reshape(new_shape).tolist()", "test_cases": ["assert reshape_matrix([[1,2,3,4],[5,6,7,8]], (4, 2)) == [[1, 2], [3, 4], [5, 6], [7, 8]]", "assert reshape_matrix([[1, 2, 3, 4], [5, 6, 7, 8]], (1, 4)) == []", "assert reshape_matrix([[1,2,3],[4,5,6]], (3, 2)) == [[1, 2], [3, 4], [5, 6]]", "assert reshape_matrix([[1,2,3,4],[5,6,7,8]], (2, 4)) == [[1, 2, 3, 4], [5, 6, 7, 8]]"]}
{"id": 4, "difficulty": "easy", "category": "Linear Algebra", "title": "Calculate Mean by Row or Column", "description": "Write a Python function that calculates the mean of a matrix either by row or by column, based on a given mode. The function should take a matrix (list of lists) and a mode ('row' or 'column') as input and return a list of means according to the specified mode.", "inputs": ["calculate_matrix_mean(matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], mode = 'column')"], "outputs": ["[4.0, 5.0, 6.0]"], "reasoning": ["Calculating the mean of each column results in [(1+4+7)/3, (2+5+8)/3, (3+6+9)/3]."], "import_code": "", "output_constrains": "", "entry_point": "calculate_matrix_mean", "starter_code": "def calculate_matrix_mean(matrix: list[list[float]], mode: str) -> list[float]:", "reference_code": "def calculate_matrix_mean(matrix: list[list[float]], mode: str) -> list[float]:\n    if mode == 'column':\n        return [sum(col) / len(matrix) for col in zip(*matrix)]\n    elif mode == 'row':\n        return [sum(row) / len(row) for row in matrix]\n    else:\n        raise ValueError(\"Mode must be 'row' or 'column'\")", "test_cases": ["assert calculate_matrix_mean([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 'column') == [4.0, 5.0, 6.0]", "assert calculate_matrix_mean([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 'row') == [2.0, 5.0, 8.0]"]}
{"id": 5, "difficulty": "easy", "category": "Linear Algebra", "title": "Scalar Multiplication of a Matrix", "description": "Write a Python function that multiplies a matrix by a scalar and returns the result.", "inputs": ["scalar_multiply(matrix = [[1, 2], [3, 4]], scalar = 2)"], "outputs": ["[[2, 4], [6, 8]]"], "reasoning": ["Each element of the matrix is multiplied by the scalar."], "import_code": "", "output_constrains": "", "entry_point": "scalar_multiply", "starter_code": "def scalar_multiply(matrix: list[list[int|float]], scalar: int|float) -> list[list[int|float]]:", "reference_code": "def scalar_multiply(matrix: list[list[int|float]], scalar: int|float) -> list[list[int|float]]:\n    return [[element * scalar for element in row] for row in matrix]", "test_cases": ["assert scalar_multiply([[1,2],[3,4]], 2) == [[2, 4], [6, 8]]", "assert scalar_multiply([[0,-1],[1,0]], -1) == [[0, 1], [-1, 0]]"]}
{"id": 6, "difficulty": "easy", "category": "Linear Algebra", "title": "Calculate Eigenvalues of a Matrix", "description": "Write a Python function that calculates the eigenvalues of a 2x2 matrix. The function should return a list containing the eigenvalues, sort values from highest to lowest.", "inputs": ["calculate_eigenvalues(matrix = [[2, 1], [1, 2]])"], "outputs": ["[3.0, 1.0]"], "reasoning": ["The eigenvalues of the matrix are calculated using the characteristic equation of the matrix, which for a 2\u00d72 matrix is $\\lambda^2 - \text{trace}(A)\\lambda + \text{det}(A) = 0$ where $\\lambda$ are the eigenvalues."], "import_code": "", "output_constrains": "", "entry_point": "calculate_eigenvalues", "starter_code": "def calculate_eigenvalues(matrix: list[list[float|int]]) -> list[float]:", "reference_code": "def calculate_eigenvalues(matrix: list[list[float|int]]) -> list[float]:\n    a, b, c, d = matrix[0][0], matrix[0][1], matrix[1][0], matrix[1][1]\n    trace = a + d\n    determinant = a * d - b * c\n    # Calculate the discriminant of the quadratic equation\n    discriminant = trace**2 - 4 * determinant\n    # Solve for eigenvalues\n    lambda_1 = (trace + discriminant**0.5) / 2\n    lambda_2 = (trace - discriminant**0.5) / 2\n    return [lambda_1, lambda_2]", "test_cases": ["assert calculate_eigenvalues([[2, 1], [1, 2]]) == [3.0, 1.0]", "assert calculate_eigenvalues([[4, -2], [1, 1]]) == [3.0, 2.0]"]}
{"id": 7, "difficulty": "easy", "category": "Linear Algebra", "title": "Matrix Transformation", "description": "Write a Python function that transforms a given matrix $A$ using the operation $T^{-1}AS$, where $T$ and $S$ are invertible matrices. The function should first validate if the matrices $T$ and $S$ are invertible, and then perform the transformation. In cases where there is no solution return -1.", "inputs": ["transform_matrix(A = [[1, 2], [3, 4]], T = [[2, 0], [0, 2]], S = [[1, 1], [0, 1]])"], "outputs": ["[[0.5,1.5],[1.5,3.5]]"], "reasoning": ["The matrices $T$ and $S$ are used to transform matrix $A$ by computing $T^{-1}AS$."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "transform_matrix", "starter_code": "def transform_matrix(A: list[list[int|float]], T: list[list[int|float]], S: list[list[int|float]]) -> list[list[int|float]]:", "reference_code": "def transform_matrix(A: list[list[int|float]], T: list[list[int|float]], S: list[list[int|float]]) -> list[list[int|float]]:\n    # Convert to numpy arrays for easier manipulation\n    A = np.array(A, dtype=float)\n    T = np.array(T, dtype=float)\n    S = np.array(S, dtype=float)\n    \n    # Check if the matrices T and S are invertible\n    if np.linalg.det(T) == 0 or np.linalg.det(S) == 0:\n        # raise ValueError(\"The matrices T and/or S are not invertible.\")\n        return -1\n    \n    # Compute the inverse of T\n    T_inv = np.linalg.inv(T)\n\n    # Perform the matrix transformation; use @ for better readability\n    transformed_matrix = np.round(T_inv @ A @ S, 4)\n    \n    return transformed_matrix.tolist()", "test_cases": ["assert transform_matrix([[1, 2], [3, 4]], [[2, 0], [0, 2]], [[1, 1], [0, 1]]) == [[0.5,1.5],[1.5,3.5]]", "assert transform_matrix([[1, 0], [0, 1]], [[1, 2], [3, 4]], [[2, 0], [0, 2]]) == [[-4.0, 2.0], [3.0, -1.0]]", "assert transform_matrix([[2, 3], [1, 4]], [[3, 0], [0, 3]], [[1, 1], [0, 1]]) == [[0.6667, 1.6667], [0.3333, 1.6667]]", "assert transform_matrix([[2, 3], [1, 4]], [[3, 0], [0, 3]], [[1, 1], [1, 1]]) == -1"]}
{"id": 8, "difficulty": "easy", "category": "Linear Algebra", "title": "Calculate 2x2 Matrix Inverse", "description": "Write a Python function that calculates the inverse of a 2x2 matrix. Return 'None' if the matrix is not invertible.", "inputs": ["inverse_2x2(matrix = [[4, 7], [2, 6]])"], "outputs": ["[[0.6, -0.7], [-0.2, 0.4]]"], "reasoning": ["The inverse of a 2x2 matrix [a, b], [c, d] is given by (1/(ad-bc)) * [d, -b], [-c, a], provided ad-bc is not zero."], "import_code": "", "output_constrains": "", "entry_point": "inverse_2x2", "starter_code": "def inverse_2x2(matrix: list[list[float]]) -> list[list[float]]:", "reference_code": "def inverse_2x2(matrix: list[list[float]]) -> list[list[float]]:\n    a, b, c, d = matrix[0][0], matrix[0][1], matrix[1][0], matrix[1][1]\n    determinant = a * d - b * c\n    if determinant == 0:\n        return None\n    inverse = [[d/determinant, -b/determinant], [-c/determinant, a/determinant]]\n    return inverse", "test_cases": ["assert inverse_2x2([[4, 7], [2, 6]]) == [[0.6, -0.7], [-0.2, 0.4]]", "assert inverse_2x2([[2, 1], [6, 2]]) == [[-1.0, 0.5], [3.0, -1.0]]"]}
{"id": 9, "difficulty": "easy", "category": "Linear Algebra", "title": "Matrix times Matrix", "description": "Write a Python function that multiplies two matrices. If the matrices cannot be multiplied, return -1.", "inputs": ["matrixmul(a = [[1,2],[2,4]], b = [[2,1],[3,4]])"], "outputs": ["[[ 8,  9],[16, 18]]"], "reasoning": ["1*2 + 2*3 = 8; 2*2 + 3*4 = 16; 1*1 + 2*4 = 9; 2*1 + 4*4 = 18 Example 2: input: A = [[1,2], [2,4]], B = [[2,1], [3,4], [4,5]] output: -1 reasoning: the length of the rows of A does not equal the column length of B"], "import_code": "", "output_constrains": "", "entry_point": "matrixmul", "starter_code": "def matrixmul(a:list[list[int|float]],\n              b:list[list[int|float]])-> list[list[int|float]]:", "reference_code": "def matrixmul(a:list[list[int|float]],\n              b:list[list[int|float]])-> list[list[int|float]]:\n    if len(a[0]) != len(b):\n        return -1\n    \n    vals = []\n    for i in range(len(a)):\n        hold = []\n        for j in range(len(b[0])):\n            val = 0\n            for k in range(len(b)):\n                val += a[i][k] * b[k][j]\n                           \n            hold.append(val)\n        vals.append(hold)\n\n    return vals", "test_cases": ["assert matrixmul([[1,2,3],[2,3,4],[5,6,7]],[[3,2,1],[4,3,2],[5,4,3]]) == [[26, 20, 14], [38, 29, 20], [74, 56, 38]]", "assert matrixmul([[0,0],[2,4],[1,2]],[[0,0],[2,4]]) == [[0, 0], [8, 16], [4, 8]]", "assert matrixmul([[0,0],[2,4],[1,2]],[[0,0,1],[2,4,1],[1,2,3]]) == -1"]}
{"id": 10, "difficulty": "easy", "category": "Linear Algebra", "title": "Calculate Covariance Matrix", "description": "Write a Python function to calculate the covariance matrix for a given set of vectors. The function should take a list of lists, where each inner list represents a feature with its observations, and return a covariance matrix as a list of lists. Additionally, provide test cases to verify the correctness of your implementation.", "inputs": ["calculate_covariance_matrix(vectors = [[1, 2, 3], [4, 5, 6]])"], "outputs": ["[[1.0, 1.0], [1.0, 1.0]]"], "reasoning": [""], "import_code": "", "output_constrains": "", "entry_point": "calculate_covariance_matrix", "starter_code": "def calculate_covariance_matrix(vectors: list[list[float]]) -> list[list[float]]:", "reference_code": "def calculate_covariance_matrix(vectors: list[list[float]]) -> list[list[float]]:\n    n_features = len(vectors)\n    n_observations = len(vectors[0])\n    covariance_matrix = [[0 for _ in range(n_features)] for _ in range(n_features)]\n\n    means = [sum(feature) / n_observations for feature in vectors]\n\n    for i in range(n_features):\n        for j in range(i, n_features):\n            covariance = sum((vectors[i][k] - means[i]) * (vectors[j][k] - means[j]) for k in range(n_observations)) / (n_observations - 1)\n            covariance_matrix[i][j] = covariance_matrix[j][i] = covariance\n\n    return covariance_matrix", "test_cases": ["assert calculate_covariance_matrix([[1, 2, 3], [4, 5, 6]]) == [[1.0, 1.0], [1.0, 1.0]]", "assert calculate_covariance_matrix([[1, 5, 6], [2, 3, 4], [7, 8, 9]]) == [[7.0, 2.5, 2.5], [2.5, 1.0, 1.0], [2.5, 1.0, 1.0]]"]}
{"id": 11, "difficulty": "medium", "category": "Linear Algebra", "title": "Solve Linear Equations using Jacobi Method", "description": "Write a Python function that uses the Jacobi method to solve a system of linear equations given by Ax = b. The function should iterate n times, rounding each intermediate solution to four decimal places, and return the approximate solution x.", "inputs": ["solve_jacobi(A = [[5, -2, 3], [-3, 9, 1], [2, -1, -7]], b = [-1, 2, 3], n = 2)"], "outputs": ["[0.146, 0.2032, -0.5175]"], "reasoning": ["The Jacobi method iteratively solves each equation for x[i] using the formula x[i] = (1/a_ii) * (b[i] - sum(a_ij * x[j] for j != i)), where a_ii is the diagonal element of A and a_ij are the off-diagonal elements."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "solve_jacobi", "starter_code": "def solve_jacobi(A: np.ndarray, b: np.ndarray, n: int) -> list:", "reference_code": "def solve_jacobi(A: np.ndarray, b: np.ndarray, n: int) -> list:\n    d_a = np.diag(A)\n    nda = A - np.diag(d_a)\n    x = np.zeros(len(b))\n    x_hold = np.zeros(len(b))\n    for _ in range(n):\n        for i in range(len(A)):\n            x_hold[i] = (1/d_a[i]) * (b[i] - sum(nda[i]*x))\n        x = x_hold.copy()\n    return np.round(x,4).tolist()", "test_cases": ["assert solve_jacobi(np.array([[5, -2, 3], [-3, 9, 1], [2, -1, -7]]), np.array([-1, 2, 3]),2) == [0.146, 0.2032, -0.5175]", "assert solve_jacobi(np.array([[4, 1, 2], [1, 5, 1], [2, 1, 3]]), np.array([4, 6, 7]),5) == [-0.0806, 0.9324, 2.4422]", "assert solve_jacobi(np.array([[4,2,-2],[1,-3,-1],[3,-1,4]]), np.array([0,7,5]),3) == [1.7083, -1.9583, -0.7812]"]}
{"id": 12, "difficulty": "hard", "category": "Linear Algebra", "title": "Singular Value Decomposition (SVD)", "description": "Write a Python function that approximates the Singular Value Decomposition on a 2x2 matrix by using the jacobian method and without using numpy svd function, i mean you could but you wouldn't learn anything. return the result in this format.", "inputs": ["svd_2x2_singular_values(A = [[2, 1], [1, 2]])"], "outputs": ["array([[-0.70710678, -0.70710678], [-0.70710678,  0.70710678]]), array([3., 1.]), array([[-0.70710678, -0.70710678], [-0.70710678,  0.70710678]])"], "reasoning": ["U is the first matrix sigma is the second vector and V is the third matrix"], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.", "entry_point": "svd_2x2_singular_values", "starter_code": "def svd_2x2_singular_values(A: np.ndarray) -> tuple:", "reference_code": "def svd_2x2_singular_values(A: np.ndarray) -> tuple:\n   # stick to lowercase\n   a = A\n\n   a_t = np.transpose(a)\n   a_2 = a_t @ a\n\n   v = np.eye(2)\n\n   for _ in range(1):\n       # Compute rotation angle for a 2x2 matrix\n       if a_2[0,0] == a_2[1,1]:\n           theta = np.pi/4\n       else:\n           theta = 0.5 * np.arctan2(2 * a_2[0,1], a_2[0,0] - a_2[1,1])\n       \n       # Create rotation matrix\n       r = np.array(\n           [\n               [np.cos(theta), -np.sin(theta)],\n               [np.sin(theta), np.cos(theta)]\n               ]\n           )\n       \n       # apply rotation\n       d = np.transpose(r) @ a_2 @ r\n\n       # update a_2\n       a_2 = d\n\n       # accumulate v\n       v = v @ r\n\n   # sigma is the diagonal elements squared\n   s = np.sqrt([d[0,0], d[1,1]])\n   s_inv = np.array([[1/s[0], 0], [0, 1/s[1]]])\n   \n   u = a @ v @ s_inv\n   \n   return (np.round(u, 4).tolist(), np.round(s, 4).tolist(), np.round(v.T, 4).tolist())", "test_cases": ["assert svd_2x2_singular_values(np.array([[2, 1], [1, 2]])) == ([[0.7071, -0.7071], [0.7071, 0.7071]], [3.0, 1.0], [[0.7071, 0.7071], [-0.7071, 0.7071]])", "assert svd_2x2_singular_values(np.array([[1, 2], [3, 4]])) == ([[0.4046, 0.9145], [0.9145, -0.4046]], [5.465, 0.366], [[0.576, 0.8174], [-0.8174, 0.576]])"]}
{"id": 13, "difficulty": "hard", "category": "Linear Algebra", "title": "Determinant of a 4x4 Matrix using Laplace's Expansion", "description": "Write a Python function that calculates the determinant of a 4x4 matrix using Laplace's Expansion method. The function should take a single argument, a 4x4 matrix represented as a list of lists, and return the determinant of the matrix. The elements of the matrix can be integers or floating-point numbers. Implement the function recursively to handle the computation of determinants for the 3x3 minor matrices.", "inputs": ["determinant_4x4(matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]])"], "outputs": ["0"], "reasoning": ["Using Laplace's Expansion, the determinant of a 4x4 matrix is calculated by expanding it into minors and cofactors along any row or column. Given the symmetrical and linear nature of this specific matrix, its determinant is 0. The calculation for a generic 4x4 matrix involves more complex steps, breaking it down into the determinants of 3x3 matrices."], "import_code": "", "output_constrains": "", "entry_point": "determinant_4x4", "starter_code": "def determinant_4x4(matrix: list[list[int|float]]) -> float:", "reference_code": "def determinant_4x4(matrix: list[list[int|float]]) -> float:\n    # Base case: If the matrix is 1x1, return its single element\n    if len(matrix) == 1:\n        return matrix[0][0]\n    # Recursive case: Calculate determinant using Laplace's Expansion\n    det = 0\n    for c in range(len(matrix)):\n        minor = [row[:c] + row[c+1:] for row in matrix[1:]]  # Remove column c\n        cofactor = ((-1)**c) * determinant_4x4(minor)  # Compute cofactor\n        det += matrix[0][c] * cofactor  # Add to running total\n    return det", "test_cases": ["assert determinant_4x4([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == 0", "assert determinant_4x4([[4, 3, 2, 1], [3, 2, 1, 4], [2, 1, 4, 3], [1, 4, 3, 2]]) == -160", "assert determinant_4x4([[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]) == 0"]}
{"id": 14, "difficulty": "easy", "category": "Machine Learning", "title": "Linear Regression Using Normal Equation", "description": "Write a Python function that performs linear regression using the normal equation. The function should take a matrix X (features) and a vector y (target) as input, and return the coefficients of the linear regression model. Round your answer to four decimal places, -0.0 is a valid result for rounding a very small number.", "inputs": ["linear_regression_normal_equation(X = [[1, 1], [1, 2], [1, 3]], y = [1, 2, 3])"], "outputs": ["[0.0, 1.0]"], "reasoning": ["The linear model is y = 0.0 + 1.0*x, perfectly fitting the input data."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.", "entry_point": "linear_regression_normal_equation", "starter_code": "def linear_regression_normal_equation(X: list[list[float]], y: list[float]) -> list[float]:", "reference_code": "def linear_regression_normal_equation(X: list[list[float]], y: list[float]) -> list[float]:\n    X = np.array(X)\n    y = np.array(y).reshape(-1, 1)\n    X_transpose = X.T\n    theta = np.linalg.inv(X_transpose.dot(X)).dot(X_transpose).dot(y)\n    theta = np.round(theta, 4).flatten().tolist()\n    return theta", "test_cases": ["assert linear_regression_normal_equation([[1, 1], [1, 2], [1, 3]], [1, 2, 3]) == [0.0, 1.0]", "assert linear_regression_normal_equation([[1, 3, 4], [1, 2, 5], [1, 3, 2]], [1, 2, 1]) == [4.0, -1.0, -0.0]"]}
{"id": 15, "difficulty": "easy", "category": "Machine Learning", "title": "Linear Regression Using Gradient Descent", "description": "Write a Python function that performs linear regression using gradient descent. The function should take NumPy arrays X (features with a column of ones for the intercept) and y (target) as input, along with learning rate alpha and the number of iterations, and return the coefficients of the linear regression model as a list. Round your answer to four decimal places. -0.0 is a valid result for rounding a very small number.", "inputs": ["linear_regression_gradient_descent(X = np.array([[1, 1], [1, 2], [1, 3]]), y = np.array([1, 2, 3]), alpha = 0.01, iterations = 1000)"], "outputs": ["[0.1107, 0.9513]"], "reasoning": ["The linear model is y = 0.0 + 1.0*x, which fits the input data after gradient descent optimization."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "linear_regression_gradient_descent", "starter_code": "def linear_regression_gradient_descent(X: np.ndarray, y: np.ndarray, alpha: float, iterations: int) -> np.ndarray:", "reference_code": "def linear_regression_gradient_descent(X: np.ndarray, y: np.ndarray, alpha: float, iterations: int) -> np.ndarray:\n    m, n = X.shape\n    theta = np.zeros((n, 1))\n    for _ in range(iterations):\n        predictions = X @ theta\n        errors = predictions - y.reshape(-1, 1)\n        updates = X.T @ errors / m\n        theta -= alpha * updates\n    return np.round(theta.flatten(), 4).tolist()", "test_cases": ["assert linear_regression_gradient_descent(np.array([[1, 1], [1, 2], [1, 3]]), np.array([1, 2, 3]), 0.01, 1000) == [0.1107, 0.9513]"]}
{"id": 16, "difficulty": "easy", "category": "Machine Learning", "title": "Feature Scaling Implementation", "description": "Write a Python function that performs feature scaling on a dataset using both standardization and min-max normalization. The function should take a 2D NumPy array as input, where each row represents a data sample and each column represents a feature. It should return two 2D lists: one scaled by standardization and one by min-max normalization.", "inputs": ["feature_scaling(data = np.array([[1, 2], [3, 4], [5, 6]]))"], "outputs": ["([[-1.2247, -1.2247], [0.0, 0.0], [1.2247, 1.2247]], [[0.0, 0.0], [0.5, 0.5], [1.0, 1.0]])"], "reasoning": ["Standardization rescales the feature to have a mean of 0 and a standard deviation of 1. Min-max normalization rescales the feature to a range of [0, 1], where the minimum feature value maps to 0 and the maximum to 1."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "feature_scaling", "starter_code": "def feature_scaling(data: np.ndarray) -> (list[list[float]], list[list[float]]):", "reference_code": "def feature_scaling(data: np.ndarray) -> (list[list[float]], list[list[float]]):\n    # Standardization\n    mean = np.mean(data, axis=0)\n    std = np.std(data, axis=0)\n    standardized_data = (data - mean) / std\n    \n    # Min-Max Normalization\n    min_val = np.min(data, axis=0)\n    max_val = np.max(data, axis=0)\n    normalized_data = (data - min_val) / (max_val - min_val)\n    \n    return np.round(standardized_data,4).tolist(), np.round(normalized_data,4).tolist()", "test_cases": ["assert feature_scaling(np.array([[1, 2], [3, 4], [5, 6]])) == ([[-1.2247, -1.2247], [0.0, 0.0], [1.2247, 1.2247]], [[0.0, 0.0], [0.5, 0.5], [1.0, 1.0]])"]}
{"id": 17, "difficulty": "medium", "category": "Machine Learning", "title": "Polynomial Regression using Normal Equation", "description": "Write a Python function that implements the k-Means clustering algorithm. This function should take specific inputs and produce a list of final centroids. k-Means clustering is a method used to partition n points into k clusters. The goal is to group similar points together and represent each group by its center (called the centroid).\nFunction Inputs:\n- points: A list of points, where each point is a tuple of coordinates (e.g., (x, y) for 2D points)\n- k: An integer representing the number of clusters to form\n- initial_centroids: A list of initial centroid points, each a tuple of coordinates\n- max_iterations: An integer representing the maximum number of iterations to perform\nFunction Output:\n- A list of the final centroids of the clusters, where each centroid is rounded to the nearest fourth decimal.", "inputs": ["k_means_clustering(points = [(1, 2), (1, 4), (1, 0), (10, 2), (10, 4), (10, 0)], k = 2, initial_centroids = [(1, 1), (10, 1)], max_iterations = 10)"], "outputs": ["[(1, 2), (10, 2)]"], "reasoning": ["Given the initial centroids and a maximum of 10 iterations, the points are clustered around these points, and the centroids are updated to the mean of the assigned points, resulting in the final centroids which approximate the means of the two clusters. The exact number of iterations needed may vary, but the process will stop after 10 iterations at most."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.", "entry_point": "k_means_clustering", "starter_code": "def k_means_clustering(points: list[tuple[float, float]], k: int, initial_centroids: list[tuple[float, float]], max_iterations: int) -> list[tuple[float, float]]:", "reference_code": "def euclidean_distance(a, b):\n    return np.sqrt(((a - b) ** 2).sum(axis=1))\n\ndef k_means_clustering(points: list[tuple[float, float]], k: int, initial_centroids: list[tuple[float, float]], max_iterations: int) -> list[tuple[float, float]]:\n    points = np.array(points)\n    centroids = np.array(initial_centroids)\n    \n    for iteration in range(max_iterations):\n        # Assign points to the nearest centroid\n        distances = np.array([euclidean_distance(points, centroid) for centroid in centroids])\n        assignments = np.argmin(distances, axis=0)\n\n        new_centroids = np.array([points[assignments == i].mean(axis=0) if len(points[assignments == i]) > 0 else centroids[i] for i in range(k)])\n        \n        # Check for convergence\n        if np.all(centroids == new_centroids):\n            break\n        centroids = new_centroids\n        centroids = np.round(centroids,4)\n    return [tuple(centroid) for centroid in centroids]", "test_cases": ["assert k_means_clustering([(1, 2), (1, 4), (1, 0), (10, 2), (10, 4), (10, 0)], 2, [(1, 1), (10, 1)], 10) == [(1.0, 2.0), (10.0, 2.0)]", "assert k_means_clustering([(0, 0, 0), (2, 2, 2), (1, 1, 1), (9, 10, 9), (10, 11, 10), (12, 11, 12)], 2, [(1, 1, 1), (10, 10, 10)], 10) == [(1.0, 1.0, 1.0), (10.3333, 10.6667, 10.3333)]", "assert k_means_clustering([(1, 1), (2, 2), (3, 3), (4, 4)], 1, [(0,0)], 10) == [(2.5, 2.5)]", "assert k_means_clustering([(0, 0), (1, 0), (0, 1), (1, 1), (5, 5), (6, 5), (5, 6), (6, 6),(0, 5), (1, 5), (0, 6), (1, 6), (5, 0), (6, 0), (5, 1), (6, 1)], 4, [(0, 0), (0, 5), (5, 0), (5, 5)], 10) == [(0.5, 0.5), (0.5, 5.5), (5.5, 0.5), (5.5, 5.5)]"]}
{"id": 18, "difficulty": "easy", "category": "Machine Learning", "title": "Implement K-Fold Cross-Validation", "description": "Write a Python function to generate train and test splits for K-Fold Cross-Validation. Your task is to divide the dataset into k folds and return a list of train-test indices for each fold.", "inputs": ["k_fold_cross_validation(X = np.array([0,1,2,3,4,5,6,7,8,9]), y = np.array([0,1,2,3,4,5,6,7,8,9]), k=5, shuffle=False)"], "outputs": ["[([2, 3, 4, 5, 6, 7, 8, 9], [0, 1]), ([0, 1, 4, 5, 6, 7, 8, 9], [2, 3]), ([0, 1, 2, 3, 6, 7, 8, 9], [4, 5]), ([0, 1, 2, 3, 4, 5, 8, 9], [6, 7]), ([0, 1, 2, 3, 4, 5, 6, 7], [8, 9])]"], "reasoning": ["The function splits the dataset into 5 folds without shuffling and returns train-test splits for each iteration."], "import_code": "import numpy as np", "output_constrains": "", "entry_point": "k_fold_cross_validation", "starter_code": "def k_fold_cross_validation(X: np.ndarray, y: np.ndarray, k=5, shuffle=True, random_seed=None):", "reference_code": "def k_fold_cross_validation(X: np.ndarray, y: np.ndarray, k=5, shuffle=True, random_seed=None):\n    \"\"\"\n    Return train and test indices for k-fold cross-validation.\n    \"\"\"\n    n_samples = len(X)\n    indices = np.arange(n_samples)\n    \n    if shuffle:\n        if random_seed is not None:\n            np.random.seed(random_seed)\n        np.random.shuffle(indices)\n    \n    fold_sizes = np.full(k, n_samples // k, dtype=int)\n    fold_sizes[:n_samples % k] += 1\n\n    current = 0\n    folds = []\n    for fold_size in fold_sizes:\n        folds.append(indices[current:current + fold_size])\n        current += fold_size\n\n    result = []\n    for i in range(k):\n        test_idx = folds[i]\n        train_idx = np.concatenate(folds[:i] + folds[i+1:])\n        result.append((train_idx.tolist(), test_idx.tolist()))\n    \n    return result", "test_cases": ["assert k_fold_cross_validation(np.array([0,1,2,3,4,5,6,7,8,9]), np.array([0,1,2,3,4,5,6,7,8,9]), k=5, shuffle=False) == [([2, 3, 4, 5, 6, 7, 8, 9], [0, 1]), ([0, 1, 4, 5, 6, 7, 8, 9], [2, 3]), ([0, 1, 2, 3, 6, 7, 8, 9], [4, 5]), ([0, 1, 2, 3, 4, 5, 8, 9], [6, 7]), ([0, 1, 2, 3, 4, 5, 6, 7], [8, 9])]", "assert k_fold_cross_validation(np.array([0,1,2,3,4,5,6,7,8,9]), np.array([0,1,2,3,4,5,6,7,8,9]), k=2, shuffle=True, random_seed=42) == [([2, 9, 4, 3, 6], [8, 1, 5, 0, 7]), ([8, 1, 5, 0, 7], [2, 9, 4, 3, 6])]", "assert k_fold_cross_validation(np.array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]), np.array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]), k=3, shuffle=False) == [([5, 6, 7, 8, 9, 10, 11, 12, 13, 14], [0, 1, 2, 3, 4]), ([0, 1, 2, 3, 4, 10, 11, 12, 13, 14], [5, 6, 7, 8, 9]), ([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [10, 11, 12, 13, 14])]", "assert k_fold_cross_validation(np.array([0,1,2,3,4,5,6,7,8,9]), np.array([0,1,2,3,4,5,6,7,8,9]), k=2, shuffle=False) == [([5, 6, 7, 8, 9], [0, 1, 2, 3, 4]), ([0, 1, 2, 3, 4], [5, 6, 7, 8, 9])]"]}
{"id": 19, "difficulty": "medium", "category": "Machine Learning", "title": "Principal Component Analysis (PCA) Implementation", "description": "Write a Python function that performs Principal Component Analysis (PCA) from scratch. The function should take a 2D NumPy array as input, where each row represents a data sample and each column represents a feature. The function should standardize the dataset, compute the covariance matrix, find the eigenvalues and eigenvectors, and return the principal components (the eigenvectors corresponding to the largest eigenvalues). The function should also take an integer k as input, representing the number of principal components to return.", "inputs": ["pca(data = np.array([[1, 2], [3, 4], [5, 6]]), k = 1)"], "outputs": ["[[0.7071], [0.7071]]"], "reasoning": ["After standardizing the data and computing the covariance matrix, the eigenvalues and eigenvectors are calculated. The largest eigenvalue's corresponding eigenvector is returned as the principal component, rounded to four decimal places."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.", "entry_point": "pca", "starter_code": "def pca(data: np.ndarray, k: int) -> list[list[float]]:", "reference_code": "def pca(data: np.ndarray, k: int) -> list[list[float]]:\n    # Standardize the data\n    data_standardized = (data - np.mean(data, axis=0)) / np.std(data, axis=0)\n    \n    # Compute the covariance matrix\n    covariance_matrix = np.cov(data_standardized, rowvar=False)\n    \n    # Eigen decomposition\n    eigenvalues, eigenvectors = np.linalg.eig(covariance_matrix)\n    \n    # Sort the eigenvectors by decreasing eigenvalues\n    idx = np.argsort(eigenvalues)[::-1]\n    eigenvalues_sorted = eigenvalues[idx]\n    eigenvectors_sorted = eigenvectors[:,idx]\n    \n    # Select the top k eigenvectors (principal components)\n    principal_components = eigenvectors_sorted[:, :k]\n    \n    return np.round(principal_components, 4).tolist()", "test_cases": ["assert pca(np.array([[4,2,1],[5,6,7],[9,12,1],[4,6,7]]),2) == [[0.6855, 0.0776], [0.6202, 0.4586], [-0.3814, 0.8853]]", "assert pca(np.array([[1, 2], [3, 4], [5, 6]]), 1) == [[0.7071], [0.7071]]"]}
{"id": 20, "difficulty": "hard", "category": "Machine Learning", "title": "Decision Tree Learning", "description": "Write a Python function that implements the decision tree learning algorithm for classification. The function should use recursive binary splitting based on entropy and information gain to build a decision tree. It should take a list of examples (each example is a dict of attribute-value pairs) and a list of attribute names as input, and return a nested dictionary representing the decision tree.", "inputs": ["learn_decision_tree(examples = [ {'Outlook': 'Sunny', 'Temperature': 'Hot', 'Humidity': 'High', 'Wind': 'Weak', 'PlayTennis': 'No'}, {'Outlook': 'Sunny', 'Temperature': 'Hot', 'Humidity': 'High', 'Wind': 'Strong', 'PlayTennis': 'No'}, {'Outlook': 'Overcast', 'Temperature': 'Hot', 'Humidity': 'High', 'Wind': 'Weak', 'PlayTennis': 'Yes'}, {'Outlook': 'Rain', 'Temperature': 'Mild', 'Humidity': 'High', 'Wind': 'Weak', 'PlayTennis': 'Yes'}], attributes = ['Outlook', 'Temperature', 'Humidity', 'Wind'], target_attr = 'PlayTennis')"], "outputs": ["{'Outlook': { 'Sunny': {'Humidity': {'High': 'No', 'Normal': 'Yes'}}, 'Overcast': 'Yes', 'Rain': {'Wind': {'Weak': 'Yes', 'Strong': 'No'}}}}"], "reasoning": ["Using the given examples, the decision tree algorithm determines that 'Outlook' is the best attribute to split the data initially. When 'Outlook' is 'Overcast', the outcome is always 'Yes', so it becomes a leaf node. In cases of 'Sunny' and 'Rain', it further splits based on 'Humidity' and 'Wind', respectively. The resulting tree structure is able to classify the training examples with the attributes 'Outlook', 'Temperature', 'Humidity', and 'Wind'."], "import_code": "import math\nfrom collections import Counter", "output_constrains": "", "entry_point": "learn_decision_tree", "starter_code": "def learn_decision_tree(examples: list[dict], attributes: list[str], target_attr: str) -> dict:", "reference_code": "def calculate_entropy(labels):\n    label_counts = Counter(labels)\n    total_count = len(labels)\n    entropy = -sum((count / total_count) * math.log2(count / total_count) for count in label_counts.values())\n    return entropy\n\ndef calculate_information_gain(examples, attr, target_attr):\n    total_entropy = calculate_entropy([example[target_attr] for example in examples])\n    values = set(example[attr] for example in examples)\n    attr_entropy = 0\n    for value in values:\n        value_subset = [example[target_attr] for example in examples if example[attr] == value]\n        value_entropy = calculate_entropy(value_subset)\n        attr_entropy += (len(value_subset) / len(examples)) * value_entropy\n    return total_entropy - attr_entropy\n\ndef majority_class(examples, target_attr):\n    return Counter([example[target_attr] for example in examples]).most_common(1)[0][0]\n\ndef learn_decision_tree(examples: list[dict], attributes: list[str], target_attr: str) -> dict:\n    if not examples:\n        return 'No examples'\n    if all(example[target_attr] == examples[0][target_attr] for example in examples):\n        return examples[0][target_attr]\n    if not attributes:\n        return majority_class(examples, target_attr)\n    \n    gains = {attr: calculate_information_gain(examples, attr, target_attr) for attr in attributes}\n    best_attr = max(gains, key=gains.get)\n    tree = {best_attr: {}}\n    \n    for value in set(example[best_attr] for example in examples):\n        subset = [example for example in examples if example[best_attr] == value]\n        new_attributes = attributes.copy()\n        new_attributes.remove(best_attr)\n        subtree = learn_decision_tree(subset, new_attributes, target_attr)\n        tree[best_attr][value] = subtree\n    \n    return tree", "test_cases": ["assert learn_decision_tree([ {'Outlook': 'Sunny', 'Wind': 'Weak', 'PlayTennis': 'No'}, {'Outlook': 'Overcast', 'Wind': 'Strong', 'PlayTennis': 'Yes'}, {'Outlook': 'Rain', 'Wind': 'Weak', 'PlayTennis': 'Yes'}, {'Outlook': 'Sunny', 'Wind': 'Strong', 'PlayTennis': 'No'}, {'Outlook': 'Sunny', 'Wind': 'Weak', 'PlayTennis': 'Yes'}, {'Outlook': 'Overcast', 'Wind': 'Weak', 'PlayTennis': 'Yes'}, {'Outlook': 'Rain', 'Wind': 'Strong', 'PlayTennis': 'No'}, {'Outlook': 'Rain', 'Wind': 'Weak', 'PlayTennis': 'Yes'} ], ['Outlook', 'Wind'], 'PlayTennis') == {'Outlook': {'Sunny': {'Wind': {'Weak': 'No', 'Strong': 'No'}}, 'Rain': {'Wind': {'Weak': 'Yes', 'Strong': 'No'}}, 'Overcast': 'Yes'}}"]}
{"id": 21, "difficulty": "hard", "category": "Machine Learning", "title": "Pegasos Kernel SVM Implementation", "description": "Write a Python function that implements a deterministic version of the Pegasos algorithm to train a kernel SVM classifier from scratch. The function should take a dataset (as a 2D NumPy array where each row represents a data sample and each column represents a feature), a label vector (1D NumPy array where each entry corresponds to the label of the sample), and training parameters such as the choice of kernel (linear or RBF), regularization parameter (lambda), and the number of iterations. Note that while the original Pegasos algorithm is stochastic (it selects a single random sample at each step), this problem requires using all samples in every iteration (i.e., no random sampling). The function should perform binary classification and return the model's alpha coefficients and bias.", "inputs": ["pegasos_kernel_svm(data = np.array([[1, 2], [2, 3], [3, 1], [4, 1]]), labels = np.array([1, 1, -1, -1]), kernel = 'rbf', lambda_val = 0.01, iterations = 100)"], "outputs": ["([0.03, 0.02, 0.05, 0.01], -0.05)"], "reasoning": ["Using the RBF kernel, the Pegasos algorithm iteratively updates the weights based on a sub-gradient descent method, taking into account the non-linear separability of the data induced by the kernel transformation."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "pegasos_kernel_svm", "starter_code": "def pegasos_kernel_svm(data: np.ndarray, labels: np.ndarray, kernel='linear', lambda_val=0.01, iterations=100, sigma=1.0):", "reference_code": "def linear_kernel(x, y):\n    return np.dot(x, y)\n\ndef rbf_kernel(x, y, sigma=1.0):\n    return np.exp(-np.linalg.norm(x-y)**2 / (2 * (sigma ** 2)))\n\ndef pegasos_kernel_svm(data: np.ndarray, labels: np.ndarray, kernel='linear', lambda_val=0.01, iterations=100, sigma=1.0):\n    n_samples = len(data)\n    alphas = np.zeros(n_samples)\n    b = 0\n\n    for t in range(1, iterations + 1):\n        for i in range(n_samples):\n            eta = 1.0 / (lambda_val * t)\n            if kernel == 'linear':\n                kernel_func = linear_kernel\n            elif kernel == 'rbf':\n                kernel_func = lambda x, y: rbf_kernel(x, y, sigma)\n    \n            decision = sum(alphas[j] * labels[j] * kernel_func(data[j], data[i]) for j in range(n_samples)) + b\n            if labels[i] * decision < 1:\n                alphas[i] += eta * (labels[i] - lambda_val * alphas[i])\n                b += eta * labels[i]\n\n    return np.round(alphas,4).tolist(), np.round(b,4)", "test_cases": ["assert pegasos_kernel_svm(np.array([[1, 2], [2, 3], [3, 1], [4, 1]]), np.array([1, 1, -1, -1]), kernel='linear', lambda_val=0.01, iterations=100) == ([100.0, 0.0, -100.0, -100.0], -937.4755)", "assert pegasos_kernel_svm(np.array([[1, 2], [2, 3], [3, 1], [4, 1]]), np.array([1, 1, -1, -1]), kernel='rbf', lambda_val=0.01, iterations=100, sigma=0.5) == ([100.0, 99.0, -100.0, -100.0], -115.0)", "assert pegasos_kernel_svm(np.array([[2, 1], [3, 2], [1, 3], [1, 4]]), np.array([-1, -1, 1, 1]), kernel='rbf', lambda_val=0.01, iterations=100, sigma=0.5) == ([-100.0, 0.0, 100.0, 90.6128], -102.8081)", "assert pegasos_kernel_svm(np.array([[2, 1], [3, 2], [1, 3], [1, 4]]), np.array([-1, -1, 1, 1]), kernel='linear', lambda_val=0.01, iterations=100) == ([-100.0, -100.0, 0.0, 0.0], -1037.4755)"]}
{"id": 22, "difficulty": "easy", "category": "Deep Learning", "title": "Sigmoid Activation Function Understanding", "description": "Write a Python function that computes the output of the sigmoid activation function given an input value z. The function should return the output rounded to four decimal places.", "inputs": ["sigmoid(z = 0)"], "outputs": ["0.5"], "reasoning": ["The sigmoid function is defined as $\\sigma (z) = 1 / (1 + exp(-z))$. For z = 0, exp(-0) = 1, hence the output is 1 / (1 + 1) = 0.5."], "import_code": "import math", "output_constrains": "", "entry_point": "sigmoid", "starter_code": "def sigmoid(z: float) -> float:", "reference_code": "def sigmoid(z: float) -> float:\n   result = 1 / (1 + math.exp(-z))\n   return round(result, 4)", "test_cases": ["assert sigmoid(0) == 0.5", "assert sigmoid(1) == 0.7311", "assert sigmoid(-1) == 0.2689"]}
{"id": 23, "difficulty": "easy", "category": "Deep Learning", "title": "Softmax Activation Function Implementation", "description": "Write a Python function that computes the softmax activation for a given list of scores. The function should return the softmax values as a list, each rounded to four decimal places.", "inputs": ["softmax(scores = [1, 2, 3])"], "outputs": ["[0.0900, 0.2447, 0.6652]"], "reasoning": ["The softmax function converts a list of values into a probability distribution. The probabilities are proportional to the exponential of each element divided by the sum of the exponentials of all elements in the list."], "import_code": "import math", "output_constrains": "", "entry_point": "softmax", "starter_code": "def softmax(scores: list[float]) -> list[float]:", "reference_code": "def softmax(scores: list[float]) -> list[float]:\n    exp_scores = [math.exp(score) for score in scores]\n    sum_exp_scores = sum(exp_scores)\n    probabilities = [round(score / sum_exp_scores, 4) for score in exp_scores]\n    return probabilities", "test_cases": ["assert softmax([1, 2, 3]) == [0.09, 0.2447, 0.6652]", "assert softmax([1, 1, 1]) == [0.3333, 0.3333, 0.3333]", "assert softmax([-1, 0, 5]) == [0.0025, 0.0067, 0.9909]"]}
{"id": 24, "difficulty": "easy", "category": "Deep Learning", "title": "Single Neuron", "description": "Write a Python function that simulates a single neuron with a sigmoid activation function for binary classification, handling multidimensional input features. The function should take a list of feature vectors (each vector representing multiple features for an example), associated true binary labels, and the neuron's weights (one for each feature) and bias as input. It should return the predicted probabilities after sigmoid activation and the mean squared error between the predicted probabilities and the true labels, both rounded to four decimal places.", "inputs": ["single_neuron_model(features = [[0.5, 1.0], [-1.5, -2.0], [2.0, 1.5]], labels = [0, 1, 0], weights = [0.7, -0.4], bias = -0.1)"], "outputs": ["([0.4626, 0.4134, 0.6682], 0.3349)"], "reasoning": ["For each input vector, the weighted sum is calculated by multiplying each feature by its corresponding weight, adding these up along with the bias, then applying the sigmoid function to produce a probability. The MSE is calculated as the average squared difference between each predicted probability and the corresponding true label."], "import_code": "import math", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "single_neuron_model", "starter_code": "def single_neuron_model(features: list[list[float]], labels: list[int], weights: list[float], bias: float) -> (list[float], float):", "reference_code": "def single_neuron_model(features: list[list[float]], labels: list[int], weights: list[float], bias: float) -> (list[float], float):\n    probabilities = []\n    for feature_vector in features:\n        z = sum(weight * feature for weight, feature in zip(weights, feature_vector)) + bias\n        prob = 1 / (1 + math.exp(-z))\n        probabilities.append(round(prob, 4))\n    \n    mse = sum((prob - label) ** 2 for prob, label in zip(probabilities, labels)) / len(labels)\n    mse = round(mse, 4)\n    \n    return probabilities, mse", "test_cases": ["assert single_neuron_model([[0.5, 1.0], [-1.5, -2.0], [2.0, 1.5]], [0, 1, 0], [0.7, -0.4], -0.1) == ([0.4626, 0.4134, 0.6682], 0.3349)", "assert single_neuron_model([[1, 2], [2, 3], [3, 1]], [1, 0, 1], [0.5, -0.2], 0) == ([0.525, 0.5987, 0.7858], 0.21)", "assert single_neuron_model([[2, 3], [3, 1], [1, 2]], [1, 0, 1], [0.5, -0.2], 1) == ([0.8022, 0.9089, 0.7503], 0.3092)"]}
{"id": 25, "difficulty": "medium", "category": "Deep Learning", "title": "Single Neuron with Backpropagation", "description": "Write a Python function that simulates a single neuron with sigmoid activation, and implements backpropagation to update the neuron's weights and bias. The function should take a list of feature vectors, associated true binary labels, initial weights, initial bias, a learning rate, and the number of epochs. The function should update the weights and bias using gradient descent based on the MSE loss, and return the updated weights, bias, and a list of MSE values for each epoch, each rounded to four decimal places.", "inputs": ["train_neuron(features = [[1.0, 2.0], [2.0, 1.0], [-1.0, -2.0]], labels = [1, 0, 0], initial_weights = [0.1, -0.2], initial_bias = 0.0, learning_rate = 0.1, epochs = 2)"], "outputs": ["updated_weights = [0.1036, -0.1425], updated_bias = -0.0167, mse_values = [0.3033, 0.2942]"], "reasoning": ["The neuron receives feature vectors and computes predictions using the sigmoid activation. Based on the predictions and true labels, the gradients of MSE loss with respect to weights and bias are computed and used to update the model parameters across epochs."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "train_neuron", "starter_code": "def train_neuron(features: np.ndarray, labels: np.ndarray, initial_weights: np.ndarray, initial_bias: float, learning_rate: float, epochs: int) -> (np.ndarray, float, list[float]):", "reference_code": "def sigmoid(x):\n    return 1 / (1 + np.exp(-x))\n\ndef train_neuron(features: np.ndarray, labels: np.ndarray, initial_weights: np.ndarray, initial_bias: float, learning_rate: float, epochs: int) -> (np.ndarray, float, list[float]):\n    weights = np.array(initial_weights)\n    bias = initial_bias\n    features = np.array(features)\n    labels = np.array(labels)\n    mse_values = []\n\n    for _ in range(epochs):\n        z = np.dot(features, weights) + bias\n        predictions = sigmoid(z)\n        \n        mse = np.mean((predictions - labels) ** 2)\n        mse_values.append(round(mse, 4))\n\n        # Gradient calculation for weights and bias\n        errors = predictions - labels\n        weight_gradients = (2/len(labels)) * np.dot(features.T, errors * predictions * (1 - predictions))\n        bias_gradient = (2/len(labels)) * np.sum(errors * predictions * (1 - predictions))\n        \n        # Update weights and bias\n        weights -= learning_rate * weight_gradients\n        bias -= learning_rate * bias_gradient\n\n        # Round weights and bias for output\n        updated_weights = np.round(weights, 4)\n        updated_bias = round(bias, 4)\n\n    return updated_weights.tolist(), updated_bias, mse_values", "test_cases": ["assert train_neuron(np.array([[1.0, 2.0], [2.0, 1.0], [-1.0, -2.0]]), np.array([1, 0, 0]), np.array([0.1, -0.2]), 0.0, 0.1, 2) == ([0.1036, -0.1425], -0.0167, [0.3033, 0.2942])", "assert train_neuron(np.array([[1, 2], [2, 3], [3, 1]]), np.array([1, 0, 1]), np.array([0.5, -0.2]), 0, 0.1, 3) == ([0.4892, -0.2301], 0.0029, [0.21, 0.2087, 0.2076])", "assert train_neuron(np.array([[1, 3], [2, 1], [-1, -3]]), np.array([1, 0, 0]), np.array([-0.1, -0.2]), 0.0, 0.1, 2) == ([-0.087, -0.0951], -0.0131, [0.3513, 0.3227])"]}
{"id": 26, "difficulty": "medium", "category": "Deep Learning", "title": "Implementing Basic Autograd Operations", "description": "Special thanks to Andrej Karpathy for making a video about this, if you haven't already check out his videos on YouTube https://youtu.be/VMj-3S1tku0?si=gjlnFP4o3JRN9dTg. Write a Python class similar to the provided 'Value' class that implements the basic autograd operations: addition, multiplication, and ReLU activation. The class should handle scalar values and should correctly compute gradients for these operations through automatic differentiation.", "inputs": ["a = Value(2)\nb = Value(-3)\nc = Value(10)\nd = a + b * c\ne = d.relu()\ne.backward()\na.data, a.grad, b.data, b.grad, c.data, c.grad, d.data, d.grad, e.data, e.grad"], "outputs": ["(2, 0, -3, 0, 10, 0, -28, 0, 0, 1)"], "reasoning": ["The output reflects the forward computation and gradients after backpropagation. The ReLU on 'd' zeros out its output and gradient due to the negative data value."], "import_code": "", "output_constrains": "", "entry_point": "Value", "starter_code": "class Value:\n    def __init__(self, data, _children=(), _op=''):\n        self.data = data\n        self.grad = 0\n        self._backward = lambda: None\n        self._prev = set(_children)\n        self._op = _op", "reference_code": "class Value:\n    def __init__(self, data, _children=(), _op=''):\n        self.data = data\n        self.grad = 0\n        self._backward = lambda: None\n        self._prev = set(_children)\n        self._op = _op\n\n    def __add__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data + other.data, (self, other), '+')\n        def _backward():\n            self.grad += out.grad\n            other.grad += out.grad\n        out._backward = _backward\n        return out\n\n    def __mul__(self, other):\n        other = other if isinstance(other, Value) else Value(other)\n        out = Value(self.data * other.data, (self, other), '*')\n        def _backward():\n            self.grad += other.data * out.grad\n            other.grad += self.data * out.grad\n        out._backward = _backward\n        return out\n\n    def relu(self):\n        out = Value(0 if self.data < 0 else self.data, (self,), 'ReLU')\n        def _backward():\n            self.grad += (out.data > 0) * out.grad\n        out._backward = _backward\n        return out\n\n    def backward(self):\n        topo = []\n        visited = set()\n        def build_topo(v):\n            if v not in visited:\n                visited.add(v)\n                for child in v._prev:\n                    build_topo(child)\n                topo.append(v)\n        build_topo(self)\n        self.grad = 1\n        for v in reversed(topo):\n            v._backward()", "test_cases": ["a = Value(2)\nb = Value(3)\nc = Value(10)\nd = a + b * c \ne = Value(7) * Value(2)\nf = e + d\ng = f.relu() \ng.backward()\n\nassert a.data, a.grad == (2, 1)\nassert b.data, b.grad == (3, 10)\nassert c.data, c.grad == (10, 3)\nassert d.data, d.grad == (32, 1)\nassert e.data, e.grad == (14, 1)\nassert f.data, f.grad == (46, 1)\nassert g.data, g.grad == (46, 1)", "a = Value(3)\nb = Value(4)\nc = Value(2)\nd = a * b + c \nd.backward()\n\nassert a.data, a.grad == (3, 1)\nassert b.data, b.grad == (4, 1)\nassert c.data, c.grad == (2, 1)\nassert d.data, d.grad == (14, 1)", "a = Value(3)\nb = Value(4)\nc = Value(5)\nd = b * c \ne = a + d * b\ne.backward() \n\nassert a.data, a.grad == (3, 1)\nassert b.data, b.grad == (4, 1)\nassert c.data, c.grad == (5, 1)\nassert d.data, d.grad == (20, 1)\nassert e.data, e.grad == (83, 1)"]}
{"id": 27, "difficulty": "easy", "category": "Linear Algebra", "title": "Transformation Matrix from Basis B to C", "description": "Given basis vectors in two different bases B and C for R^3, write a Python function to compute the transformation matrix P from basis B to C.", "inputs": ["transform_basis(B = [[1, 0, 0], [0, 1, 0], [0, 0, 1]], C = [[1, 2.3, 3], [4.4, 25, 6], [7.4, 8, 9]])"], "outputs": ["[[-0.6772, -0.0126, 0.2342], [-0.0184, 0.0505, -0.0275], [0.5732, -0.0345, -0.0569]]"], "reasoning": ["The transformation matrix P from basis B to C can be found using matrix operations involving the inverse of matrix C."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "transform_basis", "starter_code": "def transform_basis(B: list[list[int]], C: list[list[int]]) -> list[list[float]]:", "reference_code": "def transform_basis(B: list[list[int]], C: list[list[int]]) -> list[list[float]]:\n    C = np.array(C)\n    B = np.array(B)\n    C_inv = np.linalg.inv(C)\n    P = np.dot(C_inv, B)\n    return np.round(P, 4).tolist()", "test_cases": ["assert transform_basis([[1, 0, 0], [0, 1, 0], [0, 0, 1]], [[1, 2.3, 3], [4.4, 25, 6], [7.4, 8, 9]]) == [[-0.6772, -0.0126, 0.2342], [-0.0184, 0.0505, -0.0275], [0.5732, -0.0345, -0.0569]]", "assert transform_basis([[1,0],[0,1]],[[1,2],[9,2]]) == [[-0.125, 0.125 ],[ 0.5625, -0.0625]]", "assert transform_basis([[-1, 0], [3, 4]], [[2, -1], [0, 1]]) == [[1, 2], [3, 4]]", "assert transform_basis([[4, 8], [2, 4]], [[2, 1], [0, 1]]) == [[1, 2], [2, 4]]"]}
{"id": 28, "difficulty": "hard", "category": "Linear Algebra", "title": "SVD of a 2x2 Matrix using eigen values & vectors", "description": "Given a 2x2 matrix, write a Python function to compute its Singular Value Decomposition (SVD). The function should return the matrices U, S, and V such that A = U * S * V, use the method described in this post https://metamerist.blogspot.com/2006/10/linear-algebra-for-graphics-geeks-svd.html", "inputs": ["svd_2x2(A = np.array([[-10, 8], [10, -1]]))"], "outputs": ["([[0.8, -0.6], [-0.6, -0.8]], [15.6525, 4.4721], [[-0.8944, 0.4472], [-0.4472, -0.8944]])"], "reasoning": ["The SVD of the matrix A is calculated using the eigenvalues and eigenvectors of A^T A and A A^T. The singular values are the square roots of the eigenvalues, and the eigenvectors form the columns of matrices U and V."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "svd_2x2", "starter_code": "def svd_2x2(A: np.ndarray) -> tuple:", "reference_code": "def svd_2x2(A: np.ndarray) -> tuple:\n    y1, x1 = (A[1, 0] + A[0, 1]), (A[0, 0] - A[1, 1])\n    y2, x2 = (A[1, 0] - A[0, 1]), (A[0, 0] + A[1, 1])\n\n    h1 = np.sqrt(y1**2 + x1**2)\n    h2 = np.sqrt(y2**2 + x2**2)\n\n    t1 = x1 / h1\n    t2 = x2 / h2\n\n    cc = np.sqrt((1.0 + t1) * (1.0 + t2))\n    ss = np.sqrt((1.0 - t1) * (1.0 - t2))\n    cs = np.sqrt((1.0 + t1) * (1.0 - t2))\n    sc = np.sqrt((1.0 - t1) * (1.0 + t2))\n\n    c1, s1 = (cc - ss) / 2.0, (sc + cs) / 2.0\n    U = np.array([[-c1, -s1], [-s1, c1]])\n\n    s = np.array([(h1 + h2) / 2.0, abs(h1 - h2) / 2.0])\n\n    V = np.diag(1.0 / s) @ U.T @ A\n\n    return np.round(U, 4).tolist(), np.round(s, 4).tolist(), np.round(V, 4).tolist()", "test_cases": ["assert svd_2x2(np.array([[-10, 8], [10, -1]])) == ([[0.8, -0.6], [-0.6, -0.8]], [15.6525, 4.4721], [[-0.8944, 0.4472], [-0.4472, -0.8944]])", "assert svd_2x2(np.array([[1, 2], [3, 4]])) == ([[-0.4046, -0.9145], [-0.9145, 0.4046]], [5.465, 0.366], [[-0.576, -0.8174], [0.8174, -0.576]])", "assert svd_2x2(np.array([[3, 5], [7, 9]])) == ([[-0.4538, -0.8911], [-0.8911, 0.4538]], [12.791, 0.6254], [[-0.5941, -0.8044], [0.8044, -0.5941]])"]}
{"id": 29, "difficulty": "easy", "category": "Machine Learning", "title": "Random Shuffle of Dataset", "description": "Write a Python function to perform a random shuffle of the samples in two numpy arrays, X and y, while maintaining the corresponding order between them. The function should have an optional seed parameter for reproducibility.", "inputs": ["shuffle_data(X = np.array([[1, 2], [3, 4], [5, 6], [7, 8]]), y = np.array([1, 2, 3, 4]), seed=42)"], "outputs": ["([[3, 4], [7, 8], [1, 2], [5, 6]], [2, 4, 1, 3])"], "reasoning": ["The samples in X and y are shuffled randomly, maintaining the correspondence between the samples in both arrays."], "import_code": "import numpy as np", "output_constrains": "Return python list after reshaping by using numpy's tolist() method.", "entry_point": "shuffle_data", "starter_code": "def shuffle_data(X, y, seed=None):", "reference_code": "def shuffle_data(X, y, seed=None):\n    if seed:\n        np.random.seed(seed)\n    idx = np.arange(X.shape[0])\n    np.random.shuffle(idx)\n    return X[idx].tolist(), y[idx].tolist()", "test_cases": ["assert shuffle_data(np.array([[1, 2], [3, 4], [5, 6], [7, 8]]), np.array([1, 2, 3, 4]), seed=42) == ([[3, 4], [7, 8], [1, 2], [5, 6]], [2, 4, 1, 3])", "assert shuffle_data(np.array([[1, 1], [2, 2], [3, 3], [4, 4]]), np.array([10, 20, 30, 40]), seed=24) == ([[4, 4],[2, 2],[1, 1],[3, 3]], [40, 20, 10, 30])", "assert shuffle_data(np.array([[1, 2], [3, 4], [5, 6], [7, 8]]), np.array([4, 6, 7, 8]), seed=10) == ([[5, 6], [1, 2], [7, 8], [3, 4]], [7, 4, 8, 6])", "assert shuffle_data(np.array([[1, 3], [3, 6], [5, 8], [7, 11]]), np.array([4, 5, 6, 7]), seed=20) == ([[1, 3], [3, 6], [5, 8], [7, 11]], [4, 5, 6, 7])"]}
{"id": 30, "difficulty": "easy", "category": "Machine Learning", "title": "Batch Iterator for Dataset", "description": "Implement a batch iterable function that samples in a numpy array X and an optional numpy array y. The function should yield batches of a specified size. If y is provided, the function should yield batches of (X, y) pairs; otherwise, it should yield batches of X only.", "inputs": ["batch_iterator(X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]), y = np.array([1, 2, 3, 4, 5]), batch_size=2)"], "outputs": ["[[[[1, 2], [3, 4]], [1, 2]], [[[5, 6], [7, 8]], [3, 4]], [[[9, 10]], [5]]]"], "reasoning": ["The dataset X contains 5 samples, and we are using a batch size of 2. Therefore, the function will divide the dataset into 3 batches. The first two batches will contain 2 samples each, and the last batch will contain the remaining sample. The corresponding values from y are also included in each batch."], "import_code": "import numpy as np", "output_constrains": "Return python list after reshaping by using numpy's tolist() method.", "entry_point": "batch_iterator", "starter_code": "def batch_iterator(X, y=None, batch_size=64):", "reference_code": "def batch_iterator(X, y=None, batch_size=64):\n    n_samples = X.shape[0]\n    batches = []\n    for i in np.arange(0, n_samples, batch_size):\n        begin, end = i, min(i+batch_size, n_samples)\n        if y is not None:\n            batches.append([X[begin:end].tolist(), y[begin:end].tolist()])\n        else:\n            batches.append( X[begin:end].tolist())\n    return batches", "test_cases": ["assert batch_iterator(np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]), np.array([1, 2, 3, 4, 5]), batch_size=2) == [[[[1, 2], [3, 4]], [1, 2]], [[[5, 6], [7, 8]], [3, 4]], [[[9, 10]], [5]]]", "assert batch_iterator(np.array([[1, 1], [2, 2], [3, 3], [4, 4]]), batch_size=3) == [[[1, 1], [2, 2], [3, 3]], [[4, 4]]]", "assert batch_iterator(np.array([[1, 3], [3, 6], [5, 8], [7, 11]]), batch_size=2) == [[[1, 3], [3, 6]], [[5, 8], [7, 11]]]", "assert batch_iterator(np.array([[1, 3], [3, 6], [5, 8], [7, 11]]), np.array([4, 5, 6, 7]), batch_size=2) == [[[[1, 3], [3, 6]], [4, 5]], [[[5, 8], [7, 11]], [6, 7]]]"]}
{"id": 31, "difficulty": "medium", "category": "Machine Learning", "title": "Divide Dataset Based on Feature Threshold", "description": "Write a Python function to divide a dataset based on whether the value of a specified feature is greater than or equal to a given threshold. The function should return two subsets of the dataset: one with samples that meet the condition and another with samples that do not.", "inputs": ["divide_on_feature(X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]), feature_i = 0, threshold = 5)"], "outputs": ["[[[5, 6], [7, 8], [9, 10]], [[1, 2], [3, 4]]]"], "reasoning": ["The dataset X is divided based on whether the value in the 0th feature (first column) is greater than or equal to 5. Samples with the first column value >= 5 are in the first subset, and the rest are in the second subset."], "import_code": "import numpy as np", "output_constrains": "Return python list after reshaping by using numpy's tolist() method.", "entry_point": "divide_on_feature", "starter_code": "def divide_on_feature(X, feature_i, threshold):", "reference_code": "def divide_on_feature(X, feature_i, threshold):\n    # Define the split function based on the threshold type\n    split_func = None\n    if isinstance(threshold, int) or isinstance(threshold, float):\n        # For numeric threshold, check if feature value is greater than or equal to the threshold\n        split_func = lambda sample: sample[feature_i] >= threshold\n    else:\n        # For non-numeric threshold, check if feature value is equal to the threshold\n        split_func = lambda sample: sample[feature_i] == threshold\n\n    # Create two subsets based on the split function\n    X_1 = np.array([sample for sample in X if split_func(sample)]).tolist()\n    X_2 = np.array([sample for sample in X if not split_func(sample)]).tolist()\n\n    # Return the two subsets\n    return [X_1, X_2]", "test_cases": ["assert divide_on_feature(np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]), 0, 5) == [[[5, 6], [7, 8], [9, 10]], [[1, 2], [3, 4]]]", "assert divide_on_feature(np.array([[1, 1], [2, 2], [3, 3], [4, 4]]), 1, 3) == [[[3, 3], [4, 4]], [[1, 1], [2, 2]]]", "assert divide_on_feature(np.array([[1, 3], [3, 6], [5, 8], [7, 11]]), 0, 2) ==  [[[3, 6], [5, 8], [7, 11]], [[1, 3]]]", "assert divide_on_feature(np.array([[1, 3, 9], [6, 3, 6], [10, 5, 8], [9, 7, 11]]), 1, 5) ==  [[[10, 5, 8], [9, 7, 11]], [[1, 3, 9], [6, 3, 6]]]"]}
{"id": 32, "difficulty": "medium", "category": "Machine Learning", "title": "Generate Polynomial Features", "description": "Write a Python function to generate polynomial features for a given dataset. The function should take in a 2D numpy array X and an integer degree, and return a new 2D numpy array with polynomial features up to the specified degree.", "inputs": ["polynomial_features(X = np.array([[2, 3], [3, 4], [5, 6]]), degree = 2)"], "outputs": ["[[1.0, 1.0, 2.0, 1.0, 2.0, 4.0], [1.0, 3.0, 4.0, 9.0, 12.0, 16.0], [1.0, 5.0, 6.0, 25.0, 30.0, 36.0]]"], "reasoning": ["For each sample in X, the function generates all polynomial combinations of the features up to the given degree. For degree=2, it includes combinations like [x1^0, x1^1, x1^2, x2^0, x2^1, x2^2, x1^1*x2^1], where x1 and x2 are the features."], "import_code": "import numpy as np\nfrom itertools import combinations_with_replacement", "output_constrains": "Return python list after reshaping by using numpy's tolist() method.", "entry_point": "polynomial_features", "starter_code": "def polynomial_features(X, degree):", "reference_code": "def polynomial_features(X, degree):\n    n_samples, n_features = np.shape(X)\n\n    # Generate all combinations of feature indices for polynomial terms\n    def index_combinations():\n        combs = [combinations_with_replacement(range(n_features), i) for i in range(0, degree + 1)]\n        flat_combs = [item for sublist in combs for item in sublist]\n        return flat_combs\n    \n    combinations = index_combinations()\n    n_output_features = len(combinations)\n    X_new = np.empty((n_samples, n_output_features))\n    \n    # Compute polynomial features\n    for i, index_combs in enumerate(combinations):  \n        X_new[:, i] = np.prod(X[:, index_combs], axis=1)\n\n    return X_new.tolist()", "test_cases": ["assert polynomial_features(np.array([[2, 3], [3, 4], [5, 6]]), 2) == [[ 1., 2., 3., 4., 6., 9.], [ 1., 3., 4., 9., 12., 16.], [ 1., 5., 6., 25., 30., 36.]]", "assert polynomial_features(np.array([[1, 2], [3, 4], [5, 6]]), 3) == [[ 1., 1., 2., 1., 2., 4., 1., 2., 4., 8.], [ 1., 3., 4., 9., 12., 16., 27., 36., 48., 64.], [ 1., 5., 6., 25., 30., 36., 125., 150., 180., 216.]]", "assert polynomial_features(np.array([[1, 2, 3], [3, 4, 5], [5, 6, 9]]), 3) == [[ 1., 1., 2., 3., 1., 2., 3., 4., 6., 9., 1., 2., 3., 4., 6., 9., 8., 12., 18., 27.], [ 1., 3., 4., 5., 9., 12., 15., 16., 20., 25., 27., 36., 45., 48., 60., 75., 64., 80., 100., 125.],[ 1., 5., 6., 9., 25., 30., 45., 36., 54., 81., 125., 150., 225., 180., 270., 405., 216., 324., 486., 729.]]"]}
{"id": 33, "difficulty": "medium", "category": "Machine Learning", "title": "Generate Random Subsets of a Dataset", "description": "Write a Python function to generate random subsets of a given dataset. The function should take in a 2D numpy array X, a 1D numpy array y, an integer n_subsets, and a boolean replacements. It should return a list of n_subsets random subsets of the dataset, where each subset is a tuple of (X_subset, y_subset). If replacements is True, the subsets should be created with replacements; otherwise, without replacements.", "inputs": ["get_random_subsets(X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]), y = np.array([1, 2, 3, 4, 5]), n_subsets = 3, replacements = False)"], "outputs": ["[([[7, 8], [1, 2]], [4, 1]), ([[9, 10], [5, 6]], [5, 3]), ([[3, 4], [5, 6]], [2, 3])]"], "reasoning": ["The function generates three random subsets of the dataset without replacements. Each subset includes 50% of the samples (since replacements=False). The samples are randomly selected without duplication."], "import_code": "import numpy as np", "output_constrains": "Return python list after reshaping by using numpy's tolist() method.", "entry_point": "get_random_subsets", "starter_code": "def get_random_subsets(X, y, n_subsets, replacements=True, seed=42):", "reference_code": "def get_random_subsets(X, y, n_subsets, replacements=True, seed=42):\n    np.random.seed(seed)\n\n    n, m = X.shape\n    \n    subset_size = n if replacements else n // 2\n    idx = np.array([np.random.choice(n, subset_size, replace=replacements) for _ in range(n_subsets)])\n    # convert all ndarrays to lists\n    return [(X[idx][i].tolist(), y[idx][i].tolist()) for i in range(n_subsets)]", "test_cases": ["assert get_random_subsets(np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]), np.array([1, 2, 3, 4, 5]), 3, False, seed=42) == [([[3, 4], [9, 10]], [2, 5]), ([[7, 8], [3, 4]], [4, 2]), ([[3, 4], [1, 2]], [2, 1])]", "assert get_random_subsets(np.array([[1, 1], [2, 2], [3, 3], [4, 4]]), np.array([10, 20, 30, 40]), 1, True, seed=42) == [([[3, 3], [4, 4], [1, 1], [3, 3]], [30, 40, 10, 30])]", "assert get_random_subsets(np.array([[1, 3], [2, 4], [3, 5], [4, 6]]), np.array([1, 20, 30, 40]), 2, True, seed=42) == [([[3, 5], [4, 6], [1, 3], [3, 5]], [30, 40, 1, 30]), ([[3, 5], [4, 6], [1, 3], [1, 3]], [30, 40, 1, 1])]"]}
{"id": 34, "difficulty": "easy", "category": "Machine Learning", "title": "One-Hot Encoding of Nominal Values", "description": "Write a Python function to perform one-hot encoding of nominal values. The function should take in a 1D numpy array x of integer values and an optional integer n_col representing the number of columns for the one-hot encoded array. If n_col is not provided, it should be automatically determined from the input array.", "inputs": ["to_categorical(x = np.array([0, 1, 2, 1, 0]))"], "outputs": ["[[1. 0. 0.], [0. 1. 0.], [0. 0. 1.], [0. 1. 0.], [1. 0. 0.]]"], "reasoning": ["Each element in the input array is transformed into a one-hot encoded vector, where the index corresponding to the value in the input array is set to 1, and all other indices are set to 0."], "import_code": "import numpy as np", "output_constrains": "Return python list after reshaping by using numpy's tolist() method.", "entry_point": "to_categorical", "starter_code": "def to_categorical(x, n_col=None):", "reference_code": "def to_categorical(x, n_col=None):\n    # One-hot encoding of nominal values\n    # If n_col is not provided, determine the number of columns from the input array\n    if not n_col:\n        n_col = np.amax(x) + 1\n    # Initialize a matrix of zeros with shape (number of samples, n_col)\n    one_hot = np.zeros((x.shape[0], n_col))\n    # Set the appropriate elements to 1\n    one_hot[np.arange(x.shape[0]), x] = 1\n    return one_hot.tolist()", "test_cases": ["assert to_categorical(np.array([0, 1, 2, 1, 0])) == [[1., 0., 0.], [0., 1., 0.], [0., 0., 1.], [0., 1., 0.], [1., 0., 0.]]", "assert to_categorical(np.array([3, 1, 2, 1, 3]), 4) == [[0., 0., 0., 1.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 1., 0., 0.], [0., 0., 0., 1.]]", "assert to_categorical(np.array([2, 3, 4, 1, 1]), 5) == [[0.0, 0.0, 1.0, 0.0, 0.0], [0.0, 0.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0], [0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0]]", "assert to_categorical(np.array([2, 4, 1, 1])) == [[0.0, 0.0, 1.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0], [0.0, 1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0, 0.0]]"]}
{"id": 35, "difficulty": "easy", "category": "Linear Algebra", "title": "Convert Vector to Diagonal Matrix", "description": "Write a Python function to convert a 1D numpy array into a diagonal matrix. The function should take in a 1D numpy array x and return a 2D numpy array representing the diagonal matrix.", "inputs": ["make_diagonal(x = np.array([1, 2, 3]))"], "outputs": ["[[1., 0., 0.], [0., 2., 0.], [0., 0., 3.]]"], "reasoning": ["The input vector [1, 2, 3] is converted into a diagonal matrix where the elements of the vector form the diagonal of the matrix."], "import_code": "import numpy as np", "output_constrains": "Return python list after reshaping by using numpy's tolist() method.", "entry_point": "make_diagonal", "starter_code": "def make_diagonal(x):", "reference_code": "def make_diagonal(x):\n    identity_matrix = np.identity(np.size(x))\n    return (identity_matrix*x).tolist()", "test_cases": ["assert make_diagonal(np.array([1, 2, 3])) == [[1., 0., 0.], [0., 2., 0.], [0., 0., 3.]]", "assert make_diagonal(np.array([4, 5, 6, 7])) == [[4., 0., 0., 0.], [0., 5., 0., 0.], [0., 0., 6., 0.], [0., 0., 0., 7.]]", "assert make_diagonal(np.array([2, 4, 1, 1])) == [[2.0, 0.0, 0.0, 0.0], [0.0, 4.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0]]", "assert make_diagonal(np.array([1, 3, 5, 0])) == [[1.0, 0.0, 0.0, 0.0], [0.0, 3.0, 0.0, 0.0], [0.0, 0.0, 5.0, 0.0], [0.0, 0.0, 0.0, 0.0]]"]}
{"id": 36, "difficulty": "easy", "category": "Machine Learning", "title": "Calculate Accuracy Score", "description": "Write a Python function to calculate the accuracy score of a model's predictions. The function should take in two 1D numpy arrays: y_true, which contains the true labels, and y_pred, which contains the predicted labels. It should return the accuracy score as a float.", "inputs": ["accuracy_score(y_true = np.array([1, 0, 1, 1, 0, 1]), y_pred = np.array([1, 0, 0, 1, 0, 1]))"], "outputs": ["0.8333"], "reasoning": ["The function compares the true labels with the predicted labels and calculates the ratio of correct predictions to the total number of predictions. In this example, there are 5 correct predictions out of 6, resulting in an accuracy score of 0.8333333333333334."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.", "entry_point": "accuracy_score", "starter_code": "def accuracy_score(y_true, y_pred):", "reference_code": "def accuracy_score(y_true, y_pred):\n    accuracy = np.sum(y_true == y_pred, axis=0) / len(y_true)\n    return np.round(accuracy, 4)", "test_cases": ["assert accuracy_score(np.array([1, 0, 1, 1, 0, 1]), np.array([1, 0, 0, 1, 0, 1])) == 0.8333", "assert accuracy_score(np.array([1, 1, 1, 1]), np.array([1, 0, 1, 0])) == 0.5", "assert accuracy_score(np.array([1, 0, 1, 0, 1]), np.array([1, 0, 0, 1, 1])) == 0.6", "assert accuracy_score(np.array([0, 1, 0, 1]), np.array([1, 0, 1, 1])) == 0.25"]}
{"id": 37, "difficulty": "medium", "category": "Linear Algebra", "title": "Calculate Correlation Matrix", "description": "Write a Python function to calculate the correlation matrix for a given dataset. The function should take in a 2D numpy array X and an optional 2D numpy array Y. If Y is not provided, the function should calculate the correlation matrix of X with itself. It should return the correlation matrix as a 2D numpy array.", "inputs": ["calculate_correlation_matrix(X = np.array([[1, 2], [3, 4], [5, 6]]))"], "outputs": ["[[1.0, 1.0], [1.0, 1.0]]"], "reasoning": ["The function calculates the correlation matrix for the dataset X. In this example, the correlation between the two features is 1, indicating a perfect linear relationship."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "calculate_correlation_matrix", "starter_code": "def calculate_correlation_matrix(X, Y=None):", "reference_code": "def calculate_correlation_matrix(X, Y=None):\n    # Helper function to calculate standard deviation\n    def calculate_std_dev(A):\n        return np.sqrt(np.mean((A - A.mean(0))**2, axis=0))\n    \n    if Y is None:\n        Y = X\n    n_samples = np.shape(X)[0]\n    # Calculate the covariance matrix\n    covariance = (1 / n_samples) * (X - X.mean(0)).T.dot(Y - Y.mean(0))\n    # Calculate the standard deviations\n    std_dev_X = np.expand_dims(calculate_std_dev(X), 1)\n    std_dev_y = np.expand_dims(calculate_std_dev(Y), 1)\n    # Calculate the correlation matrix\n    correlation_matrix = np.divide(covariance, std_dev_X.dot(std_dev_y.T))\n\n    return np.round(np.array(correlation_matrix, dtype=float), 4).tolist()", "test_cases": ["assert calculate_correlation_matrix(np.array([[1, 2], [3, 4], [5, 6]])) == [[1.0, 1.0], [1.0, 1.0]]", "assert calculate_correlation_matrix(np.array([[1, 2, 3], [7, 15, 6], [7, 8, 9]])) == [[1.0, 0.843, 0.866], [0.843, 1.0, 0.4611], [0.866, 0.4611, 1.0]]", "assert calculate_correlation_matrix(np.array([[1, 0], [0, 1]]), np.array([[1, 2], [3, 4]])) == [[ -1.0, -1.0], [ 1.0, 1.0]]", "assert calculate_correlation_matrix(np.array([[1, 3], [3, 6], [5, 8], [7, 11]])) == [[1.0, 0.9971], [0.9971, 1.0]]", "assert calculate_correlation_matrix(np.array([[1, 4], [3, 6]]), np.array([[8, 9], [7, 11]])) == [[-1.0, 1.0], [-1.0, 1.0]]"]}
{"id": 38, "difficulty": "hard", "category": "Machine Learning", "title": "Implement AdaBoost Fit Method", "description": "Write a Python function `adaboost_fit` that implements the fit method for an AdaBoost classifier. The function should take in a 2D numpy array `X` of shape `(n_samples, n_features)` representing the dataset, a 1D numpy array `y` of shape `(n_samples,)` representing the labels, and an integer `n_clf` representing the number of classifiers. The function should initialize sample weights, find the best thresholds for each feature, calculate the error, update weights, and return a list of classifiers with their parameters.", "inputs": ["adaboost_fit(X = np.array([[1, 2], [2, 3], [3, 4], [4, 5]]), y = np.array([1, 1, -1, -1]), n_clf = 3)"], "outputs": ["[{'polarity': -1, 'threshold': 3, 'feature_index': 0, 'alpha': 11.5129}, {'polarity': -1, 'threshold': 3, 'feature_index': 0, 'alpha': 11.5129}, {'polarity': -1, 'threshold': 3, 'feature_index': 0, 'alpha': 11.5129}]"], "reasoning": ["The function fits an AdaBoost classifier on the dataset X with the given labels y and number of classifiers n_clf. It returns a list of classifiers with their parameters, including the polarity, threshold, feature index, and alpha values"], "import_code": "import numpy as np\nimport math", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list.", "entry_point": "adaboost_fit", "starter_code": "def adaboost_fit(X, y, n_clf):", "reference_code": "def adaboost_fit(X, y, n_clf):\n    n_samples, n_features = np.shape(X)\n    w = np.full(n_samples, (1 / n_samples))\n    clfs = []\n    \n    for _ in range(n_clf):\n        clf = {}\n        min_error = float('inf')\n        \n        for feature_i in range(n_features):\n            feature_values = np.expand_dims(X[:, feature_i], axis=1)\n            unique_values = np.unique(feature_values)\n            \n            for threshold in unique_values:\n                p = 1\n                prediction = np.ones(np.shape(y))\n                prediction[X[:, feature_i] < threshold] = -1\n                error = sum(w[y != prediction])\n                \n                if error > 0.5:\n                    error = 1 - error\n                    p = -1\n                \n                if error < min_error:\n                    clf['polarity'] = p\n                    clf['threshold'] = threshold\n                    clf['feature_index'] = feature_i\n                    min_error = error\n        \n        clf['alpha'] = 0.5 * math.log((1.0 - min_error) / (min_error + 1e-10))\n        predictions = np.ones(np.shape(y))\n        negative_idx = (X[:, clf['feature_index']] < clf['threshold'])\n        if clf['polarity'] == -1:\n            negative_idx = np.logical_not(negative_idx)\n        predictions[negative_idx] = -1\n        w *= np.exp(-clf['alpha'] * y * predictions)\n        w /= np.sum(w)\n        clf['alpha'] = np.round(clf['alpha'], 4)\n        clfs.append(clf)\n\n    return clfs", "test_cases": ["assert adaboost_fit(np.array([[1, 2], [2, 3], [3, 4], [4, 5]]), np.array([1, 1, -1, -1]), 3)  == [{'polarity': -1, 'threshold': 3, 'feature_index': 0, 'alpha': 11.5129}, {'polarity': -1, 'threshold': 3, 'feature_index': 0, 'alpha': 11.5129}, {'polarity': -1, 'threshold': 3, 'feature_index': 0, 'alpha': 11.5129}]", "assert adaboost_fit(np.array([[8, 7], [3, 4], [5, 9], [4, 0], [1, 0], [0, 7], [3, 8], [4, 2], [6, 8], [0, 2]]), np.array([1, -1, 1, -1, 1, -1, -1, -1, 1, 1]), 2) == [{'polarity': 1, 'threshold': 5, 'feature_index': 0, 'alpha': 0.6931}, {'polarity': -1, 'threshold': 3, 'feature_index': 0, 'alpha': 0.5493}]", "assert adaboost_fit(np.array([[1, 3], [3, 6], [5, 8], [7, 11]]), np.array([1, 1, -1, -1]), 3) == [{'polarity': -1, 'threshold': 5, 'feature_index': 0, 'alpha': 11.5129}, {'polarity': -1, 'threshold': 5, 'feature_index': 0, 'alpha': 11.5129}, {'polarity': -1, 'threshold': 5, 'feature_index': 0, 'alpha': 11.5129}]", "assert adaboost_fit(np.array([[1, 3], [3, 6], [5, 8], [7, 11]]), np.array([1, -1, 1, -1]), 2) == [{'polarity': -1, 'threshold': 3, 'feature_index': 0, 'alpha': 0.5493}, {'polarity': -1, 'threshold': 7, 'feature_index': 0, 'alpha': 0.8047}]"]}
{"id": 39, "difficulty": "easy", "category": "Deep Learning", "title": "Implementation of Log Softmax Function", "description": "In machine learning and statistics, the softmax function is a generalization of the logistic function that converts a vector of scores into probabilities. The log-softmax function is the logarithm of the softmax function, and it is often used for numerical stability when computing the softmax of large numbers.\n\nGiven a 1D numpy array of scores, implement a Python function to compute the log-softmax of the array.", "inputs": ["log_softmax(scores = np.array([1, 2, 3]))"], "outputs": ["[-2.4076, -1.4076, -0.4076]"], "reasoning": ["The log-softmax function is applied to the input array [1, 2, 3]. The output array contains the log-softmax values for each element."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "log_softmax", "starter_code": "def log_softmax(scores: list):", "reference_code": "def log_softmax(scores: list):\n    # Subtract the maximum value for numerical stability\n    scores = scores - np.max(scores)\n    return (np.round(scores - np.log(np.sum(np.exp(scores))), 4)).tolist()", "test_cases": ["assert log_softmax([1, 2, 3]) == [-2.4076, -1.4076, -0.4076]", "assert log_softmax([1, 1, 1]) == [-1.0986, -1.0986, -1.0986]", "assert log_softmax([1, 1, .0000001]) == [-0.862, -0.862, -1.862]"]}
{"id": 40, "difficulty": "hard", "category": "Deep Learning", "title": "Implementing a Custom Dense Layer in Python", "description": "Implementing a Custom Dense Layer in Python\nYou are provided with a base `Layer` class that defines the structure of a neural network layer. Your task is to implement a subclass called `Dense`, which represents a fully connected neural network layer. The `Dense` class should extend the `Layer` class and implement the following methods:\n1. Initialization (`__init__`):\n- Define the layer with a specified number of neurons (`n_units`) and an optional input shape (`input_shape`).\n- Set up placeholders for the layer's weights (`W`), biases (`w0`), and optimizers.\n2. Weight Initialization (`initialize`):\n- Initialize the weights `W` using a uniform distribution with a limit of `1 / sqrt(input_shape[0])`, and bias `w0` should be set to zero.\n- Initialize optimizers for `W` and `w0`.\n3. Parameter Count (`parameters`):\n- Return the total number of trainable parameters in the layer, which includes the parameters in `W` and `w0`.\n4. Forward Pass (`forward_pass`):\n- Compute the output of the layer by performing a dot product between the input `X` and the weight matrix `W`, and then adding the bias `w0`.\n5. Backward Pass (`backward_pass`):\n- Calculate and return the gradient with respect to the input.\n- If the layer is trainable, update the weights and biases using the optimizer's update rule.\n6. Output Shape (`output_shape`):\n- Return the shape of the output produced by the forward pass, which should be `(self.n_units,)`.\nObjective:\nExtend the `Layer` class by implementing the `Dense` class to ensure it functions correctly within a neural network framework.", "inputs": ["# Initialize a Dense layer with 3 neurons and input shape (2,)\ndense_layer = Dense(n_units=3, input_shape=(2,))\n\n# Define a mock optimizer with a simple update rule\nclass MockOptimizer:\n    def update(self, weights, grad):\n        return weights - 0.01 * grad\n\noptimizer = MockOptimizer()\n\n# Initialize the Dense layer with the mock optimizer\ndense_layer.initialize(optimizer)\n\n# Perform a forward pass with sample input data\nX = np.array([[1, 2]])\ndense_layer.forward_pass(X)\n\n# Perform a backward pass with sample gradient\naccum_grad = np.array([[0.1, 0.2, 0.3]])\ndense_layer.backward_pass(accum_grad)"], "outputs": ["[[0.2082, -0.2293]]"], "reasoning": ["The code initializes a Dense layer with 3 neurons and input shape (2,). It then performs a forward pass with sample input data and a backward pass with sample gradients. The output demonstrates the forward and backward pass results."], "import_code": "import numpy as np\nimport copy\nimport math\n\nclass Layer(object):\n\n    def set_input_shape(self, shape):\n    \n        self.input_shape = shape\n\n    def layer_name(self):\n        return self.__class__.__name__\n\n    def parameters(self):\n        return 0\n\n    def forward_pass(self, X, training):\n        raise NotImplementedError()\n\n    def backward_pass(self, accum_grad):\n        raise NotImplementedError()\n\n    def output_shape(self):\n        raise NotImplementedError()", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "Dense", "starter_code": "class Dense(Layer):\n    def __init__(self, n_units, input_shape=None):\n        self.layer_input = None\n        self.input_shape = input_shape\n        self.n_units = n_units\n        self.trainable = True\n        self.W = None\n        self.w0 = None\n\n    \"\"\"\n    Your task is to implement the Dense class based on the above structure\n    \"\"\"", "reference_code": "class Dense(Layer):\n    def __init__(self, n_units, input_shape=None):\n        self.layer_input = None\n        self.input_shape = input_shape\n        self.n_units = n_units\n        self.trainable = True\n        self.W = None\n        self.w0 = None\n\n    \"\"\"\n    Your task is to implement the Dense class based on the above structure\n    \"\"\"\n\n    def initialize(self, optimizer):\n        limit = 1 / math.sqrt(self.input_shape[0])\n        self.W  = np.random.uniform(-limit, limit, (self.input_shape[0], self.n_units))\n        self.w0 = np.zeros((1, self.n_units))\n        self.W_opt  = copy.copy(optimizer)\n        self.w0_opt = copy.copy(optimizer)\n\n    def parameters(self):\n        return np.prod(self.W.shape) + np.prod(self.w0.shape)\n\n    def forward_pass(self, X, training=True):\n        self.layer_input = X\n        return X.dot(self.W) + self.w0\n\n    def backward_pass(self, accum_grad):\n        W = self.W\n        if self.trainable:\n            grad_w = self.layer_input.T.dot(accum_grad)\n            grad_w0 = np.sum(accum_grad, axis=0, keepdims=True)\n            self.W = self.W_opt.update(self.W, grad_w)\n            self.w0 = self.w0_opt.update(self.w0, grad_w0)\n        accum_grad = accum_grad.dot(W.T)\n        return np.round(accum_grad, 4).tolist()\n\n    def output_shape(self):\n        return (self.n_units, )", "test_cases": ["np.random.seed(42)\ndense_layer = Dense(n_units=3, input_shape=(2,)) \nclass MockOptimizer: \n    def update(self, weights, grad): \n        return weights - 0.01 * grad \noptimizer = MockOptimizer() \ndense_layer.initialize(optimizer) \nX = np.array([[1, 2]]) \noutput = dense_layer.forward_pass(X) \naccum_grad = np.array([[0.1, 0.2, 0.3]]) \nback_output = dense_layer.backward_pass(accum_grad) \nassert back_output == [[0.2082, -0.2293]]", "np.random.seed(42)\ndense_layer = Dense(n_units=3, input_shape=(2,)) \nclass MockOptimizer: \n    def update(self, weights, grad): \n        return weights - 0.01 * grad \noptimizer = MockOptimizer() \ndense_layer.initialize(optimizer) \nX = np.array([[3, 5]]) \noutput = dense_layer.forward_pass(X) \naccum_grad = np.array([[0.2, 0.3, 0.4]]) \nback_output = dense_layer.backward_pass(accum_grad) \nassert back_output == [[0.287, -0.3126]]", "np.random.seed(42)\ndense_layer = Dense(n_units=3, input_shape=(2,)) \nclass MockOptimizer: \n    def update(self, weights, grad): \n        return weights - 0.01 * grad \noptimizer = MockOptimizer() \ndense_layer.initialize(optimizer) \nX = np.array([[2, 3]]) \noutput = dense_layer.forward_pass(X) \naccum_grad = np.array([[0.3, 0.4, 0.5]]) \nback_output = dense_layer.backward_pass(accum_grad) \nassert back_output == [[0.3658, -0.396]]"]}
{"id": 41, "difficulty": "medium", "category": "Deep Learning", "title": "Simple Convolutional 2D Layer", "description": "In this problem, you need to implement a 2D convolutional layer in Python. This function will process an input matrix using a specified convolutional kernel, padding, and stride.", "inputs": ["simple_conv2d(input_matrix = np.array([[1, 2, 3, 4],[5, 6, 7, 8],[9, 10, 11, 12],[13, 14, 15, 16]]), kernel = np.array([[1, 0],[-1, 1]]), padding = 1, stride = 2)"], "outputs": ["[[1.0, 1.0, -4.0], [9.0, 7.0, -4.0], [0.0, 14.0, 16.0]]"], "reasoning": ["The function performs a 2D convolution operation on the input matrix using the specified kernel, padding, and stride. The output matrix contains the results of the convolution operation."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "simple_conv2d", "starter_code": "def simple_conv2d(input_matrix: np.ndarray, kernel: np.ndarray, padding: int, stride: int):", "reference_code": "def simple_conv2d(input_matrix: np.ndarray, kernel: np.ndarray, padding: int, stride: int):\n    input_height, input_width = input_matrix.shape\n    kernel_height, kernel_width = kernel.shape\n\n    padded_input = np.pad(input_matrix, ((padding, padding), (padding, padding)), mode='constant')\n    input_height_padded, input_width_padded = padded_input.shape\n\n    output_height = (input_height_padded - kernel_height) // stride + 1\n    output_width = (input_width_padded - kernel_width) // stride + 1\n\n    output_matrix = np.zeros((output_height, output_width))\n\n    for i in range(output_height):\n        for j in range(output_width):\n            region = padded_input[i*stride:i*stride + kernel_height, j*stride:j*stride + kernel_width]\n            output_matrix[i, j] = np.sum(region * kernel)\n\n    return np.round(output_matrix, 4).tolist()", "test_cases": ["assert simple_conv2d(np.array([ [1., 2., 3., 4., 5.], [6., 7., 8., 9., 10.], [11., 12., 13., 14., 15.], [16., 17., 18., 19., 20.], [21., 22., 23., 24., 25.], ]), np.array([ [1., 2.], [3., -1.], ]), 0, 1)  == [[ 16., 21., 26., 31.], [ 41., 46., 51., 56.], [ 66., 71., 76., 81.], [ 91., 96., 101., 106.]]", "assert simple_conv2d(np.array([ [1., 2., 3., 4., 5.], [6., 7., 8., 9., 10.], [11., 12., 13., 14., 15.], [16., 17., 18., 19., 20.], [21., 22., 23., 24., 25.], ]), np.array([ [.5, 3.2], [1., -1.], ]), 2, 2)  == [[ 0., 0., 0., 0. ], [ 0., 5.9, 13.3, 12.5], [ 0., 42.9, 50.3, 27.5], [ 0., 80.9, 88.3, 12.5],]", "assert simple_conv2d(np.array([ [1., 2., 3., 4., 5.], [6., 7., 8., 9., 10.], [11., 12., 13., 14., 15.], [16., 17., 18., 19., 20.], [21., 22., 23., 24., 25.], ]), np.array([ [1., 2.], [3., -1.], ]), 1, 1)  == [[ -1., 1., 3., 5., 7., 15.], [ -4., 16., 21., 26., 31., 35.], [  1., 41., 46., 51., 56., 55.], [  6., 66., 71., 76., 81., 75.], [ 11., 91., 96., 101., 106., 95.], [ 42., 65., 68., 71., 74.,  25.],]", "assert simple_conv2d(np.array([ [1., 2., 3., 4., 5.], [6., 7., 8., 9., 10.], [11., 12., 13., 14., 15.], [16., 17., 18., 19., 20.], [21., 22., 23., 24., 25.], ]), np.array([ [1., 2., 3.], [-6., 2., 8.], [5., 2., 3.], ]), 0, 1)  == [ [174., 194., 214.], [274., 294., 314.], [374., 394., 414.], ]", "assert simple_conv2d(np.array([ [1., 2., 3., 4., 5.], [6., 7., 8., 9., 10.], [11., 12., 13., 14., 15.], [16., 17., 18., 19., 20.], [21., 22., 23., 24., 25.], ]), np.array([ [1., 2., 3.], [-6., 2., 8.], [5., 2., 3.], ]), 1, 2)  == [ [51., 104., 51.], [234., 294., 110.], [301., 216., -35.], ]", "assert simple_conv2d(np.array([ [1., 2., 3.], [1., 2., 3.], [1., 2., 3.],]), np.array([ [1., 2., 3.], [1., 2., 3.], [1., 2., 3.],]), 1, 1)  == [[16., 28., 16.], [24., 42., 24.], [16., 28., 16.]]"]}
{"id": 42, "difficulty": "easy", "category": "Deep Learning", "title": "Implement ReLU Activation Function", "description": "Write a Python function `relu` that implements the Rectified Linear Unit (ReLU) activation function. The function should take a single float as input and return the value after applying the ReLU function. The ReLU function returns the input if it's greater than 0, otherwise, it returns 0.", "inputs": ["relu(z = 0)"], "outputs": ["0"], "reasoning": ["The ReLU function is applied to the input values 0, 1, and -1. The output is 0 for negative values and the input value for non-negative values."], "import_code": "", "output_constrains": "", "entry_point": "relu", "starter_code": "def relu(z: float) -> float:", "reference_code": "def relu(z: float) -> float:\n    return max(0, z)", "test_cases": ["assert relu(0) == 0", "assert relu(1) == 1", "assert relu(-1) == 0"]}
{"id": 43, "difficulty": "easy", "category": "Machine Learning", "title": "Implement Ridge Regression Loss Function", "description": "Write a Python function `ridge_loss` that implements the Ridge Regression loss function. The function should take a 2D numpy array `X` representing the feature matrix, a 1D numpy array `w` representing the coefficients, a 1D numpy array `y_true` representing the true labels, and a float `alpha` representing the regularization parameter. The function should return the Ridge loss, which combines the Mean Squared Error (MSE) and a regularization term.", "inputs": ["ridge_loss(X = np.array([[1, 1], [2, 1], [3, 1], [4, 1]]), w = np.array([0.2, 2]), y_true = np.array([2, 3, 4, 5]), alpha = 0.1)"], "outputs": ["2.204"], "reasoning": ["The Ridge loss is calculated using the Mean Squared Error (MSE) and a regularization term. The output represents the combined loss value."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.", "entry_point": "ridge_loss", "starter_code": "def ridge_loss(X: np.ndarray, w: np.ndarray, y_true: np.ndarray, alpha: float) -> float:", "reference_code": "def ridge_loss(X: np.ndarray, w: np.ndarray, y_true: np.ndarray, alpha: float) -> float:\n    loss = np.mean((y_true - X @ w)**2) + alpha * np.sum(w**2)\n    return np.round(loss, 4)", "test_cases": ["assert ridge_loss(np.array([[1,1],[2,1],[3,1],[4,1]]), np.array([.2,2]), np.array([2,3,4,5]), 0.1) == 2.204", "assert ridge_loss(np.array([[1,1,4],[2,1,2],[3,1,.1],[4,1,1.2],[1,2,3]]), np.array([.2,2,5]), np.array([2,3,4,5,2]), 0.1) == 164.402", "assert ridge_loss(np.array([[3,4,1],[1,2,2],[1,.1,3],[1.2,1,4],[1,2,3]]), np.array([2,.2,5]), np.array([2,3,4,5,2]), 0.1) == 183.0721"]}
{"id": 44, "difficulty": "easy", "category": "Deep Learning", "title": "Leaky ReLU Activation Function", "description": "Write a Python function `leaky_relu` that implements the Leaky Rectified Linear Unit (Leaky ReLU) activation function. The function should take a float `z` as input and an optional float `alpha`, with a default value of 0.01, as the slope for negative inputs. The function should return the value after applying the Leaky ReLU function.", "inputs": ["leaky_relu(z = 0)"], "outputs": ["0"], "reasoning": ["For z = 0, the output is 0."], "import_code": "", "output_constrains": "", "entry_point": "leaky_relu", "starter_code": "def leaky_relu(z: float, alpha: float = 0.01) -> float|int:", "reference_code": "def leaky_relu(z: float, alpha: float = 0.01) -> float|int:\n    return z if z > 0 else alpha * z", "test_cases": ["assert leaky_relu(5) == 5", "assert leaky_relu(1) == 1", "assert leaky_relu(-1) == -0.01", "assert leaky_relu(0) == 0", "assert leaky_relu(-2, alpha=0.1) == -0.2"]}
{"id": 45, "difficulty": "easy", "category": "Machine Learning", "title": "Linear Kernel Function", "description": "Write a Python function `kernel_function` that computes the linear kernel between two input vectors `x1` and `x2`. The linear kernel is defined as the dot product (inner product) of two vectors.", "inputs": ["kernel_function(x1 = np.array([1, 2, 3]), x2 = np.array([4, 5, 6]))"], "outputs": ["32"], "reasoning": ["The linear kernel between x1 and x2 is computed as:1*4 + 2*5 + 3*6 = 32"], "import_code": "import numpy as np", "output_constrains": "", "entry_point": "kernel_function", "starter_code": "def kernel_function(x1, x2):", "reference_code": "def kernel_function(x1, x2):\n    return np.inner(x1, x2)", "test_cases": ["assert kernel_function(np.array([1, 2, 3]) , np.array([4, 5, 6]) ) == 32", "assert kernel_function(np.array([0, 1, 2]) , np.array([3, 4, 5]) ) == 14", "assert kernel_function(np.array([3, 1, 2, 5]) , np.array([3, 6, 4, 5]) ) == 48"]}
{"id": 46, "difficulty": "easy", "category": "Machine Learning", "title": "Implement Precision Metric", "description": "Write a Python function `precision` that calculates the precision metric given two numpy arrays: `y_true` and `y_pred`. The `y_true` array contains the true binary labels, and the `y_pred` array contains the predicted binary labels. Precision is defined as the ratio of true positives to the sum of true positives and false positives.", "inputs": ["precision(y_true = np.array([1, 0, 1, 1, 0, 1]), y_pred = np.array([1, 0, 1, 0, 0, 1]))"], "outputs": ["1.0"], "reasoning": ["True Positives (TP) = 3\nFalse Positives (FP) = 0\nPrecision = TP / (TP + FP) = 3 / (3 + 0) = 1.0"], "import_code": "import numpy as np", "output_constrains": "", "entry_point": "precision", "starter_code": "def precision(y_true, y_pred):", "reference_code": "def precision(y_true, y_pred):\n    true_positives = np.sum((y_true == 1) & (y_pred == 1))\n    false_positives = np.sum((y_true == 0) & (y_pred == 1))\n    return true_positives / (true_positives + false_positives) if (true_positives + false_positives) > 0 else 0.0", "test_cases": ["assert precision(np.array([1, 0, 1, 1, 0, 1])  , np.array([1, 0, 1, 0, 0, 1]) ) == 1.0", "assert precision(np.array([1, 0, 1, 1, 0, 0])  , np.array([1, 0, 0, 0, 0, 1]) ) == 0.5", "assert precision(np.array([1, 0, 1, 1, 0, 0, 1, 1])  , np.array([1, 0, 0, 0, 0, 1, 0, 0])) == 0.5"]}
{"id": 47, "difficulty": "medium", "category": "Machine Learning", "title": "Implement Gradient Descent Variants with MSE Loss", "description": "In this problem, you need to implement a single function that can perform three variants of gradient descent\u00e2\u0080\u0094Stochastic Gradient Descent (SGD), Batch Gradient Descent, and Mini-Batch Gradient Descent\u00e2\u0080\u0094using Mean Squared Error (MSE) as the loss function. The function will take an additional parameter to specify which variant to use.", "inputs": ["gradient_descent(X = np.array([[1, 1], [2, 1], [3, 1], [4, 1]]), y = np.array([2, 3, 4, 5]), weights = np.zeros(2), learning_rate = 0.01, n_iterations = 1000, method='batch')"], "outputs": ["[1.01, 0.9705]"], "reasoning": ["The function should return the final weights after performing the specified variant of gradient descent."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "gradient_descent", "starter_code": "def gradient_descent(X, y, weights, learning_rate, n_iterations, batch_size=1, method='batch'):", "reference_code": "def gradient_descent(X, y, weights, learning_rate, n_iterations, batch_size=1, method='batch'):\n    m = len(y)\n    \n    for _ in range(n_iterations):\n        if method == 'batch':\n            # Calculate the gradient using all data points\n            predictions = X.dot(weights)\n            errors = predictions - y\n            gradient = 2 * X.T.dot(errors) / m\n            weights = weights - learning_rate * gradient\n        \n        elif method == 'stochastic':\n            # Update weights for each data point individually\n            for i in range(m):\n                prediction = X[i].dot(weights)\n                error = prediction - y[i]\n                gradient = 2 * X[i].T.dot(error)\n                weights = weights - learning_rate * gradient\n        \n        elif method == 'mini_batch':\n            # Update weights using sequential batches of data points without shuffling\n            for i in range(0, m, batch_size):\n                X_batch = X[i:i+batch_size]\n                y_batch = y[i:i+batch_size]\n                predictions = X_batch.dot(weights)\n                errors = predictions - y_batch\n                gradient = 2 * X_batch.T.dot(errors) / batch_size\n                weights = weights - learning_rate * gradient\n                \n    return np.round(weights, 4).tolist()", "test_cases": ["assert gradient_descent(np.array([[1, 1], [2, 1], [3, 1], [4, 1]]), np.array([2, 3, 4, 5]), np.zeros(2), 0.01, 100, method='batch') == [1.1491, 0.5618]", "assert gradient_descent(np.array([[1, 1], [2, 1], [3, 1], [4, 1]]), np.array([2, 3, 4, 5]), np.zeros(2), 0.01, 100, method='stochastic') == [1.0508, 0.8366]", "assert gradient_descent(np.array([[1, 1], [2, 1], [3, 1], [4, 1]]), np.array([2, 3, 4, 5]), np.zeros(2), 0.01, 100, 2, method='mini_batch') == [1.1033, 0.6833]"]}
{"id": 48, "difficulty": "medium", "category": "Linear Algebra", "title": "Implement Reduced Row Echelon Form (RREF) Function", "description": "In this problem, your task is to implement a function that converts a given matrix into its Reduced Row Echelon Form (RREF). The RREF of a matrix is a special form where each leading entry in a row is 1, and all other elements in the column containing the leading 1 are zeros, except for the leading 1 itself.\nHowever, there are some additional details to keep in mind:\n- Diagonal entries can be 0 if the matrix is reducible (i.e., the row corresponding to that position can be eliminated entirely).\n- Some rows may consist entirely of zeros.\n- If a column contains a pivot (a leading 1), all other entries in that column should be zero.\nYour task is to implement the RREF algorithm, which must handle these cases and convert any given matrix into its RREF.", "inputs": ["rref(matrix = np.array([[1, 2, -1, -4], [2, 3, -1, -11],[-2, 0, -3, 22]]))"], "outputs": ["[[1.0, 0.0, 0.0, -8.0], [0.0, 1.0, 0.0, 1.0], [-0.0, -0.0, 1.0, -2.0]]"], "reasoning": ["The given matrix is converted to its Reduced Row Echelon Form (RREF) where each leading entry is 1, and all other entries in the leading columns are zero."], "import_code": "import numpy as np", "output_constrains": "Return python list after reshaping by using numpy's tolist() method.", "entry_point": "rref", "starter_code": "def rref(matrix):", "reference_code": "def rref(matrix):\n    # Convert to float for division operations\n    A = matrix.astype(np.float32)\n    n, m = A.shape\n    \n    for i in range(n):\n        if A[i, i] == 0:\n            nonzero_rel_id = np.nonzero(A[i:, i])[0]\n            if len(nonzero_rel_id) == 0: continue\n            \n            A[i] = A[i] + A[nonzero_rel_id[0] + i]\n\n        A[i] = A[i] / A[i, i]\n        for j in range(n):\n            if i != j:\n                A[j] -= A[j, i] * A[i]\n\n    return A.tolist()", "test_cases": ["assert rref(np.array([ [1, 2, -1, -4], [2, 3, -1, -11], [-2, 0, -3, 22] ])) == [[ 1., 0., 0., -8.], [ 0., 1., 0., 1.], [-0., -0., 1., -2.]]", "assert rref(np.array([ [2, 4, -2], [4, 9, -3], [-2, -3, 7] ])) == [[ 1., 0., 0.], [ 0., 1., 0.], [ 0., 0., 1.]]", "assert rref(np.array([ [0, 2, -1, -4], [2, 0, -1, -11], [-2, 0, 0, 22] ])) == [[ 1., 0., 0., -11.],[-0., 1., 0., -7.5],[-0., -0., 1., -11.]]", "assert rref(np.array([ [1, 2, -1], [2, 4, -1], [-2, -4, -3]])) == [[ 1., 2., 0.],[ 0., 0., 0.],[-0., -0., 1.]]"]}
{"id": 49, "difficulty": "medium", "category": "Deep Learning", "title": "Implement Adam Optimization Algorithm", "description": "Implement the Adam (Adaptive Moment Estimation) optimization algorithm in Python. Adam is an optimization algorithm that adapts the learning rate for each parameter. Your task is to write a function `adam_optimizer` that updates the parameters of a given function using the Adam algorithm.\nThe function should take the following parameters:\n- `f`: The objective function to be optimized\n- `grad`: A function that computes the gradient of `f`\n- `x0`: Initial parameter values\n- `learning_rate`: The step size (default: 0.001)\n- `beta1`: Exponential decay rate for the first moment estimates (default: 0.9)\n- `beta2`: Exponential decay rate for the second moment estimates (default: 0.999)\n- `epsilon`: A small constant for numerical stability (default: 1e-8)\n- `num_iterations`: Number of iterations to run the optimizer (default: 1000)\nThe function should return the optimized parameters.", "inputs": ["def objective_function(x):\n    return x[0]**2 + x[1]**2\n\ndef gradient(x):\n    return np.array([2*x[0], 2*x[1]])\n\nadam_optimizer(objective_function, gradient, x0 = np.array([1.0, 1.0]))"], "outputs": ["[0.99, 0.99]"], "reasoning": ["The Adam optimizer updates the parameters to minimize the objective function. In this case, the objective function is the sum of squares of the parameters, and the optimizer finds the optimal values for the parameters."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "adam_optimizer", "starter_code": "def adam_optimizer(f, grad, x0, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-8, num_iterations=10):", "reference_code": "def adam_optimizer(f, grad, x0, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-8, num_iterations=10):\n    x = x0\n    m = np.zeros_like(x)\n    v = np.zeros_like(x)\n\n    for t in range(1, num_iterations + 1):\n        g = grad(x)\n        m = beta1 * m + (1 - beta1) * g\n        v = beta2 * v + (1 - beta2) * g**2\n        m_hat = m / (1 - beta1**t)\n        v_hat = v / (1 - beta2**t)\n        x = x - learning_rate * m_hat / (np.sqrt(v_hat) + epsilon)\n\n    return np.round(x, 4).tolist()", "test_cases": ["assert adam_optimizer(lambda x: x[0]**2 + x[1]**2, lambda y: np.array([2*y[0], 2*y[1]]), np.array([1.0, 1.0])) == [0.99, 0.99]", "assert adam_optimizer(lambda x: x[0]**2 + x[1]**2, lambda y: np.array([2*y[0], 2*y[1]]), np.array([0.2, 12.3])) == [ 0.19, 12.29]", "assert adam_optimizer(lambda x: x[0]**2 + x[1]**2, lambda y: np.array([2*y[0], 2*y[1]]), np.array([1, 3])) == [0.99, 2.99]", "assert adam_optimizer(lambda x: x[0]**2 + x[1]**2, lambda y: np.array([2*y[0], 2*y[1]]), np.array([5, 8])) == [4.99, 7.99]"]}
{"id": 50, "difficulty": "medium", "category": "Machine Learning", "title": "Implement Lasso Regression using Gradient Descent", "description": "In this problem, you need to implement the Lasso Regression algorithm using Gradient Descent. Lasso Regression (L1 Regularization) adds a penalty equal to the absolute value of the coefficients to the loss function. Your task is to update the weights and bias iteratively using the gradient of the loss function and the L1 penalty.\nThe objective function of Lasso Regression is:\n$J(w, b) = \frac{1}{2n} \\sum\\limits_{i=1}^n (y_i - (\\sum\\limits_{j=1}^p X_{ij} w_j + b))^2$\nWhere:\n- $y_i$  is the actual value for the i-th sample\n- $\\hat{y_i} = \\sum_{j=1}^p X_{ij}w_j + b$ is the predicted value for the i-th sample\n- $w_j$ is the weight associated with the j-th feature\n- $\u0007lpha$ is the regularization parameter\n- $b$ is the bias\nYour task is to use the L1 penalty to shrink some of the feature coefficients to zero during gradient descent, thereby helping with feature selection.", "inputs": ["l1_regularization_gradient_descent(X = np.array([[0, 0], [1, 1], [2, 2]]), y = np.array([0, 1, 2]), alpha = 0.1, learning_rate=0.01, max_iter=1000)"], "outputs": ["([0.4237, 0.4237], 0.1539)"], "reasoning": ["The Lasso Regression algorithm is used to optimize the weights and bias for the given data. The weights are adjusted to minimize the loss function with the L1 penalty."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "l1_regularization_gradient_descent", "starter_code": "def l1_regularization_gradient_descent(X: np.array, y: np.array, alpha: float = 0.1, learning_rate: float = 0.01, max_iter: int = 1000, tol: float = 1e-4) -> tuple:", "reference_code": "def l1_regularization_gradient_descent(X: np.array, y: np.array, alpha: float = 0.1, learning_rate: float = 0.01, max_iter: int = 1000, tol: float = 1e-4) -> tuple:\n    n_samples, n_features = X.shape\n    # Zero out weights and bias\n    weights = np.zeros(n_features)\n    bias = 0\n    \n    for iteration in range(max_iter):\n        # Predict values\n        y_pred = np.dot(X, weights) + bias\n        # Calculate error\n        error = y_pred - y\n        # Gradient for weights with L1 penalty\n        grad_w = (1 / n_samples) * np.dot(X.T, error) + alpha * np.sign(weights)\n        # Gradient for bias (no penalty for bias)\n        grad_b = (1 / n_samples) * np.sum(error)\n        \n        # Update weights and bias\n        weights -= learning_rate * grad_w\n        bias -= learning_rate * grad_b\n        \n        # Check for convergence\n        if np.linalg.norm(grad_w, ord=1) < tol:\n            break\n    \n    return np.round(weights, 4).tolist(), np.round(bias, 4)", "test_cases": ["assert l1_regularization_gradient_descent(np.array([[0, 0], [1, 1], [2, 2]]), np.array([0, 1, 2]), alpha=0.1, learning_rate=0.01, max_iter=1000)  == ([0.4237, 0.4237], 0.1539)", "assert l1_regularization_gradient_descent(np.array([[0, 0], [1, 1], [2, 2]]), np.array([0, 1, 2]), alpha=0.1, learning_rate=0.01, max_iter=5000)  == ([0.4249, 0.4249], 0.1504)", "assert l1_regularization_gradient_descent(np.array([[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]]), np.array([1, 2, 3, 4, 5]), alpha=0.1, learning_rate=0.01, max_iter=1000)  == ([0.2728, 0.6811], 0.4083)"]}
{"id": 51, "difficulty": "medium", "category": "NLP", "title": "Optimal String Alignment Distance", "description": "In this problem, you need to implement a function that calculates the Optimal String Alignment (OSA) distance between two given strings. The OSA distance represents the minimum number of edits required to transform one string into another. The allowed edit operations are:\n- Insert a character\n- Delete a character\n- Substitute a character\n- Transpose two adjacent characters\nEach of these operations costs 1 unit.\nYour task is to find the minimum number of edits needed to convert the first string (s1) into the second string (s2).\nFor example, the OSA distance between the strings `caper` and `acer` is 2: one deletion (removing \"p\") and one transposition (swapping \"a\" and \"c\").", "inputs": ["OSA(source = \"butterfly\", target = \"dragonfly\")"], "outputs": ["6"], "reasoning": ["The OSA distance between the strings \"butterfly\" and \"dragonfly\" is 6. The minimum number of edits required to transform the source string into the target string is 6."], "import_code": "import numpy as np", "output_constrains": "", "entry_point": "OSA", "starter_code": "def OSA(source: str, target: str) -> int:", "reference_code": "def OSA(source: str, target: str) -> int:\n    source_len, target_len = len(source), len(target)\n\n    # Initialize matrix with zeros\n    osa_matrix = [[0] * (target_len + 1) for _ in range(source_len + 1)]\n\n    # Fill the first row and first column with index values\n    for j in range(1, target_len + 1):\n        osa_matrix[0][j] = j\n    for i in range(1, source_len + 1):\n        osa_matrix[i][0] = i\n\n    # Compute the OSA distance\n    for i in range(1, source_len + 1):\n        for j in range(1, target_len + 1):\n            osa_matrix[i][j] = min(\n                osa_matrix[i - 1][j] + 1,  # Deletion\n                osa_matrix[i][j - 1] + 1,  # Insertion\n                osa_matrix[i - 1][j - 1] + (1 if source[i - 1] != target[j - 1] else 0)  # Substitution\n            )\n            if i > 1 and j > 1 and source[i - 1] == target[j - 2] and source[i - 2] == target[j - 1]:\n                osa_matrix[i][j] = min(osa_matrix[i][j], osa_matrix[i - 2][j - 2] + 1)  # Transposition\n\n    return osa_matrix[-1][-1]", "test_cases": ["assert OSA(\"butterfly\", \"dragonfly\") == 6", "assert OSA(\"caper\", \"acer\") == 2", "assert OSA(\"telescope\", \"microscope\") == 5", "assert OSA(\"london\", \"paris\") == 6", "assert OSA(\"shower\", \"grower\") == 2", "assert OSA(\"labyrinth\", \"puzzle\") == 9", "assert OSA(\"silhouette\", \"shadow\") == 8", "assert OSA(\"whisper\", \"screaming\") == 9", "assert OSA(\"enigma\", \"mystery\") == 7", "assert OSA(\"symphony\", \"cacophony\") == 4", "assert OSA(\"mirage\", \"oasis\") == 6", "assert OSA(\"asteroid\", \"meteorite\") == 5", "assert OSA(\"palindrome\", \"palladium\") == 5"]}
{"id": 52, "difficulty": "easy", "category": "Machine Learning", "title": "Implement Recall Metric in Binary Classification", "description": "Task: Implement Recall in Binary Classification\nYour task is to implement the recall metric in a binary classification setting. Recall is a performance measure that evaluates how effectively a machine learning model identifies positive instances from all the actual positive cases in a dataset.\nYou need to write a function `recall(y_true, y_pred)` that calculates the recall metric. The function should accept two inputs:\n- `y_true`: A list of true binary labels (0 or 1) for the dataset.\n- `y_pred`: A list of predicted binary labels (0 or 1) from the model.\nYour function should return the recall value rounded to three decimal places. If the denominator (TP + FN) is zero, the recall should be 0.0 to avoid division by zero.", "inputs": ["recall(y_true = np.array([1, 0, 1, 1, 0, 1]), y_pred = np.array([1, 0, 1, 0, 0, 1]))"], "outputs": ["0.75"], "reasoning": ["The recall value for the given true labels and predicted labels is 0.75. The model correctly identified 3 out of 4 positive instances in the dataset."], "import_code": "import numpy as np", "output_constrains": "", "entry_point": "recall", "starter_code": "def recall(y_true, y_pred):", "reference_code": "def recall(y_true, y_pred):\n    tp = np.sum((y_true == 1) & (y_pred == 1))\n    fn = np.sum((y_true == 1) & (y_pred == 0))\n\n    try:\n        return round(tp / (tp + fn), 3)\n    except ZeroDivisionError:\n        return 0.0", "test_cases": ["assert recall(np.array([1, 0, 1, 1, 0, 1]), np.array([1, 0, 1, 0, 0, 1])) == 0.75", "assert recall(np.array([1, 0, 1, 1, 0, 0]), np.array([1, 0, 0, 0, 0, 1])) == 0.333", "assert recall(np.array([1, 0, 1, 1, 0, 0]), np.array([1, 0, 1, 1, 0, 0])) == 1.0", "assert recall(np.array([1, 0, 1, 1, 0, 1]), np.array([0, 0, 0, 1, 0, 1])) == 0.5", "assert recall(np.array([1, 0, 1, 1, 0, 1]), np.array([0, 1, 0, 0, 1, 0])) == 0.0", "assert recall(np.array([1, 0, 0, 1, 0, 1]), np.array([1, 0, 1, 1, 0, 0])) == 0.667"]}
{"id": 53, "difficulty": "medium", "category": "Deep Learning", "title": "Implement Self-Attention Mechanism", "description": "Task: Implement the Self-Attention Mechanism\nYour task is to implement the self-attention mechanism, which is a fundamental component of transformer models, widely used in natural language processing and computer vision tasks. The self-attention mechanism allows a model to dynamically focus on different parts of the input sequence when generating a contextualized representation.\nYour function should return the self-attention output as a numpy array.", "inputs": ["self_attention(X = np.array([[1, 0], [0, 1]]), W_q = np.array([[1, 0], [0, 1]]), W_k = np.array([[1, 0], [0, 1]]), W_v = np.array([[1, 2], [3, 4]]))"], "outputs": ["[[1.6605, 2.6605], [2.3395, 3.3395]]"], "reasoning": ["The self-attention mechanism calculates the attention scores for each input, determining how much focus to put on other inputs when generating a contextualized representation. The output is the weighted sum of the values based on the attention scores."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "self_attention", "starter_code": "def self_attention(X, W_q, W_k, W_v):", "reference_code": "def compute_qkv(X, W_q, W_k, W_v):\n    Q = np.dot(X, W_q)\n    K = np.dot(X, W_k)\n    V = np.dot(X, W_v)\n    return Q, K, V\n\ndef self_attention(X, W_q, W_k, W_v):\n\n    Q, K, V = compute_qkv(X, W_q, W_k, W_v)\n\n    d_k = Q.shape[1]\n    scores = np.matmul(Q, K.T) / np.sqrt(d_k)\n    attention_weights = np.exp(scores) / np.sum(np.exp(scores), axis=1, keepdims=True)\n    attention_output = np.matmul(attention_weights, V)\n    return np.round(attention_output, 4).tolist()", "test_cases": ["assert self_attention(np.array([[1, 0], [0, 1]]), np.array([[1, 0], [0, 1]]), np.array([[1, 0], [0, 1]]), np.array([[1, 2], [3, 4]])) == [[1.6605, 2.6605], [2.3395, 3.3395]]", "assert self_attention(np.array([[1, 1], [1, 0]]), np.array([[1, 0], [0, 1]]), np.array([[1, 0], [0, 1]]), np.array([[1, 2], [3, 4]])) == [[3.0093, 4.679], [2.5, 4.0]]", "assert self_attention(np.array([[1, 0, 1], [0, 1, 1], [1, 1, 0]]), np.array([[1, 1, 0], [0, 1, 1], [1, 0, 1]]), np.array([[1, 1, 0], [0, 1, 1], [1, 0, 1]]), np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == [[8.0, 10.0, 12.0], [8.6199, 10.6199, 12.6199], [7.3801, 9.3801, 11.3801]]"]}
{"id": 54, "difficulty": "medium", "category": "Deep Learning", "title": "Implementing a Simple RNN", "description": "Write a Python function that implements a simple Recurrent Neural Network (RNN) cell. The function should process a sequence of input vectors and produce the final hidden state. Use the tanh activation function for the hidden state updates. The function should take as inputs the sequence of input vectors, the initial hidden state, the weight matrices for input-to-hidden and hidden-to-hidden connections, and the bias vector. The function should return the final hidden state after processing the entire sequence, rounded to four decimal places.", "inputs": ["rnn_forward(input_sequence = [[1.0], [2.0], [3.0]], initial_hidden_state = [0.0], Wx = [[0.5]], Wh = [[0.8]], b = [0.0])"], "outputs": ["[0.9759]"], "reasoning": ["The RNN processes each input in the sequence, updating the hidden state at each step using the tanh activation function."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "rnn_forward", "starter_code": "def rnn_forward(input_sequence: list[list[float]], initial_hidden_state: list[float], Wx: list[list[float]], Wh: list[list[float]], b: list[float]) -> list[float]:", "reference_code": "def rnn_forward(input_sequence: list[list[float]], initial_hidden_state: list[float], Wx: list[list[float]], Wh: list[list[float]], b: list[float]) -> list[float]:\n    h = np.array(initial_hidden_state)\n    Wx = np.array(Wx)\n    Wh = np.array(Wh)\n    b = np.array(b)\n    for x in input_sequence:\n        x = np.array(x)\n        h = np.tanh(np.dot(Wx, x) + np.dot(Wh, h) + b)\n    final_hidden_state = np.round(h, 4)\n    return final_hidden_state.tolist()", "test_cases": ["assert rnn_forward([[1.0], [2.0], [3.0]], [0.0], [[0.5]], [[0.8]], [0.0]) == [0.9759]", "assert rnn_forward([[0.5], [0.1], [-0.2]], [0.0], [[1.0]], [[0.5]], [0.1]) == [0.118]", "assert rnn_forward( [[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]], [0.0, 0.0], [[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]], [[0.7, 0.8], [0.9, 1.0]], [0.1, 0.2] ) == [0.7474, 0.9302]"]}
{"id": 55, "difficulty": "medium", "category": "Linear Algebra", "title": "2D Translation Matrix Implementation", "description": "Task: Implement a 2D Translation Matrix\nYour task is to implement a function that applies a 2D translation matrix to a set of points. A translation matrix is used to move points in 2D space by a specified distance in the x and y directions.\nWrite a function `translate_object(points, tx, ty)` where `points` is a list of [x, y] coordinates and `tx` and `ty` are the translation distances in the x and y directions, respectively.\nThe function should return a new list of points after applying the translation matrix.", "inputs": ["translate_object(points = [[0, 0], [1, 0], [0.5, 1]], tx =  2, ty = 3)"], "outputs": ["[[2.0, 3.0], [3.0, 3.0], [2.5, 4.0]]"], "reasoning": ["The translation matrix moves the points by 2 units in the x-direction and 3 units in the y-direction. The resulting points are [[2.0, 3.0], [3.0, 3.0], [2.5, 4.0]]."], "import_code": "import numpy as np", "output_constrains": "Return python list after reshaping by using numpy's tolist() method.", "entry_point": "translate_object", "starter_code": "def translate_object(points, tx, ty):", "reference_code": "def translate_object(points, tx, ty):\n    translation_matrix = np.array([\n        [1, 0, tx],\n        [0, 1, ty],\n        [0, 0, 1]\n    ])\n    \n    homogeneous_points = np.hstack([np.array(points), np.ones((len(points), 1))])\n    \n    translated_points = np.dot(homogeneous_points, translation_matrix.T)\n    \n    return translated_points[:, :2].tolist()", "test_cases": ["assert translate_object([[0, 0], [1, 0], [0.5, 1]], 2, 3) ==  [[2.0, 3.0], [3.0, 3.0], [2.5, 4.0]]", "assert translate_object([[0, 0], [1, 0], [1, 1], [0, 1]], -1, 2) == [[-1.0, 2.0], [0.0, 2.0], [0.0, 3.0], [-1.0, 3.0]]", "assert translate_object([[0, 0], [1, 0], [1, 1], [0, 1]], 2, 3) == [[2.0, 3.0], [3.0, 3.0], [3.0, 4.0], [2.0, 4.0]]"]}
{"id": 56, "difficulty": "easy", "category": "Deep Learning", "title": "KL Divergence Between Two Normal Distributions", "description": "Task: Implement KL Divergence Between Two Normal Distributions\nYour task is to compute the Kullback-Leibler (KL) divergence between two normal distributions. KL divergence measures how one probability distribution differs from a second, reference probability distribution.\nWrite a function `kl_divergence_normal(mu_p, sigma_p, mu_q, sigma_q)` that calculates the KL divergence between two normal distributions, where $ P \\sim N(\\mu_P, \\sigma_P^2) $ and $ Q \\sim N(\\mu_Q, \\sigma_Q^2) $.\nThe function should return the KL divergence as a floating-point number.", "inputs": ["kl_divergence_normal(mu_p = 0.0, sigma_p = 1.0, mu_q = 1.0, sigma_q = 1.0)"], "outputs": ["0.5"], "reasoning": ["The KL divergence between the normal distributions $ P $ and $ Q $ with parameters $ \\mu_P = 0.0 $, $ \\sigma_P = 1.0 $ and $ \\mu_Q = 1.0 $, $ \\sigma_Q = 1.0 $ is 0.5."], "import_code": "import numpy as np", "output_constrains": "", "entry_point": "kl_divergence_normal", "starter_code": "def kl_divergence_normal(mu_p, sigma_p, mu_q, sigma_q):", "reference_code": "def kl_divergence_normal(mu_p, sigma_p, mu_q, sigma_q):\n    term1 = np.log(sigma_q / sigma_p)\n    term2 = (sigma_p ** 2 + (mu_p - mu_q) ** 2) / (2 * sigma_q ** 2)\n    kl_div = term1 + term2 - 0.5\n    return kl_div", "test_cases": ["assert kl_divergence_normal(0.0, 1.0, 0.0, 1.0) == 0.0", "assert kl_divergence_normal(0.0, 1.0, 1.0, 1.0) == 0.5", "assert kl_divergence_normal(0.0, 1.0, 0.0, 2.0) == 0.3181471805599453", "assert kl_divergence_normal(1.0, 1.0, 0.0, 2.0) == 0.4431471805599453", "assert kl_divergence_normal(2.0, 1.0, 3.0, 2.0) == 0.4431471805599453", "assert kl_divergence_normal(0.0, 2.0, 0.0, 3.0) == 0.1276873303303866"]}
{"id": 57, "difficulty": "medium", "category": "Linear Algebra", "title": "Gauss-Seidel Method for Solving Linear Systems", "description": "Task: Implement the Gauss-Seidel Method\nYour task is to implement the Gauss-Seidel method, an iterative technique for solving a system of linear equations (Ax = b).\nThe function should iteratively update the solution vector (x) by using the most recent values available during the iteration process.\nWrite a function `gauss_seidel(A, b, n, x_ini=None)` where:\n- `A` is a square matrix of coefficients,\n- `b` is the right-hand side vector,\n- `n` is the number of iterations,\n- `x_ini` is an optional initial guess for (x) (if not provided, assume a vector of zeros).\nThe function should return the approximated solution vector (x) after performing the specified number of iterations.", "inputs": ["gauss_seidel(A = np.array([[4, 1, 2], [3, 5, 1], [1, 1, 3]], dtype=float), b = np.array([4, 7, 3], dtype=float), n = 100)"], "outputs": ["[0.5, 1.0, 0.5]"], "reasoning": ["The Gauss-Seidel method iteratively updates the solution vector (x) until convergence. The output is an approximate solution to the linear system."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "gauss_seidel", "starter_code": "def gauss_seidel(A, b, n, x_ini=None):", "reference_code": "def gauss_seidel_it(A, b, x):\n    rows, cols = A.shape\n    for i in range(rows):\n        x_new = b[i]\n        for j in range(cols):\n            if i != j:\n                x_new -= A[i, j] * x[j]\n        x[i] = x_new / A[i, i]\n    return x\n\ndef gauss_seidel(A, b, n, x_ini=None):\n    x = x_ini or np.zeros_like(b)\n    for _ in range(n):\n        x = gauss_seidel_it(A, b, x)\n    return np.round(x, 4).tolist()", "test_cases": ["assert gauss_seidel(np.array([[4, 1, 2], [3, 5, 1], [1, 1, 3]], dtype=float), np.array([4, 7, 3], dtype=float), 5) == [0.5008, 0.9997, 0.4998]", "assert gauss_seidel(np.array([[4, -1, 0, 1], [-1, 4, -1, 0], [0, -1, 4, -1], [1, 0, -1, 4]], dtype=float), np.array([15, 10, 10, 15], dtype=float), 1) == [3.75, 3.4375, 3.3594, 3.6523]", "assert gauss_seidel(np.array([[10, -1, 2], [-1, 11, -1], [2, -1, 10]], dtype=float), np.array([6, 25, -11], dtype=float), 100) == [1.0433, 2.2692, -1.0817]"]}
{"id": 58, "difficulty": "medium", "category": "Linear Algebra", "title": "Gaussian Elimination for Solving Linear Systems", "description": "Task: Implement the Gaussian Elimination Method\nYour task is to implement the Gaussian Elimination method, which transforms a system of linear equations into an upper triangular matrix. This method can then be used to solve for the variables using backward substitution.\nWrite a function `gaussian_elimination(A, b)` that performs Gaussian Elimination with partial pivoting to solve the system (Ax = b).\nThe function should return the solution vector (x).", "inputs": ["gaussian_elimination(A = np.array([[2,8,4], [2,5,1], [4,10,-1]], dtype=float), b = np.array([2,5,1], dtype=float))"], "outputs": ["[11.0, -4.0, 3.0]"], "reasoning": ["The Gaussian Elimination method transforms the system of equations into an upper triangular matrix and then uses backward substitution to solve for the variables."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "gaussian_elimination", "starter_code": "def gaussian_elimination(A, b):", "reference_code": "def partial_pivoting(A_aug, row_num, col_num):\n    rows, cols = A_aug.shape\n    max_row = row_num\n    max_val = abs(A_aug[row_num, col_num])\n    for i in range(row_num, rows):\n        current_val = abs(A_aug[i, col_num])\n        if current_val > max_val:\n            max_val = current_val\n            max_row = i\n    if max_row != row_num:\n        A_aug[[row_num, max_row]] = A_aug[[max_row, row_num]]\n    return A_aug\n\ndef gaussian_elimination(A, b):\n    rows, cols = A.shape\n    A_aug = np.hstack((A, b.reshape(-1, 1)))\n\n    for i in range(rows-1):\n        A_aug = partial_pivoting(A_aug, i, i)\n        for j in range(i+1, rows):\n            A_aug[j, i:] -= (A_aug[j, i] / A_aug[i, i]) * A_aug[i, i:]\n\n    x = np.zeros_like(b, dtype=float)\n    for i in range(rows-1, -1, -1):\n        x[i] = (A_aug[i, -1] - np.dot(A_aug[i, i+1:cols], x[i+1:])) / A_aug[i, i]\n    return np.round(x, 4).tolist()", "test_cases": ["assert gaussian_elimination(np.array([[2,8,4], [2,5,1], [4,10,-1]], dtype=float), np.array([2,5,1], dtype=float)) == [11.0, -4.0, 3.0]", "assert gaussian_elimination(np.array([ [0, 2, 1, 0, 0, 0, 0], [2, 6, 2, 1, 0, 0, 0], [1, 2, 7, 2, 1, 0, 0], [0, 1, 2, 8, 2, 1, 0], [0, 0, 1, 2, 9, 2, 1], [0, 0, 0, 1, 2, 10, 2], [0, 0, 0, 0, 1, 2, 11] ], dtype=float), np.array([1, 2, 3, 4, 5, 6, 7], dtype=float)) == [-0.4894, 0.3617, 0.2766, 0.2554, 0.319, 0.4039, 0.5339]", "assert gaussian_elimination(np.array([[2, 1, -1], [-3, -1, 2], [-2, 1, 2]], dtype=float), np.array([8, -11, -3], dtype=float)) == [2.0, 3.0, -1.0]"]}
{"id": 59, "difficulty": "medium", "category": "Deep Learning", "title": "Implement Long Short-Term Memory (LSTM) Network", "description": "Task: Implement Long Short-Term Memory (LSTM) Network\nYour task is to implement an LSTM network that processes a sequence of inputs and produces the final hidden state and cell state after processing all inputs.\nWrite a class `LSTM` with the following methods:\n- `__init__(self, input_size, hidden_size)`: Initializes the LSTM with random weights and zero biases.\n- `forward(self, x, initial_hidden_state, initial_cell_state)`: Processes a sequence of inputs and returns the hidden states at each time step, as well as the final hidden state and cell state.\nThe LSTM should compute the forget gate, input gate, candidate cell state, and output gate at each time step to update the hidden state and cell state.", "inputs": ["lstm = LSTM(input_size=1, hidden_size=1)\nlstm.forward(x = np.array([[1.0], [2.0], [3.0]]), initial_hidden_state = np.zeros((1, 1)), initial_cell_state = np.zeros((1, 1)))"], "outputs": ["([[[0.0806]], [[0.0358]], [[0.0077]]], [[0.0077]], [[0.0738]])"], "reasoning": ["The LSTM processes the input sequence [1.0, 2.0, 3.0] and produces the final hidden state [0.73698596]."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "LSTM", "starter_code": "class LSTM:\n    def __init__(self, input_size, hidden_size):\n        self.input_size = input_size\n        self.hidden_size = hidden_size\n\n        # Initialize weights and biases\n        self.Wf = np.random.randn(hidden_size, input_size + hidden_size)\n        self.Wi = np.random.randn(hidden_size, input_size + hidden_size)\n        self.Wc = np.random.randn(hidden_size, input_size + hidden_size)\n        self.Wo = np.random.randn(hidden_size, input_size + hidden_size)\n\n        self.bf = np.zeros((hidden_size, 1))\n        self.bi = np.zeros((hidden_size, 1))\n        self.bc = np.zeros((hidden_size, 1))\n        self.bo = np.zeros((hidden_size, 1))\n\n    def forward(self, x, initial_hidden_state, initial_cell_state):\n        \"\"\"\n        Processes a sequence of inputs and returns the hidden states, final hidden state, and final cell state.\n        \"\"\"", "reference_code": "class LSTM:\n    def __init__(self, input_size, hidden_size):\n        self.input_size = input_size\n        self.hidden_size = hidden_size\n\n        # Initialize weights and biases\n        self.Wf = np.random.randn(hidden_size, input_size + hidden_size)\n        self.Wi = np.random.randn(hidden_size, input_size + hidden_size)\n        self.Wc = np.random.randn(hidden_size, input_size + hidden_size)\n        self.Wo = np.random.randn(hidden_size, input_size + hidden_size)\n\n        self.bf = np.zeros((hidden_size, 1))\n        self.bi = np.zeros((hidden_size, 1))\n        self.bc = np.zeros((hidden_size, 1))\n        self.bo = np.zeros((hidden_size, 1))\n\n    def forward(self, x, initial_hidden_state, initial_cell_state):\n        \"\"\"\n        Processes a sequence of inputs and returns the hidden states, final hidden state, and final cell state.\n        \"\"\"\n        h = initial_hidden_state\n        c = initial_cell_state\n        outputs = []\n\n        for t in range(len(x)):\n            xt = x[t].reshape(-1, 1)\n            concat = np.vstack((h, xt))\n\n            # Forget gate\n            ft = self.sigmoid(np.dot(self.Wf, concat) + self.bf)\n\n            # Input gate\n            it = self.sigmoid(np.dot(self.Wi, concat) + self.bi)\n            c_tilde = np.tanh(np.dot(self.Wc, concat) + self.bc)\n\n            # Cell state update\n            c = ft * c + it * c_tilde\n\n            # Output gate\n            ot = self.sigmoid(np.dot(self.Wo, concat) + self.bo)\n\n            # Hidden state update\n            h = ot * np.tanh(c)\n\n            outputs.append(h)\n\n        return np.round(np.array(outputs), 4).tolist(), np.round(h, 4).tolist(), np.round(c, 4).tolist()\n\n    def sigmoid(self, x):\n        return 1 / (1 + np.exp(-x))", "test_cases": ["input_sequence = np.array([[1.0], [2.0], [3.0]]) \ninitial_hidden_state = np.zeros((1, 1)) \ninitial_cell_state = np.zeros((1, 1)) \nlstm = LSTM(input_size=1, hidden_size=1) # Set weights and biases for reproducibility \nlstm.Wf = np.array([[0.5, 0.5]]) \nlstm.Wi = np.array([[0.5, 0.5]]) \nlstm.Wc = np.array([[0.3, 0.3]]) \nlstm.Wo = np.array([[0.5, 0.5]]) \nlstm.bf = np.array([[0.1]]) \nlstm.bi = np.array([[0.1]]) \nlstm.bc = np.array([[0.1]]) \nlstm.bo = np.array([[0.1]]) \noutputs, final_h, final_c = lstm.forward(input_sequence, initial_hidden_state, initial_cell_state)\nassert final_h == [[0.7370]]", "input_sequence = np.array([[0.1, 0.2], [0.3, 0.4]]) \ninitial_hidden_state = np.zeros((2, 1)) \ninitial_cell_state = np.zeros((2, 1)) \nlstm = LSTM(input_size=2, hidden_size=2) # Set weights and biases for reproducibility \nlstm.Wf = np.array([[0.1, 0.2, 0.3, 0.4], [0.5, 0.6, 0.7, 0.8]]) \nlstm.Wi = np.array([[0.1, 0.2, 0.3, 0.4], [0.5, 0.6, 0.7, 0.8]]) \nlstm.Wc = np.array([[0.1, 0.2, 0.3, 0.4], [0.5, 0.6, 0.7, 0.8]]) \nlstm.Wo = np.array([[0.1, 0.2, 0.3, 0.4], [0.5, 0.6, 0.7, 0.8]]) \nlstm.bf = np.array([[0.1], [0.2]]) \nlstm.bi = np.array([[0.1], [0.2]]) \nlstm.bc = np.array([[0.1], [0.2]]) \nlstm.bo = np.array([[0.1], [0.2]]) \noutputs, final_h, final_c = lstm.forward(input_sequence, initial_hidden_state, initial_cell_state)\nassert final_h == [[0.1661], [0.4030]]", "input_sequence = np.array([[1, 3], [2, 4]]) \ninitial_hidden_state = np.zeros((2, 1)) \ninitial_cell_state = np.zeros((2, 1)) \nlstm = LSTM(input_size=2, hidden_size=2) # Set weights and biases for reproducibility \nlstm.Wf = np.array([[0.1, 0.2, 0.3, 0.4], [0.5, 0.6, 0.7, 0.8]]) \nlstm.Wi = np.array([[0.1, 0.2, 0.3, 0.4], [0.5, 0.6, 0.7, 0.8]]) \nlstm.Wc = np.array([[0.1, 0.2, 0.3, 0.4], [0.5, 0.6, 0.7, 0.8]]) \nlstm.Wo = np.array([[0.1, 0.2, 0.3, 0.4], [0.5, 0.6, 0.7, 0.8]]) \nlstm.bf = np.array([[0.1], [0.2]]) \nlstm.bi = np.array([[0.1], [0.2]]) \nlstm.bc = np.array([[0.1], [0.2]]) \nlstm.bo = np.array([[0.1], [0.2]]) \noutputs, final_h, final_c = lstm.forward(input_sequence, initial_hidden_state, initial_cell_state)\nassert final_h == [[0.8543], [0.9567]]"]}
{"id": 60, "difficulty": "medium", "category": "NLP", "title": "Implement TF-IDF (Term Frequency-Inverse Document Frequency)", "description": "Task: Implement TF-IDF (Term Frequency-Inverse Document Frequency)\nYour task is to implement a function that computes the TF-IDF scores for a query against a given corpus of documents.\nFunction Signature\nWrite a function `compute_tf_idf(corpus, query)` that takes the following inputs:\n- `corpus`: A list of documents, where each document is a list of words.\n- `query`: A list of words for which you want to compute the TF-IDF scores.\nOutput\nThe function should return a list of lists containing the TF-IDF scores for the query words in each document, rounded to five decimal places.\nImportant Considerations\n1. Handling Division by Zero:\nWhen implementing the Inverse Document Frequency (IDF) calculation, you must account for cases where a term does not appear in any document (`df = 0`). This can lead to division by zero in the standard IDF formula. Add smoothing (e.g., adding 1 to both numerator and denominator) to avoid such errors.\n2. Empty Corpus:\nEnsure your implementation gracefully handles the case of an empty corpus. If no documents are provided, your function should either raise an appropriate error or return an empty result. This will ensure the program remains robust and predictable.\n3. Edge Cases:\n- Query terms not present in the corpus.\n- Documents with no words.\n- Extremely large or small values for term frequencies or document frequencies.\nBy addressing these considerations, your implementation will be robust and handle real-world scenarios effectively.", "inputs": ["compute_tf_idf(corpus = [[\"the\", \"cat\", \"sat\", \"on\", \"the\", \"mat\"], [\"the\", \"dog\", \"chased\", \"the\", \"cat\"], [\"the\", \"bird\", \"flew\", \"over\", \"the\", \"mat\"]], query = [\"cat\"])"], "outputs": ["[[0.21461], [0.25754], [0.0]]"], "reasoning": ["The TF-IDF scores for the word \"cat\" in each document are computed and rounded to five decimal places."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "compute_tf_idf", "starter_code": "def compute_tf_idf(corpus, query):", "reference_code": "def compute_tf_idf(corpus, query):\n    \"\"\"\n    Compute TF-IDF scores for a query against a corpus of documents using only NumPy.\n    The output TF-IDF scores retain five decimal places.\n    \"\"\"\n    vocab = sorted(set(word for document in corpus for word in document).union(query))\n    word_to_index = {word: idx for idx, word in enumerate(vocab)}\n\n    tf = np.zeros((len(corpus), len(vocab)))\n\n    for doc_idx, document in enumerate(corpus):\n        for word in document:\n            word_idx = word_to_index[word]\n            tf[doc_idx, word_idx] += 1\n        tf[doc_idx, :] /= len(document)\n\n    df = np.count_nonzero(tf > 0, axis=0)\n\n    num_docs = len(corpus)\n    idf = np.log((num_docs + 1) / (df + 1)) + 1\n\n    tf_idf = tf * idf\n\n    query_indices = [word_to_index[word] for word in query]\n    tf_idf_scores = tf_idf[:, query_indices]\n\n    tf_idf_scores = np.round(tf_idf_scores, 5)\n\n    return np.round(tf_idf_scores, 4).tolist()", "test_cases": ["assert compute_tf_idf([ [\"the\", \"cat\", \"sat\", \"on\", \"the\", \"mat\"], [\"the\", \"dog\", \"chased\", \"the\", \"cat\"], [\"the\", \"bird\", \"flew\", \"over\", \"the\", \"mat\"] ] , [\"cat\"]) == [[0.2146], [0.2575], [0.0]]", "assert compute_tf_idf([ [\"the\", \"cat\", \"sat\", \"on\", \"the\", \"mat\"], [\"the\", \"dog\", \"chased\", \"the\", \"cat\"], [\"the\", \"bird\", \"flew\", \"over\", \"the\", \"mat\"] ], [\"cat\", \"mat\"]) == [[0.2146, 0.2146], [0.2575, 0.0], [0.0, 0.2146]]", "assert compute_tf_idf([ [\"this\", \"is\", \"a\", \"sample\"], [\"this\", \"is\", \"another\", \"example\"], [\"yet\", \"another\", \"sample\", \"document\"], [\"one\", \"more\", \"document\", \"for\", \"testing\"] ], [\"sample\", \"document\", \"test\"]) == [[0.3777, 0.0, 0.0], [0.0, 0.0, 0.0], [0.3777, 0.3777, 0.0], [0.0, 0.3022, 0.0]]"]}
{"id": 61, "difficulty": "easy", "category": "Machine Learning", "title": "Implement F-Score Calculation for Binary Classification", "description": "Task: Implement F-Score Calculation for Binary Classification\n\nYour task is to implement a function that calculates the F-Score for a binary classification task. The F-Score combines both Precision and Recall into a single metric, providing a balanced measure of a model's performance.\n\nWrite a function `f_score(y_true, y_pred, beta)` where:\n\n- `y_true`: A numpy array of true labels (binary).\n- `y_pred`: A numpy array of predicted labels (binary).\n- `beta`: A float value that adjusts the importance of Precision and Recall. When `beta`=1, it computes the F1-Score, a balanced measure of both Precision and Recall.\n\nThe function should return the F-Score rounded to three decimal places.", "inputs": ["f_score(y_true = np.array([1, 0, 1, 1, 0, 1]), y_pred = np.array([1, 0, 1, 0, 0, 1]), beta = 1)"], "outputs": ["0.857"], "reasoning": ["The F-Score for the binary classification task is calculated using the true labels, predicted labels, and beta value."], "import_code": "import numpy as np", "output_constrains": "", "entry_point": "f_score", "starter_code": "def f_score(y_true, y_pred, beta):\n    \"\"\"\n    Calculate F-Score for a binary classification task.\n\n    :param y_true: Numpy array of true labels\n    :param y_pred: Numpy array of predicted labels\n    :param beta: The weight of precision in the harmonic mean\n    :return: F-Score rounded to three decimal places\n    \"\"\"", "reference_code": "def f_score(y_true, y_pred, beta):\n    \"\"\"\n    Calculate F-Score for a binary classification task.\n\n    :param y_true: Numpy array of true labels\n    :param y_pred: Numpy array of predicted labels\n    :param beta: The weight of precision in the harmonic mean\n    :return: F-Score rounded to three decimal places\n    \"\"\"\n    tp = np.sum((y_true == 1) & (y_pred == 1))\n    fn = np.sum((y_true == 1) & (y_pred == 0))\n    fp = np.sum((y_true == 0) & (y_pred == 1))\n\n    recall = tp / (tp + fn) if (tp + fn) > 0 else 0\n    precision = tp / (tp + fp) if (tp + fp) > 0 else 0\n\n    op = precision * recall\n    div = ((beta**2) * precision) + recall\n\n    if div == 0 or op == 0:\n        return 0.0\n    score = (1 + (beta ** 2)) * op / div\n    return round(score, 3)", "test_cases": ["assert f_score(np.array([1, 0, 1, 1, 0, 1]), np.array([1, 0, 1, 0, 0, 1]), 1) == 0.857", "assert f_score(np.array([1, 0, 1, 1, 0, 0]), np.array([1, 0, 0, 0, 0, 1]), 1) == 0.4", "assert f_score(np.array([1, 0, 1, 1, 0, 0]), np.array([1, 0, 1, 1, 0, 0]), 2) == 1.0", "assert f_score(np.array([1, 0, 1, 1, 0, 1]), np.array([0, 0, 0, 1, 0, 1]), 2) == 0.556", "assert f_score(np.array([1, 1, 1, 1, 0, 0, 0]), np.array([0, 1, 0, 1, 1, 0, 0]), 3) == 0.513"]}
{"id": 62, "difficulty": "hard", "category": "Deep Learning", "title": "Implement a Simple RNN with Backpropagation Through Time (BPTT)", "description": "Task: Implement a Simple RNN with Backpropagation Through Time (BPTT)\n\nYour task is to implement a simple Recurrent Neural Network (RNN) and backpropagation through time (BPTT) to learn from sequential data. The RNN will process input sequences, update hidden states, and perform backpropagation to adjust weights based on the error gradient.\n\nWrite the following methods to complete the initialization, forward pass, and backward pass of the RNN:\n\n- `initialize_weights(input_size, hidden_size, output_size)`: Initializes the RNN with weights set to random values multiplied by 0.01 and biases set to zero.\n- `rnn_forward(W_xh, W_hh, W_hy, b_h, b_y, hidden_size, input_sequence)`: Processes a sequence of inputs and returns the output, the last inputs and the hidden states.\n- `rnn_backward(W_xh, W_hh, W_hy, b_h, b_y, hidden_size, input_sequence, expected_output, outputs, last_inputs, last_hiddens, learning_rate)`: Performs backpropagation through time (BPTT) to adjust the weights based on the loss.\n\nIn this task, the RNN will be trained on sequence prediction, where the network will learn to predict the next item in a sequence. You should use 1/2 * Mean Squared Error (MSE) as the loss function and make sure to aggregate the losses at each time step by summing.", "inputs": ["input_sequence = np.array([[1.0], [2.0], [3.0], [4.0]])\nexpected_output = np.array([[2.0], [3.0], [4.0], [5.0]])\n# Initialize RNN\nrnn = SimpleRNN(input_size=1, hidden_size=5, output_size=1)\n\nrnn.forward(input_sequence)\nrnn.backward(input_sequence, expected_output, learning_rate=0.01)\nrnn.forward(input_sequence)"], "outputs": ["[[[0.001]], [[0.0021]], [[0.0031]], [[0.0041]]]"], "reasoning": ["The RNN processes the input sequence [1.0, 2.0, 3.0, 4.0] and predicts the next item in the sequence at each step."], "import_code": "import numpy as np", "output_constrains": "", "entry_point": "SimpleRNN", "starter_code": "class SimpleRNN:\n    def __init__(self, input_size, hidden_size, output_size):\n        \"\"\"\n        Initializes the RNN with random weights and zero biases.\n        \"\"\"\n        self.hidden_size = hidden_size\n        self.W_xh = np.random.randn(hidden_size, input_size)*0.01\n        self.W_hh = np.random.randn(hidden_size, hidden_size)*0.01\n        self.W_hy = np.random.randn(output_size, hidden_size)*0.01\n        self.b_h = np.zeros((hidden_size, 1))\n        self.b_y = np.zeros((output_size, 1))\n\n    def forward(self, x):\n        \"\"\"\n        Forward pass through the RNN for a given sequence of inputs.\n        \"\"\"", "reference_code": "class SimpleRNN:\n    def __init__(self, input_size, hidden_size, output_size):\n        \"\"\"\n        Initializes the RNN with random weights and zero biases.\n        \"\"\"\n        self.hidden_size = hidden_size\n        self.W_xh = np.random.randn(hidden_size, input_size)*0.01\n        self.W_hh = np.random.randn(hidden_size, hidden_size)*0.01\n        self.W_hy = np.random.randn(output_size, hidden_size)*0.01\n        self.b_h = np.zeros((hidden_size, 1))\n        self.b_y = np.zeros((output_size, 1))\n\n    def forward(self, x):\n        \"\"\"\n        Forward pass through the RNN for a given sequence of inputs.\n        \"\"\"\n\n        # Initialize hidden state\n        h = np.zeros((self.hidden_size, 1))\n        outputs = []\n        self.last_inputs = []\n        self.last_hiddens = [h]\n        \n        for t in range(len(x)):\n            self.last_inputs.append(x[t].reshape(-1, 1))\n            h = np.tanh(np.dot(self.W_xh, self.last_inputs[t]) + np.dot(self.W_hh, h) + self.b_h)\n            y = np.dot(self.W_hy, h) + self.b_y\n            outputs.append(y)\n            self.last_hiddens.append(h)\n        \n        self.last_outputs = outputs\n        return np.array(outputs)\n\n    def backward(self, x, y, learning_rate):\n        dW_xh = np.zeros_like(self.W_xh)\n        dW_hh = np.zeros_like(self.W_hh)\n        dW_hy = np.zeros_like(self.W_hy)\n        db_h = np.zeros_like(self.b_h)\n        db_y = np.zeros_like(self.b_y)\n\n        dh_next = np.zeros((self.hidden_size, 1))\n\n        for t in reversed(range(len(x))):\n            dy = self.last_outputs[t] - y[t].reshape(-1, 1)  # (Predicted - Actual)\n            dW_hy += np.dot(dy, self.last_hiddens[t+1].T)\n            db_y += dy\n\n            dh = np.dot(self.W_hy.T, dy) + dh_next\n            dh_raw = (1 - self.last_hiddens[t+1] ** 2) * dh  # Derivative of tanh\n\n            dW_xh += np.dot(dh_raw, self.last_inputs[t].T)\n            dW_hh += np.dot(dh_raw, self.last_hiddens[t].T)\n            db_h += dh_raw\n\n            dh_next = np.dot(self.W_hh.T, dh_raw)\n\n        # Update weights and biases\n        self.W_xh -= learning_rate * dW_xh\n        self.W_hh -= learning_rate * dW_hh\n        self.W_hy -= learning_rate * dW_hy\n        self.b_h -= learning_rate * db_h\n        self.b_y -= learning_rate * db_y", "test_cases": ["np.random.seed(42)\ninput_sequence = np.array([[1.0], [2.0], [3.0], [4.0]])\nexpected_output = np.array([[2.0], [3.0], [4.0], [5.0]])\nrnn = SimpleRNN(input_size=1, hidden_size=5, output_size=1)\n# Train the RNN over multiple epochs\n\nfor epoch in range(100): \n    output = rnn.forward(input_sequence)\n    rnn.backward(input_sequence, expected_output, learning_rate=0.01)\n    output = np.round(output, 4).tolist()\n\nassert output == [[[2.2414]], [[3.1845]], [[4.0431]], [[4.5742]]]", "np.random.seed(42)\ninput_sequence = np.array([[1.0,2.0], [7.0,2.0], [1.0,3.0], [12.0,4.0]])\nexpected_output = np.array([[2.0], [3.0], [4.0], [5.0]])\nrnn = SimpleRNN(input_size=2, hidden_size=3, output_size=1)\n# Train the RNN over multiple epochs\nfor epoch in range(100):\n    output = rnn.forward(input_sequence)\n    rnn.backward(input_sequence, expected_output, learning_rate=0.01)\n    output = np.round(output, 4).tolist()\n\nassert output == [[[2.422]], [[3.4417]], [[3.613]], [[4.5066]]]", "np.random.seed(42)\ninput_sequence = np.array([[1.0,2.0], [7.0,2.0], [1.0,3.0], [12.0,4.0]])\nexpected_output = np.array([[2.0,1.0], [3.0,7.0], [4.0,8.0], [5.0,10.0]])\nrnn = SimpleRNN(input_size=2, hidden_size=10, output_size=2)\n# Train the RNN over multiple epochs\nfor epoch in range(50):\n    output = rnn.forward(input_sequence)\n    rnn.backward(input_sequence, expected_output, learning_rate=0.01)\n    output = np.round(output, 4).tolist()\n\nassert output == [[[3.2842], [5.9353]], [[3.6039], [6.8201]], [[3.5259], [6.5828]], [[3.6134], [6.8492]]]"]}
{"id": 63, "difficulty": "hard", "category": "Linear Algebra", "title": "Implement the Conjugate Gradient Method for Solving Linear Systems", "description": "Task: Implement the Conjugate Gradient Method for Solving Linear Systems\n\nYour task is to implement the Conjugate Gradient (CG) method, an efficient iterative algorithm for solving large, sparse, symmetric, positive-definite linear systems. Given a matrix `A` and a vector `b`, the algorithm will solve for `x` in the system ( Ax = b ).\n\nWrite a function `conjugate_gradient(A, b, n, x0=None, tol=1e-8)` that performs the Conjugate Gradient method as follows:\n\n- `A`: A symmetric, positive-definite matrix representing the linear system.\n- `b`: The vector on the right side of the equation.\n- `n`: Maximum number of iterations.\n- `x0`: Initial guess for the solution vector.\n- `tol`: Tolerance for stopping criteria.\n\nThe function should return the solution vector `x`.", "inputs": ["conjugate_gradient(A = np.array([[4, 1], [1, 3]]), b = np.array([1, 2]), n = 5)"], "outputs": ["[0.09090909, 0.63636364]"], "reasoning": ["The Conjugate Gradient method is applied to the linear system Ax = b with the given matrix A and vector b. The algorithm iteratively refines the solution to converge to the exact solution."], "import_code": "import numpy as np", "output_constrains": "The final solution vector x should be rounded to 8 decimal places and converted to a list using tolist() when returned.", "entry_point": "conjugate_gradient", "starter_code": "def conjugate_gradient(A: np.array, b: np.array, n: int, x0: np.array=None, tol=1e-8):\n    \"\"\"\n    Solve the system Ax = b using the Conjugate Gradient method.\n\n    :param A: Symmetric positive-definite matrix\n    :param b: Right-hand side vector\n    :param n: Maximum number of iterations\n    :param x0: Initial guess for solution (default is zero vector)\n    :param tol: Convergence tolerance\n    :return: Solution vector x\n    \"\"\"", "reference_code": "def residual(A: np.array, b: np.array, x: np.array) -> np.array:\n    # calculate linear system residuals\n    return b - A @ x\n\ndef alpha(A: np.array, r: np.array, p: np.array) -> float:\n\n    # calculate step size\n    alpha_num = np.dot(r, r)\n    alpha_den = np.dot(p @ A, p)\n\n    return alpha_num/alpha_den\n\ndef beta(r: np.array, r_plus1: np.array) -> float:\n\n    # calculate direction scaling\n    beta_num = np.dot(r_plus1, r_plus1)\n    beta_den = np.dot(r, r)\n\n    return beta_num/beta_den\n\ndef conjugate_gradient(A: np.array, b: np.array, n: int, x0: np.array=None, tol=1e-8):\n    \"\"\"\n    Solve the system Ax = b using the Conjugate Gradient method.\n\n    :param A: Symmetric positive-definite matrix\n    :param b: Right-hand side vector\n    :param n: Maximum number of iterations\n    :param x0: Initial guess for solution (default is zero vector)\n    :param tol: Convergence tolerance\n    :return: Solution vector x\n    \"\"\"\n\n    # calculate initial residual vector\n    x = np.zeros_like(b)\n    r = residual(A, b, x) # residual vector\n    rPlus1 = r\n    p = r # search direction vector\n\n    for i in range(n):\n\n        # line search step value - this minimizes the error along the current search direction\n        alp = alpha(A, r, p)\n\n        # new x and r based on current p (the search direction vector)\n        x = x + alp * p\n        rPlus1 = r - alp * (A@p)\n\n        # calculate beta - this ensures that all vectors are A-orthogonal to each other\n        bet = beta(r, rPlus1)\n\n        # update x and r\n        # using a othogonal search direction ensures we get all the information we need in more direction and then don't have to search in that direction again\n        p = rPlus1 + bet * p\n\n        # update residual vector\n        r = rPlus1\n\n        # break if less than tolerance\n        if np.linalg.norm(residual(A,b,x)) < tol:\n            break\n\n    return np.round(x, 8).tolist()", "test_cases": ["assert conjugate_gradient(np.array([[6, 2, 1, 1, 0], [2, 5, 2, 1, 1], [1, 2, 6, 1, 2], [1, 1, 1, 7, 1], [0, 1, 2, 1, 8]]), np.array([1, 2, 3, 4, 5]), 100) == [0.01666667, 0.11666667, 0.21666667, 0.45, 0.5]", "assert conjugate_gradient(np.array([[4, 1, 2], [1, 3, 0], [2, 0, 5]]), np.array([7, 8, 5]), 1) == [1.2627451, 1.44313725, 0.90196078]", "assert conjugate_gradient(np.array([[6, 2, 1, 1, 0], [2, 5, 2, 1, 1], [1, 2, 6, 1, 2], [1, 1, 1, 7, 1], [0, 1, 2, 1, 8]]), np.array([1, 2, 3, 4, 5]), 100) == [0.01666667, 0.11666667, 0.21666667, 0.45, 0.5]"]}
{"id": 64, "difficulty": "easy", "category": "Machine Learning", "title": "Implement Gini Impurity Calculation for a Set of Classes", "description": "Task: Implement Gini Impurity Calculation\n\nYour task is to implement a function that calculates the Gini Impurity for a set of classes. Gini impurity is commonly used in decision tree algorithms to measure the impurity or disorder within a node.", "inputs": ["gini_impurity(y = [0, 1, 1, 1, 0])"], "outputs": ["0.48"], "reasoning": ["The Gini Impurity is calculated as 1 - (p_0^2 + p_1^2), where p_0 and p_1 are the probabilities of each class. In this case, p_0 = 2/5 and p_1 = 3/5, resulting in a Gini Impurity of 0.48."], "import_code": "import numpy as np", "output_constrains": "", "entry_point": "gini_impurity", "starter_code": "def gini_impurity(y: list[int]) -> float:\n    \"\"\"\n    Calculate Gini Impurity for a list of class labels.\n\n    :param y: List of class labels\n    :return: Gini Impurity rounded to three decimal places\n    \"\"\"", "reference_code": "def gini_impurity(y: list[int]) -> float:\n    \"\"\"\n    Calculate Gini Impurity for a list of class labels.\n\n    :param y: List of class labels\n    :return: Gini Impurity rounded to three decimal places\n    \"\"\"\n    classes = set(y)\n    n = len(y)\n\n    gini_impurity = 0\n\n    for cls in classes:\n        gini_impurity += (y.count(cls)/n)**2\n\n    return round(1-gini_impurity,3)", "test_cases": ["assert gini_impurity([0, 0, 0, 0, 1, 1, 1, 1]) == 0.5", "assert gini_impurity([0, 0, 0, 0, 0, 1]) == 0.278", "assert gini_impurity([0, 1, 2, 2, 2, 1, 2]) == 0.571"]}
{"id": 65, "difficulty": "easy", "category": "Linear Algebra", "title": "Implement Compressed Row Sparse Matrix (CSR) Format Conversion", "description": "Task: Convert a Dense Matrix to Compressed Row Sparse (CSR) Format\n\nYour task is to implement a function that converts a given dense matrix into the Compressed Row Sparse (CSR) format, an efficient storage representation for sparse matrices. The CSR format only stores non-zero elements and their positions, significantly reducing memory usage for matrices with a large number of zeros.\n\nWrite a function `compressed_row_sparse_matrix(dense_matrix)` that takes a 2D list `dense_matrix` as input and returns a tuple containing three lists:\n\n- **Values array**: List of all non-zero elements in row-major order.\n- **Column indices array**: Column index for each non-zero element in the values array.\n- **Row pointer array**: Cumulative number of non-zero elements per row, indicating the start of each row in the values array.", "inputs": ["compressed_row_sparse_matrix(dense_matrix = [[1, 0, 0, 0], [0, 2, 0, 0], [3, 0, 4, 0], [1, 0, 0, 5]])"], "outputs": ["([1, 2, 3, 4, 1, 5], [0, 1, 0, 2, 0, 3], [0, 1, 2, 4, 6])"], "reasoning": ["The dense matrix is converted to CSR format with the values array containing non-zero elements, column indices array storing the corresponding column index, and row pointer array indicating the start of each row in the values array."], "import_code": "", "output_constrains": "", "entry_point": "compressed_row_sparse_matrix", "starter_code": "def compressed_row_sparse_matrix(dense_matrix):\n    \"\"\"\n    Convert a dense matrix to its Compressed Row Sparse (CSR) representation.\n\n    :param dense_matrix: 2D list representing a dense matrix\n    :return: A tuple containing (values array, column indices array, row pointer array)\n    \"\"\"", "reference_code": "def compressed_row_sparse_matrix(dense_matrix):\n    \"\"\"\n    Convert a dense matrix to its Compressed Row Sparse (CSR) representation.\n\n    :param dense_matrix: 2D list representing a dense matrix\n    :return: A tuple containing (values array, column indices array, row pointer array)\n    \"\"\"\n    vals = []\n    col_idx = []\n    row_ptr = [0]\n\n    for row in dense_matrix:\n        for j, val in enumerate(row):\n            if val != 0:\n                vals.append(val)\n                col_idx.append(j)\n        row_ptr.append(len(vals))\n\n    return vals, col_idx, row_ptr", "test_cases": ["assert compressed_row_sparse_matrix([[1, 0, 0, 0], [0, 2, 0, 0], [3, 0, 4, 0], [1, 0, 0, 5]]) == ([1, 2, 3, 4, 1, 5], [0, 1, 0, 2, 0, 3], [0, 1, 2, 4, 6])", "assert compressed_row_sparse_matrix([[0, 0, 0], [1, 2, 0], [0, 3, 4]]) == ([1, 2, 3, 4], [0, 1, 1, 2], [0, 0, 2, 4])", "assert compressed_row_sparse_matrix([[0, 0, 3, 0, 0], [0, 4, 0, 0, 0], [5, 0, 0, 6, 0], [0, 0, 0, 0, 0], [0, 7, 0, 0, 8]]) == ([3, 4, 5, 6, 7, 8], [2, 1, 0, 3, 1, 4], [0, 1, 2, 4, 4, 6])"]}
{"id": 66, "difficulty": "easy", "category": "Linear Algebra", "title": "Implement Orthogonal Projection of a Vector onto a Line", "description": "Task: Compute the Orthogonal Projection of a Vector\n\nYour task is to implement a function that calculates the orthogonal projection of a vector **v** onto another vector **L**. This projection results in the vector on **L** that is closest to **v**.\n\nWrite a function `orthogonal_projection(v, L)` that takes in two lists, `v` (the vector to be projected) and `L` (the line vector), and returns the orthogonal projection of `v` onto `L`. The function should output a list representing the projection vector rounded to three decimal places.", "inputs": ["orthogonal_projection(v = [3, 4], L = [1, 0])"], "outputs": ["[3.0, 0.0]"], "reasoning": ["The orthogonal projection of vector [3, 4] onto the line defined by [1, 0] results in the projection vector [3, 0], which lies on the line [1, 0]."], "import_code": "", "output_constrains": "", "entry_point": "orthogonal_projection", "starter_code": "def orthogonal_projection(v, L):\n    \"\"\"\n    Compute the orthogonal projection of vector v onto line L.\n\n    :param v: The vector to be projected\n    :param L: The line vector defining the direction of projection\n    :return: List representing the projection of v onto L\n    \"\"\"", "reference_code": "def dot(v1, v2):\n    return sum([ax1 * ax2 for ax1, ax2 in zip(v1, v2)])\n\ndef scalar_mult(scalar, v):\n    return [scalar * ax for ax in v]\n\ndef orthogonal_projection(v, L):\n    \"\"\"\n    Compute the orthogonal projection of vector v onto line L.\n\n    :param v: The vector to be projected\n    :param L: The line vector defining the direction of projection\n    :return: List representing the projection of v onto L\n    \"\"\"\n    L_mag_sq = dot(L, L)\n    proj_scalar = dot(v, L) / L_mag_sq\n    proj_v = scalar_mult(proj_scalar, L)\n    return [round(x, 3) for x in proj_v]", "test_cases": ["assert orthogonal_projection([3, 4], [1, 0]) == [3.0, 0.0]", "assert orthogonal_projection([1, 2, 3], [0, 0, 1]) == [0.0, 0.0, 3.0]", "assert orthogonal_projection([5, 6, 7], [2, 0, 0]) == [5.0, 0.0, 0.0]"]}
{"id": 67, "difficulty": "easy", "category": "Linear Algebra", "title": "Implement Compressed Column Sparse Matrix Format (CSC)", "description": "Task: Create a Compressed Column Sparse Matrix Representation\n\nYour task is to implement a function that converts a dense matrix into its Compressed Column Sparse (CSC) representation. The CSC format stores only non-zero elements of the matrix and is efficient for matrices with a high number of zero elements.\n\nWrite a function `compressed_col_sparse_matrix(dense_matrix)` that takes in a two-dimensional list `dense_matrix` and returns a tuple of three lists:\n\n- `values`: List of non-zero elements, stored in column-major order.\n- `row indices`: List of row indices corresponding to each value in the values array.\n- `column pointer`: List that indicates the starting index of each column in the values array.", "inputs": ["compressed_col_sparse_matrix(dense_matrix = [[0, 0, 3, 0], [1, 0, 0, 4], [0, 2, 0, 0]])"], "outputs": ["([1, 2, 3, 4], [1, 2, 0, 1], [0, 1, 2, 3, 4])"], "reasoning": ["The dense matrix is converted to CSC format with the values array containing non-zero elements, row indices array storing the corresponding row index, and column pointer array indicating the start of each column in the values array."], "import_code": "", "output_constrains": "", "entry_point": "compressed_col_sparse_matrix", "starter_code": "def compressed_col_sparse_matrix(dense_matrix):\n    \"\"\"\n    Convert a dense matrix into its Compressed Column Sparse (CSC) representation.\n\n    :param dense_matrix: List of lists representing the dense matrix\n    :return: Tuple of (values, row indices, column pointer)\n    \"\"\"", "reference_code": "def compressed_col_sparse_matrix(dense_matrix):\n    \"\"\"\n    Convert a dense matrix into its Compressed Column Sparse (CSC) representation.\n\n    :param dense_matrix: List of lists representing the dense matrix\n    :return: Tuple of (values, row indices, column pointer)\n    \"\"\"\n    vals = []\n    row_idx = []\n    col_ptr = [0]\n\n    rows, cols = len(dense_matrix), len(dense_matrix[0])\n\n    for i in range(cols):\n        for j in range(rows):\n            val = dense_matrix[j][i]\n            if val != 0:\n                vals.append(val)\n                row_idx.append(j)\n        col_ptr.append(len(vals))\n\n    return vals, row_idx, col_ptr", "test_cases": ["assert compressed_col_sparse_matrix([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == ([], [], [0, 0, 0, 0])", "assert compressed_col_sparse_matrix([[0, 0, 0], [1, 2, 0], [0, 3, 4]]) == ([1, 2, 3, 4], [1, 1, 2, 2], [0, 1, 3, 4])", "assert compressed_col_sparse_matrix([[0, 0, 3, 0, 0], [0, 4, 0, 0, 0], [5, 0, 0, 6, 0], [0, 0, 0, 0, 0], [0, 7, 0, 0, 8]]) == ([5, 4, 7, 3, 6, 8], [2, 1, 4, 0, 2, 4], [0, 1, 3, 4, 5, 6])"]}
{"id": 68, "difficulty": "medium", "category": "Linear Algebra", "title": "Find the Image of a Matrix Using Row Echelon Form", "description": "Task: Compute the Column Space of a Matrix\n\nIn this task, you are required to implement a function `matrix_image(A)` that calculates the column space of a given matrix `A`. The column space, also known as the image or span, consists of all linear combinations of the columns of `A`. To find this, you'll use concepts from linear algebra, focusing on identifying independent columns that span the matrix's image. **Your task**: Implement the function `matrix_image(A)` to return the basis vectors that span the column space of `A`. These vectors should be extracted from the original matrix and correspond to the independent columns.", "inputs": ["matrix_image(A = np.array([[1, 2, 3], [4, 5, 6],[7, 8, 9]]))"], "outputs": ["[[1, 2], [4, 5], [7, 8]]"], "reasoning": ["The column space of the matrix is spanned by the independent columns [1, 2], [4, 5], and [7, 8]. These columns form the basis vectors that represent the image of the matrix."], "import_code": "import numpy as np", "output_constrains": "The matrix representing basis vectors should be rounded to 8 decimal places and converted to a list using tolist() when returned.", "entry_point": "matrix_image", "starter_code": "def matrix_image(A):", "reference_code": "def rref(A):\n    # Convert to float for division operations\n    A = A.astype(np.float32)\n    n, m = A.shape\n\n    for i in range(n):\n        if A[i, i] == 0:\n            nonzero_current_row = np.nonzero(A[i:, i])[0] + i\n            if len(nonzero_current_row) == 0:\n                continue\n            A[[i, nonzero_current_row[0]]] = A[[nonzero_current_row[0], i]]\n\n        A[i] = A[i] / A[i, i]\n\n        for j in range(n):\n            if i != j:\n                A[j] -= A[i] * A[j, i]\n    return A\n\ndef find_pivot_columns(A):\n    n, m = A.shape\n    pivot_columns = []\n    for i in range(n):\n        nonzero = np.nonzero(A[i, :])[0]\n        if len(nonzero) != 0:\n            pivot_columns.append(nonzero[0])\n    return pivot_columns\n\ndef matrix_image(A):\n    # Find the RREF of the matrix\n    Arref = rref(A)\n    # Find the pivot columns\n    pivot_columns = find_pivot_columns(Arref)\n    # Extract the pivot columns from the original matrix\n    image_basis = A[:, pivot_columns]\n    return np.round(image_basis, 8).tolist()", "test_cases": ["assert matrix_image(np.array([[1, 0], [0, 1]])) == [[1, 0], [0, 1]]", "assert matrix_image(np.array([[1, 2], [2, 4]])) == [[1], [2]]", "assert matrix_image(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == [[1, 2], [4, 5], [7, 8]]", "assert matrix_image(np.array([[3, 9, 6], [1, 4, 7], [2, 5, 8]])) == [[3, 9, 6], [1, 4, 7], [2, 5, 8]]", "assert matrix_image(np.array([[3, 3, 3], [1, 1, 1], [2, 2, 2]])) == [[3], [1], [2]]"]}
{"id": 69, "difficulty": "easy", "category": "Machine Learning", "title": "Calculate R-squared for Regression Analysis", "description": "Task: Compute the R-squared Value in Regression Analysis\n\n- R-squared, also known as the coefficient of determination, is a measure that indicates how well the independent variables explain the variability of the dependent variable in a regression model.\n\n- **Your Task**: To implement the function `r_squared(y_true, y_pred)` that calculates the R-squared value, given arrays of true values `y_true` and predicted values `y_pred`.", "inputs": ["r_squared(y_true = np.array([1, 2, 3, 4, 5]), y_pred = np.array([1.1, 2.1, 2.9, 4.2, 4.8]))"], "outputs": ["0.989"], "reasoning": ["The R-squared value is calculated to be 0.989, indicating that the regression model explains 98.9% of the variance in the dependent variable."], "import_code": "import numpy as np", "output_constrains": "Your code should return the R-squared value rounded to three decimal places.", "entry_point": "r_squared", "starter_code": "def r_squared(y_true, y_pred):", "reference_code": "def r_squared(y_true, y_pred):\n    if np.array_equal(y_true, y_pred):\n        return 1.0\n\n    # Calculate mean of true values\n    y_mean = np.mean(y_true)\n\n    # Calculate Sum of Squared Residuals (SSR)\n    ssr = np.sum((y_true - y_pred) ** 2)\n\n    # Calculate Total Sum of Squares (SST)\n    sst = np.sum((y_true - y_mean) ** 2)\n\n    try:\n        # Calculate R-squared\n        r2 = 1 - (ssr / sst)\n        if np.isinf(r2):\n            return 0.0\n        return round(r2, 3)\n    except ZeroDivisionError:\n        return 0.0", "test_cases": ["assert r_squared(np.array([1, 2, 3, 4, 5]), np.array([1, 2, 3, 4, 5])) == 1.0", "assert r_squared(np.array([1, 2, 3, 4, 5]), np.array([1.1, 2.1, 2.9, 4.2, 4.8])) == 0.989", "assert r_squared(np.array([1, 2, 3, 4, 5]), np.array([2, 1, 4, 3, 5])) == 0.6", "assert r_squared(np.array([1, 2, 3, 4, 5]), np.array([3, 3, 3, 3, 3])) == 0.0", "assert r_squared(np.array([3, 3, 3, 3, 3]), np.array([1, 2, 3, 4, 5])) == 0.0", "assert r_squared(np.array([1, 2, 3, 4, 5]), np.array([5, 4, 3, 2, 1])) == -3.0", "assert r_squared(np.array([0, 0, 0, 0, 0]), np.array([0, 0, 0, 0, 0])) == 1.0", "assert r_squared(np.array([-2, -2, -2]), np.array([-2, -2, -2 + 1e-8])) == 0.0"]}
{"id": 70, "difficulty": "easy", "category": "Computer Vision", "title": "Calculate Image Brightness", "description": "Task: Image Brightness Calculator\n\nIn this task, you will implement a function `calculate_brightness(img)` that calculates the average brightness of a grayscale image. The image is represented as a 2D matrix, where each element represents a pixel value between 0 (black) and 255 (white).\n\nYour Task:\nImplement the function `calculate_brightness(img)` to:\n\n1. Return the average brightness of the image rounded to two decimal places.\n2. Handle edge cases:\n    - If the image matrix is empty.\n    - If the rows in the matrix have inconsistent lengths.\n    - If any pixel values are outside the valid range (0-255).\n\nFor any of these edge cases, the function should return `-1`.", "inputs": ["calculate_brightness(img = [[100, 200], [50, 150]])"], "outputs": ["125.0"], "reasoning": ["The average brightness is calculated as (100 + 200 + 50 + 150) / 4 = 125.0"], "import_code": "", "output_constrains": "", "entry_point": "calculate_brightness", "starter_code": "def calculate_brightness(img):", "reference_code": "def calculate_brightness(img):\n    # Check if image is empty or has no columns\n    if not img or not img[0]:\n        return -1\n\n    rows, cols = len(img), len(img[0])\n\n    # Check if all rows have same length and values are valid\n    for row in img:\n        if len(row) != cols:\n            return -1\n        for pixel in row:\n            if not 0 <= pixel <= 255:\n                return -1\n\n    # Calculate average brightness\n    total = sum(sum(row) for row in img)\n    return round(total / (rows * cols), 2)", "test_cases": ["assert calculate_brightness([]) == -1", "assert calculate_brightness([[100, 200], [150]]) == -1", "assert calculate_brightness([[100, 300]]) == -1", "assert calculate_brightness([[100, -1]]) == -1", "assert calculate_brightness([[128]]) == 128.0", "assert calculate_brightness([[100, 200], [50, 150]]) == 125.0"]}
{"id": 71, "difficulty": "easy", "category": "Machine Learning", "title": "Calculate Root Mean Square Error (RMSE)", "description": "Task: Compute Root Mean Square Error (RMSE)\n\nIn this task, you are required to implement a function `rmse(y_true, y_pred)` that calculates the Root Mean Square Error (RMSE) between the actual values and the predicted values. RMSE is a commonly used metric for evaluating the accuracy of regression models, providing insight into the standard deviation of residuals.\n\nYour Task:\nImplement the function `rmse(y_true, y_pred)` to:\n\n1. Calculate the RMSE between the arrays y_true and y_pred.\n2. Return the RMSE value rounded to three decimal places.\n3. Ensure the function handles edge cases such as:\n    - Mismatched array shapes.\n    - Empty arrays.\n    - Invalid input types.\nThe RMSE is defined as:\n\n\\[\nRMSE = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (y_{true,i} - y_{pred,i})^2}\n\\]\n\nWhere:\n- $n$ is the number of observations.\n- $y_{true,i}$ and $y_{pred,i}$ are the actual and predicted values for the $i$-th observation.", "inputs": ["rmse(y_true = np.array([3, -0.5, 2, 7]), y_pred = np.array([2.5, 0.0, 2, 8]))"], "outputs": ["0.612"], "reasoning": ["The RMSE is calculated as sqrt((0.5^2 + 0.5^2 + 0^2 + 1^2) / 4) = 0.612"], "import_code": "import numpy as np", "output_constrains": "", "entry_point": "rmse", "starter_code": "def rmse(y_true, y_pred):", "reference_code": "def rmse(y_true, y_pred):\n    if y_true.shape != y_pred.shape:\n        raise ValueError(\"Arrays must have the same shape\")\n    if y_true.size == 0:\n        raise ValueError(\"Arrays cannot be empty\")\n    return round(np.sqrt(np.mean((y_true - y_pred) ** 2)), 3)", "test_cases": ["assert rmse(np.array([3, -0.5, 2, 7]), np.array([2.5, 0.0, 2, 8])) == 0.612", "assert rmse(np.array([[0.5, 1], [-1, 1], [7, -6]]), np.array([[0, 2], [-1, 2], [8, -5]])) == 0.842", "assert rmse(np.array([[1, 2], [3, 4]]), np.array([[1, 2], [3, 4]])) == 0.0"]}
{"id": 72, "difficulty": "easy", "category": "Machine Learning", "title": "Calculate Jaccard Index for Binary Classification", "description": "Task: Implement the Jaccard Index\n\nYour task is to implement a function `jaccard_index(y_true, y_pred)` that calculates the Jaccard Index, a measure of similarity between two binary sets. The Jaccard Index is widely used in binary classification tasks to evaluate the overlap between predicted and true labels.\n\nYour Task:\nImplement the function `jaccard_index(y_true, y_pred)` to:\n\n1. Calculate the Jaccard Index between the arrays `y_true` and `y_pred`.\n2. Return the Jaccard Index as a float value.\n3. Ensure the function handles cases where:\n    - There is no overlap between `y_true` and `y_pred`.\n    - Both arrays contain only zeros (edge cases).\n\nThe Jaccard Index is defined as:\n\n\\[\nJaccard Index = \\frac{\\text{Number of elements in the intersection of } y_{\\text{true}} \\text{ and } y_{\\text{pred}} }{\\text{Number of elements in the union of } y_{\\text{true}} \\text{ and } y_{\\text{pred}}}\n\\]\n\nWhere:\n- $y_{\\text{true}}$ and $y_{\\text{pred}}$ are binary arrays of the same length, representing true and predicted labels.\n- The result ranges from 0 (no overlap) to 1 (perfect overlap).", "inputs": ["jaccard_index(y_true = np.array([1, 0, 1, 1, 0, 1]), y_pred = np.array([1, 0, 1, 0, 0, 1]))"], "outputs": ["0.75"], "reasoning": ["The Jaccard Index is calculated as 3 / 4 = 0.75, indicating a 75% overlap between the true and predicted labels."], "import_code": "import numpy as np", "output_constrains": "Your code should return the Jaccard Index rounded to three decimal places.", "entry_point": "jaccard_index", "starter_code": "def jaccard_index(y_true, y_pred):", "reference_code": "def jaccard_index(y_true, y_pred):\n    intersection = np.sum((y_true == 1) & (y_pred == 1))\n    union = np.sum((y_true == 1) | (y_pred == 1))\n    result = intersection / union\n    if np.isnan(result):\n        return 0.0\n    return round(result, 3)", "test_cases": ["assert jaccard_index(np.array([1, 0, 1, 1, 0, 1]), np.array([1, 0, 1, 1, 0, 1])) == 1.0", "assert jaccard_index(np.array([1, 0, 1, 1, 0, 0]), np.array([0, 1, 0, 0, 1, 1])) == 0.0", "assert jaccard_index(np.array([1, 0, 1, 1, 0, 1]), np.array([1, 0, 1, 0, 0, 0])) == 0.5", "assert jaccard_index(np.array([1, 0, 1, 1, 0, 1]), np.array([0, 1, 0, 1, 1, 0])) == 0.167", "assert jaccard_index(np.array([1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 1, 1, 0])) == 0.333", "assert jaccard_index(np.array([1, 1, 1, 0, 1, 1]), np.array([1, 0, 0, 0, 0, 0])) == 0.2"]}
{"id": 73, "difficulty": "easy", "category": "Machine Learning", "title": "Calculate Dice Score for Classification", "description": "Task: Compute the Dice Score\n\nYour task is to implement a function `dice_score(y_true, y_pred)` that calculates the Dice Score, also known as the S\u00c3\u00b8rensen-Dice coefficient or F1-score, for binary classification. The Dice Score is used to measure the similarity between two sets and is particularly useful in tasks like image segmentation and binary classification.\n\nYour Task:\nImplement the function `dice_score(y_true, y_pred)` to:\n\n1. Calculate the Dice Score between the arrays `y_true` and `y_pred`.\n2. Return the Dice Score as a float value rounded to 3 decimal places.\n3. Handle edge cases appropriately, such as when there are no true or predicted positives.\n\nThe Dice Score is defined as:\n\\[\nDice Score = \\frac{2 \\times (\\text{Number of elements in the intersection of } y_{\\text{true}} \\text{ and } y_{\\text{pred}})}{\\text{Number of elements in } y_{\\text{true}} + \\text{Number of elements in } y_{\\text{pred}}}\n\\]\n\nWhere:\n- $y_{\\text{true}}$ and $y_{\\text{pred}}$ are binary arrays of the same length, representing true and predicted labels.\n- The result ranges from 0 (no overlap) to 1 (perfect overlap).", "inputs": ["dice_score(y_true = np.array([1, 1, 0, 1, 0, 1]), y_pred = np.array([1, 1, 0, 0, 0, 1]))"], "outputs": ["0.857"], "reasoning": ["The Dice Score is calculated as (2 * 3) / (2 * 3 + 0 + 1) = 0.857, indicating an 85.7% overlap between the true and predicted labels."], "import_code": "import numpy as np", "output_constrains": "", "entry_point": "dice_score", "starter_code": "def dice_score(y_true, y_pred):", "reference_code": "def dice_score(y_true, y_pred):\n    intersection = np.logical_and(y_true, y_pred).sum()\n    true_sum = y_true.sum()\n    pred_sum = y_pred.sum()\n\n    # Handle edge cases\n    if true_sum == 0 or pred_sum == 0:\n        return 0.0\n\n    dice = (2.0 * intersection) / (true_sum + pred_sum)\n    return round(float(dice), 3)", "test_cases": ["assert dice_score(np.array([1, 1, 0, 0]), np.array([1, 1, 0, 0])) == 1.0", "assert dice_score(np.array([1, 1, 0, 0]), np.array([0, 0, 1, 1])) == 0.0", "assert dice_score(np.array([1, 1, 0, 0]), np.array([1, 0, 0, 0])) == 0.667", "assert dice_score(np.array([0, 0, 0, 0]), np.array([0, 0, 0, 0])) == 0.0", "assert dice_score(np.array([1, 1, 1, 1]), np.array([1, 1, 1, 1])) == 1.0", "assert dice_score(np.array([0, 0, 0, 0]), np.array([1, 1, 1, 1])) == 0.0", "assert dice_score(np.array([1]), np.array([1])) == 1.0", "assert dice_score(np.array([True, True, False, False]), np.array([1, 1, 0, 0])) == 1.0"]}
{"id": 74, "difficulty": "medium", "category": "Linear Algebra", "title": "Create Composite Hypervector for a Dataset Row", "description": "Task: Generate a Composite Hypervector Using Hyperdimensional Computing\n\nYour task is to implement the function `create_row_hv(row, dim, random_seeds)` to generate a composite hypervector for a given dataset row using Hyperdimensional Computing (HDC). Each feature in the row is represented by binding hypervectors for the feature name and its value. The hypervectors for the values are created using the same feature seed provided in the `random_seeds` dictionary to ensure reproducibility. All feature hypervectors are then bundled to create a composite hypervector for the row.\n\nInput:\n- `row`: A dictionary representing a dataset row, where keys are feature names and values are their corresponding values.\n- `dim`: The dimensionality of the hypervectors.\n- `random_seeds`: A dictionary where keys are feature names and values are seeds to ensure reproducibility of hypervectors.\nOutput:\n- A composite hypervector representing the entire row.", "inputs": ["create_row_hv(row = {\"FeatureA\": \"value1\", \"FeatureB\": \"value2\"}, dim = 5, random_seeds = {\"FeatureA\": 42, \"FeatureB\": 7})"], "outputs": ["[ 1, -1,  1,  1,  1]"], "reasoning": ["The composite hypervector is created by binding hypervectors for each feature and bundling them together."], "import_code": "import numpy as np", "output_constrains": "The composite hypervector should be converted to a list using tolist() when returned.", "entry_point": "create_row_hv", "starter_code": "def create_row_hv(row, dim, random_seeds):", "reference_code": "def create_hv(dim):\n    return np.random.choice([-1, 1], dim)\n\ndef create_col_hvs(dim, seed):\n    np.random.seed(seed)\n    return create_hv(dim), create_hv(dim)\n\ndef bind(hv1, hv2):\n    return hv1 * hv2\n\ndef bundle(hvs, dim):\n    bundled = np.sum(list(hvs.values()), axis=0)\n    return sign(bundled)\n\ndef sign(vector, threshold=0.01):\n    return np.array([1 if v >= 0 else -1 for v in vector])\n\ndef create_row_hv(row, dim, random_seeds):\n    row_hvs = {col: bind(*create_col_hvs(dim, random_seeds[col])) for col in row.keys()}\n    return bundle(row_hvs, dim).tolist()", "test_cases": ["assert create_row_hv({\"FeatureA\": \"value1\", \"FeatureB\": \"value2\"}, 5, {\"FeatureA\": 42, \"FeatureB\": 7}) == [1, -1, 1, 1, 1]", "assert create_row_hv({\"FeatureA\": \"value1\", \"FeatureB\": \"value2\"}, 10, {\"FeatureA\": 42, \"FeatureB\": 7}) == [1, -1, 1, 1, -1, -1, -1, -1, -1, -1]", "assert create_row_hv({\"FeatureA\": \"value1\", \"FeatureB\": \"value2\"}, 15, {\"FeatureA\": 42, \"FeatureB\": 7}) == [1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, 1, -1, -1, 1]"]}
{"id": 75, "difficulty": "easy", "category": "Machine Learning", "title": "Generate a Confusion Matrix for Binary Classification", "description": "Task: Generate a Confusion Matrix\n\nYour task is to implement the function `confusion_matrix(data)` that generates a confusion matrix for a binary classification problem. The confusion matrix provides a summary of the prediction results on a classification problem, allowing you to visualize how many data points were correctly or incorrectly labeled.\n\nInput:\n    - A list of lists, where each inner list represents a pair\n    - `[y_true, y_pred]` for one observation. `y_true` is the actual label, and `y_pred` is the predicted label.\nOutput:\n    - A 2x2 confusion matrix represented as a list of lists.", "inputs": ["confusion_matrix(data = [[1, 1], [1, 0], [0, 1], [0, 0], [0, 1]])"], "outputs": ["[[1, 1], [2, 1]]"], "reasoning": ["The confusion matrix shows the counts of true positives, false negatives, false positives, and true negatives."], "import_code": "from collections import Counter", "output_constrains": "", "entry_point": "confusion_matrix", "starter_code": "def confusion_matrix(data):", "reference_code": "def confusion_matrix(data):\n    # Count all occurrences\n    counts = Counter(tuple(pair) for pair in data)\n    # Get metrics\n    TP, FN, FP, TN = counts[(1, 1)], counts[(1, 0)], counts[(0, 1)], counts[(0, 0)]\n    # Define matrix and return\n    confusion_matrix = [[TP, FN], [FP, TN]]\n    return confusion_matrix", "test_cases": ["assert confusion_matrix([[1, 1], [1, 0], [0, 1], [0, 0], [0, 1]]) == [[1, 1], [2, 1]]", "assert confusion_matrix([[0, 1], [1, 0], [1, 1], [0, 1], [0, 0], [1, 0], [0, 1], [1, 1], [0, 0], [1, 0], [1, 1], [0, 0], [1, 0], [0, 1], [1, 1], [1, 1], [1, 0]]) == [[5, 5], [4, 3]]", "assert confusion_matrix([[0, 1], [0, 1], [0, 0], [0, 1], [0, 0], [0, 1], [0, 1], [0, 0], [1, 0], [0, 1], [1, 0], [0, 0], [0, 1], [0, 1], [0, 1], [1, 0]]) == [[0, 3], [9, 4]]"]}
{"id": 76, "difficulty": "easy", "category": "Linear Algebra", "title": "Calculate Cosine Similarity Between Vectors", "description": "Task: Implement Cosine Similarity\n\nIn this task, you need to implement a function `cosine_similarity(v1, v2)` that calculates the cosine similarity between two vectors. Cosine similarity measures the cosine of the angle between two vectors, indicating their directional similarity.\n\nInput:\n- `v1` and `v2`: Numpy arrays representing the input vectors.\nOutput:\n- A float representing the cosine similarity, rounded to three decimal places.\nConstraints:\n- Both input vectors must have the same shape.\n- Input vectors cannot be empty or have zero magnitude.", "inputs": ["cosine_similarity(v1 = np.array([1, 2, 3]), v2 = np.array([2, 4, 6]))"], "outputs": ["1.0"], "reasoning": ["The cosine similarity between v1 and v2 is 1.0, indicating perfect similarity."], "import_code": "import numpy as np", "output_constrains": "", "entry_point": "cosine_similarity", "starter_code": "def cosine_similarity(v1, v2):", "reference_code": "def cosine_similarity(v1, v2):\n    if v1.shape != v2.shape:\n        raise ValueError(\"Arrays must have the same shape\")\n\n    if v1.size == 0:\n        raise ValueError(\"Arrays cannot be empty\")\n\n    # Flatten arrays in case of 2D\n    v1_flat = v1.flatten()\n    v2_flat = v2.flatten()\n\n    dot_product = np.dot(v1_flat, v2_flat)\n    magnitude1 = np.sqrt(np.sum(v1_flat**2))\n    magnitude2 = np.sqrt(np.sum(v2_flat**2))\n\n    if magnitude1 == 0 or magnitude2 == 0:\n        raise ValueError(\"Vectors cannot have zero magnitude\")\n\n    return round(dot_product / (magnitude1 * magnitude2), 3)", "test_cases": ["assert cosine_similarity(np.array([1, 2, 3]), np.array([2, 4, 6])) == 1.0", "assert cosine_similarity(np.array([1, 2, 3]), np.array([-1, -2, -3])) == -1.0", "assert cosine_similarity(np.array([1, 0, 7]), np.array([0, 1, 3])) == 0.939", "assert cosine_similarity(np.array([1, 0]), np.array([0, 1])) == 0.0"]}
{"id": 77, "difficulty": "medium", "category": "Machine Learning", "title": "Calculate Performance Metrics for a Classification Model", "description": "Task: Implement Performance Metrics Calculation\n\nIn this task, you are required to implement a function `performance_metrics(actual, predicted)` that computes various performance metrics for a binary classification problem. These metrics include:\n\n- Confusion Matrix\n- Accuracy\n- F1 Score\n- Specificity\n- Negative Predictive Value\n\nThe function should take in two lists:\n\n- `actual`: The actual class labels (1 for positive, 0 for negative).\n- `predicted`: The predicted class labels from the model.\n\n**Output**\nThe function should return a tuple containing:\n\n- `confusion_matrix`: A 2x2 matrix.\n- `accuracy`: A float representing the accuracy of the model.\n- `f1_score`: A float representing the F1 score of the model.\n- `specificity`: A float representing the specificity of the model.\n- `negative_predictive_value`: A float representing the negative predictive value.\n\nConstraints\n- All elements in the `actual` and `predicted` lists must be either 0 or 1.\n- Both lists must have the same length.", "inputs": ["performance_metrics(actual = [1, 0, 1, 0, 1], predicted = [1, 0, 0, 1, 1])"], "outputs": ["([[2, 1], [1, 1]], 0.6, 0.667, 0.5, 0.5)"], "reasoning": ["The function calculates the confusion matrix, accuracy, F1 score, specificity, and negative predictive value based on the input labels. The resulting values are rounded to three decimal places as required."], "import_code": "from collections import Counter", "output_constrains": "When your code return `accuracy`, `f1_score`, `specificity`, and `negative_predictive_value`, their values should be rounded to three decimal places.", "entry_point": "performance_metrics", "starter_code": "def performance_metrics(actual: list[int], predicted: list[int]) -> tuple:", "reference_code": "def performance_metrics(actual: list[int], predicted: list[int]) -> tuple:\n    data = list(zip(actual, predicted))\n    counts = Counter(tuple(pair) for pair in data)\n    TP, FN, FP, TN = counts[(1, 1)], counts[(1, 0)], counts[(0, 1)], counts[(0, 0)]\n    confusion_matrix = [[TP, FN], [FP, TN]]\n    accuracy = (TP + TN) / (TP + TN + FP + FN)\n    precision = TP / (TP + FP)\n    recall = TP / (TP + FN)\n    f1 = 2 * precision * recall / (precision + recall)\n    negativePredictive = TN / (TN + FN)\n    specificity = TN / (TN + FP)\n    return confusion_matrix, round(accuracy, 3), round(f1, 3), round(specificity, 3), round(negativePredictive, 3)", "test_cases": ["assert performance_metrics([1, 0, 1, 0, 1], [1, 0, 0, 1, 1]) == ([[2, 1], [1, 1]], 0.6, 0.667, 0.5, 0.5)", "assert performance_metrics([1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1], [0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0]) == ([[6, 4], [2, 7]], 0.684, 0.667, 0.778, 0.636)", "assert performance_metrics([0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1]) == ([[4, 4], [5, 2]], 0.4, 0.471, 0.286, 0.333)", "assert performance_metrics([1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1], [0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0]) == ([[4, 5], [4, 2]], 0.4, 0.471, 0.333, 0.286)"]}
{"id": 78, "difficulty": "easy", "category": "Statistics", "title": "Descriptive Statistics Calculator", "description": "Write a Python function to calculate various descriptive statistics metrics for a given dataset. The function should take a list or NumPy array of numerical values and return a dictionary containing mean, median, mode, variance, standard deviation, percentiles (25th, 50th, 75th), and interquartile range (IQR).", "inputs": ["descriptive_statistics(data = [10, 20, 30, 40, 50])"], "outputs": ["{'mean': 30.0, 'median': 30.0, 'mode': 10, 'variance': 200.0, 'standard_deviation': 14.1421, '25th_percentile': 20.0, '50th_percentile': 30.0, '75th_percentile': 40.0, 'interquartile_range': 20.0}"], "reasoning": ["The dataset is processed to calculate all descriptive statistics. The mean is the average value, the median is the central value, the mode is the most frequent value, and variance and standard deviation measure the spread of data. Percentiles and IQR describe data distribution."], "import_code": "import numpy as np", "output_constrains": "The output should be a dictionary with the following keys:\n- 'mean'\n- 'median'\n- 'mode'\n- 'variance'\n- 'standard_deviation'\n- '25th_percentile'\n- '50th_percentile'\n- '75th_percentile'\n- 'interquartile_range'\nExcept for statistics that draw from the data, all other values should be rounded to four decimal places.", "entry_point": "descriptive_statistics", "starter_code": "def descriptive_statistics(data):", "reference_code": "def descriptive_statistics(data):\n    \"\"\"\n    Calculate various descriptive statistics metrics for a given dataset.\n    :param data: List or numpy array of numerical values\n    :return: Dictionary containing mean, median, mode, variance, standard deviation,\n             percentiles (25th, 50th, 75th), and interquartile range (IQR)\n    \"\"\"\n    # Ensure data is a numpy array for easier calculations\n    data = np.array(data)\n\n    # Mean\n    mean = np.mean(data)\n\n    # Median\n    median = np.median(data)\n\n    # Mode\n    unique, counts = np.unique(data, return_counts=True)\n    mode = unique[np.argmax(counts)] if len(data) > 0 else None\n\n    # Variance\n    variance = np.var(data)\n\n    # Standard Deviation\n    std_dev = np.sqrt(variance)\n\n    # Percentiles (25th, 50th, 75th)\n    percentiles = np.percentile(data, [25, 50, 75])\n\n    # Interquartile Range (IQR)\n    iqr = percentiles[2] - percentiles[0]\n\n    # Compile results into a dictionary\n    stats_dict = {\n        \"mean\": mean,\n        \"median\": median,\n        \"mode\": mode,\n        \"variance\": np.round(variance,4),\n        \"standard_deviation\": np.round(std_dev,4),\n        \"25th_percentile\": percentiles[0],\n        \"50th_percentile\": percentiles[1],\n        \"75th_percentile\": percentiles[2],\n        \"interquartile_range\": iqr\n    }\n    return stats_dict", "test_cases": ["assert descriptive_statistics([10, 20, 30, 40, 50]) == {'mean': 30.0, 'median': 30.0, 'mode': 10, 'variance': 200.0, 'standard_deviation': 14.1421, '25th_percentile': 20.0, '50th_percentile': 30.0, '75th_percentile': 40.0, 'interquartile_range': 20.0}", "assert descriptive_statistics([1, 2, 2, 3, 4, 4, 4, 5]) == {'mean': 3.125, 'median': 3.5, 'mode': 4, 'variance': 1.6094, 'standard_deviation': 1.2686, '25th_percentile': 2.0, '50th_percentile': 3.5, '75th_percentile': 4.0, 'interquartile_range': 2.0}", "assert descriptive_statistics([100]) == {'mean': 100.0, 'median': 100.0, 'mode': 100, 'variance': 0.0, 'standard_deviation': 0.0, '25th_percentile': 100.0, '50th_percentile': 100.0, '75th_percentile': 100.0, 'interquartile_range': 0.0}"]}
{"id": 79, "difficulty": "medium", "category": "Probability", "title": "Binomial Distribution Probability", "description": "Write a Python function to calculate the probability of achieving exactly k successes in n independent Bernoulli trials, each with probability p of success, using the Binomial distribution formula.", "inputs": ["binomial_probability(n = 6, k = 2, p = 0.5)"], "outputs": ["0.23438"], "reasoning": ["The function calculates the Binomial probability, the intermediate steps include calculating the binomial coefficient, raising p and (1-p) to the appropriate powers, and multiplying the results."], "import_code": "import math", "output_constrains": "Your code should return the probability rounded to five decimal places.", "entry_point": "binomial_probability", "starter_code": "def binomial_probability(n, k, p):\n    \"\"\"\n    Calculate the probability of achieving exactly k successes in n independent Bernoulli trials,\n    each with probability p of success, using the Binomial distribution formula.\n    :param n: Total number of trials\n    :param k: Number of successes\n    :param p: Probability of success on each trial\n    :return: Probability of k successes in n trials\n    \"\"\"", "reference_code": "def binomial_probability(n, k, p):\n    \"\"\"\n    Calculate the probability of achieving exactly k successes in n independent Bernoulli trials,\n    each with probability p of success, using the Binomial distribution formula.\n    :param n: Total number of trials\n    :param k: Number of successes\n    :param p: Probability of success on each trial\n    :return: Probability of k successes in n trials\n    \"\"\"\n    # Calculate binomial coefficient (n choose k)\n    binomial_coeff = math.comb(n, k)\n    # Calculate the probability using the binomial formula\n    probability = binomial_coeff * (p ** k) * ((1 - p) ** (n - k))\n    # Return the probability, rounded to five decimal places\n    return round(probability, 5)", "test_cases": ["assert binomial_probability(6, 2, 0.5) == 0.23438", "assert binomial_probability(6, 4, 0.7) == 0.32414", "assert binomial_probability(3, 3, 0.9) == 0.729", "assert binomial_probability(5, 0, 0.3) == 0.16807", "assert binomial_probability(7, 2, 0.1) == 0.124", "assert binomial_probability(100, 2, 0.1) == 0.00162", "assert binomial_probability(2, 2, 0.1) == 0.01"]}
{"id": 80, "difficulty": "medium", "category": "Probability", "title": "Normal Distribution PDF Calculator", "description": "Write a Python function to calculate the probability density function (PDF) of the normal distribution for a given value, mean, and standard deviation. The function should use the mathematical formula of the normal distribution to return the PDF value rounded to 5 decimal places.", "inputs": ["normal_pdf(x = 16, mean = 15, std_dev = 2.04)"], "outputs": ["0.17342"], "reasoning": ["The function computes the PDF using x = 16, mean = 15, and std_dev = 2.04."], "import_code": "import math", "output_constrains": "", "entry_point": "normal_pdf", "starter_code": "def normal_pdf(x, mean, std_dev):\n    \"\"\"\n    Calculate the probability density function (PDF) of the normal distribution.\n    :param x: The value at which the PDF is evaluated.\n    :param mean: The mean (\u03bc) of the distribution.\n    :param std_dev: The standard deviation (\u03c3) of the distribution.\n    \"\"\"", "reference_code": "def normal_pdf(x, mean, std_dev):\n    \"\"\"\n    Calculate the probability density function (PDF) of the normal distribution.\n    :param x: The value at which the PDF is evaluated.\n    :param mean: The mean (\u03bc) of the distribution.\n    :param std_dev: The standard deviation (\u03c3) of the distribution.\n    \"\"\"\n    coefficient = 1 / (math.sqrt(2 * math.pi) * std_dev)\n    exponent = math.exp(-((x - mean) ** 2) / (2 * std_dev ** 2))\n    return round(coefficient * exponent, 5)", "test_cases": ["assert normal_pdf(0, 0, 1) == 0.39894", "assert normal_pdf(16, 15, 2.04) == 0.17342", "assert normal_pdf(1, 0, 0.5) == 0.10798"]}
{"id": 81, "difficulty": "easy", "category": "Probability", "title": "Poisson Distribution Probability Calculator", "description": "Write a Python function to calculate the probability of observing exactly k events in a fixed interval using the Poisson distribution formula. The function should take k (number of events) and lam (mean rate of occurrences) as inputs and return the probability rounded to 5 decimal places.", "inputs": ["poisson_probability(k = 3, lam = 5)"], "outputs": ["0.14037"], "reasoning": ["The function calculates the probability for a given number of events occurring in a fixed interval, based on the mean rate of occurrences."], "import_code": "import math", "output_constrains": "", "entry_point": "poisson_probability", "starter_code": "def poisson_probability(k, lam):\n    \"\"\"\n    Calculate the probability of observing exactly k events in a fixed interval,\n    given the mean rate of events lam, using the Poisson distribution formula.\n    :param k: Number of events (non-negative integer)\n    :param lam: The average rate (mean) of occurrences in a fixed interval\n    \"\"\"", "reference_code": "def poisson_probability(k, lam):\n    \"\"\"\n    Calculate the probability of observing exactly k events in a fixed interval,\n    given the mean rate of events lam, using the Poisson distribution formula.\n    :param k: Number of events (non-negative integer)\n    :param lam: The average rate (mean) of occurrences in a fixed interval\n    \"\"\"\n    # Calculate the Poisson probability using the formula\n    probability = (lam ** k) * math.exp(-lam) / math.factorial(k)\n    # Return the probability, rounded to five decimal places\n    return round(probability, 5)", "test_cases": ["assert poisson_probability(3, 5) == 0.14037", "assert poisson_probability(0, 5) == 0.00674", "assert poisson_probability(2, 10) == 0.00227", "assert poisson_probability(1, 1) == 0.36788", "assert poisson_probability(20, 20) == 0.08884"]}
{"id": 82, "difficulty": "easy", "category": "Computer Vision", "title": "Grayscale Image Contrast Calculator", "description": "Write a Python function to calculate the contrast of a grayscale image using the difference between the maximum and minimum pixel values.", "inputs": ["calculate_contrast(img = np.array([[0, 50], [200, 255]]))"], "outputs": ["255"], "reasoning": ["The function calculates contrast by finding the difference between the maximum (255) and minimum (0) pixel values in the image, resulting in a contrast of 255."], "import_code": "import numpy as np", "output_constrains": "", "entry_point": "calculate_contrast", "starter_code": "def calculate_contrast(img):\n    \"\"\"\n    Calculate the contrast of a grayscale image.\n    Args:\n        img (numpy.ndarray): 2D array representing a grayscale image with pixel values between 0 and 255.\n    \"\"\"", "reference_code": "def calculate_contrast(img):\n    \"\"\"\n    Calculate the contrast of a grayscale image.\n    Args:\n        img (numpy.ndarray): 2D array representing a grayscale image with pixel values between 0 and 255.\n    \"\"\"\n    # Find the maximum and minimum pixel values\n    max_pixel = np.max(img)\n    min_pixel = np.min(img)\n\n    # Calculate contrast\n    contrast = max_pixel - min_pixel\n\n    return round(float(contrast), 3)", "test_cases": ["assert calculate_contrast(np.array([[0, 50], [200, 255]])) == 255", "assert calculate_contrast(np.array([[128, 128], [128, 128]])) == 0", "assert calculate_contrast(np.zeros((10, 10), dtype=np.uint8)) == 0", "assert calculate_contrast(np.ones((10, 10), dtype=np.uint8) * 255) == 0", "assert calculate_contrast(np.array([[10, 20, 30], [40, 50, 60]])) == 50"]}
{"id": 83, "difficulty": "easy", "category": "Linear Algebra", "title": "Dot Product Calculator", "description": "Write a Python function to calculate the dot product of two vectors. The function should take two 1D NumPy arrays as input and return the dot product as a single number.", "inputs": ["calculate_dot_product(vec1 = np.array([1, 2, 3]), vec2 = np.array([4, 5, 6]))"], "outputs": ["32"], "reasoning": ["The function calculates the dot product by multiplying corresponding elements of the two vectors and summing the results. For vec1 = [1, 2, 3] and vec2 = [4, 5, 6], the result is (1 * 4) + (2 * 5) + (3 * 6) = 32."], "import_code": "import numpy as np", "output_constrains": "", "entry_point": "calculate_dot_product", "starter_code": "def calculate_dot_product(vec1, vec2):\n    \"\"\"\n    Calculate the dot product of two vectors.\n    Args:\n        vec1 (numpy.ndarray): 1D array representing the first vector.\n        vec2 (numpy.ndarray): 1D array representing the second vector.\n    \"\"\"", "reference_code": "def calculate_dot_product(vec1, vec2):\n    \"\"\"\n    Calculate the dot product of two vectors.\n    Args:\n        vec1 (numpy.ndarray): 1D array representing the first vector.\n        vec2 (numpy.ndarray): 1D array representing the second vector.\n    \"\"\"\n    return np.dot(vec1, vec2)", "test_cases": ["assert calculate_dot_product(np.array([1, 2, 3]), np.array([4, 5, 6])) == 32", "assert calculate_dot_product(np.array([-1, 2, 3]), np.array([4, -5, 6])) == 4", "assert calculate_dot_product(np.array([1, 0]), np.array([0, 1])) == 0", "assert calculate_dot_product(np.array([0, 0, 0]), np.array([0, 0, 0])) == 0", "assert calculate_dot_product(np.array([7]), np.array([3])) == 21"]}
{"id": 84, "difficulty": "easy", "category": "Linear Algebra", "title": "Phi Transformation for Polynomial Features", "description": "Write a Python function to perform a Phi Transformation that maps input features into a higher-dimensional space by generating polynomial features. The transformation allows models like linear regression to fit nonlinear data by introducing new feature dimensions that represent polynomial combinations of the original input features. The function should take a list of numerical data and a degree as inputs, and return a nested list where each inner list represents the transformed features of a data point. If the degree is less than 0, the function should return an empty list.", "inputs": ["phi_transform(data = [1.0, 2.0], degree = 2)"], "outputs": ["[[1.0, 1.0, 1.0], [1.0, 2.0, 4.0]]"], "reasoning": ["The Phi Transformation generates polynomial features for each data point up to the specified degree. For data = [1.0, 2.0] and degree = 2, the transformation creates a nested list where each row contains powers of the data point from 0 to 2."], "import_code": "import numpy as np", "output_constrains": "The function should output a list of lists, where each inner list contains the polynomial features of the corresponding data point. The output should be rounded to 8 decimal places.", "entry_point": "phi_transform", "starter_code": "def phi_transform(data: list[float], degree: int):\n    \"\"\"\n    Perform a Phi Transformation to map input features into a higher-dimensional space by generating polynomial features.\n\n    Args:\n        data (list[float]): A list of numerical values to transform.\n        degree (int): The degree of the polynomial expansion.\n    \"\"\"", "reference_code": "def phi_transform(data: list[float], degree: int):\n    \"\"\"\n    Perform a Phi Transformation to map input features into a higher-dimensional space by generating polynomial features.\n\n    Args:\n        data (list[float]): A list of numerical values to transform.\n        degree (int): The degree of the polynomial expansion.\n    \"\"\"\n    if degree < 0 or not data:\n        return []\n    return np.round(np.array([[x ** i for i in range(degree + 1)] for x in data]), 8).tolist()", "test_cases": ["assert phi_transform([], 2) == []", "assert phi_transform([1.0, 2.0], -1) == []", "assert phi_transform([1.0, 2.0], 2) == [[1.0, 1.0, 1.0], [1.0, 2.0, 4.0]]", "assert phi_transform([1.0, 3.0], 3) == [[1.0, 1.0, 1.0, 1.0], [1.0, 3.0, 9.0, 27.0]]", "assert phi_transform([2.0], 4) == [[1.0, 2.0, 4.0, 8.0, 16.0]]"]}
{"id": 85, "difficulty": "hard", "category": "Deep Learning", "title": "Positional Encoding Calculator", "description": "Write a Python function to implement the Positional Encoding layer for Transformers. The function should calculate positional encodings for a sequence length (`position`) and model dimensionality (`d_model`) using sine and cosine functions as specified in the Transformer architecture. The function should return -1 if `position` is 0, or if `d_model` is less than or equal to 0.", "inputs": ["pos_encoding(position = 2, d_model = 8)"], "outputs": ["[[0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0], [0.84130859375, 0.54052734375, 0.099853515625, 0.9951171875, 0.01000213623046875, 1.0, 0.0010004043579101562, 1.0]]"], "reasoning": ["The function computes the positional encoding by calculating sine values for even indices and cosine values for odd indices, ensuring that the encoding provides the required positional information."], "import_code": "import numpy as np", "output_constrains": "The position encoding array should be of dtype np.float16 and converted to a list using tolist() when returned.", "entry_point": "pos_encoding", "starter_code": "def pos_encoding(position: int, d_model: int):", "reference_code": "def pos_encoding(position: int, d_model: int):\n    if position == 0 or d_model <= 0:\n        return -1\n    # Create position and dimension indices\n    pos = np.arange(position).reshape(position, 1)\n    ind = np.arange(d_model).reshape(1, d_model)\n    # Compute the angles\n    angle_rads = pos / np.power(10000, (2 * (ind // 2)) / d_model)\n    # Apply sine to even indices, cosine to odd indices\n    angle_rads[:, 0::2] = np.sin(angle_rads[:, 0::2])  # Even indices (0, 2, 4...)\n    angle_rads[:, 1::2] = np.cos(angle_rads[:, 1::2])  # Odd indices (1, 3, 5...)\n    # Convert to float16 as required\n    return np.round(angle_rads, 4).tolist()", "test_cases": ["assert pos_encoding(2, 8) == [[0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0], [0.8415, 0.5403, 0.0998, 0.995, 0.01, 1.0, 0.001, 1.0]]", "assert pos_encoding(5, 16) == [[0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0], [0.8415, 0.5403, 0.311, 0.9504, 0.0998, 0.995, 0.0316, 0.9995, 0.01, 1.0, 0.0032, 1.0, 0.001, 1.0, 0.0003, 1.0], [0.9093, -0.4161, 0.5911, 0.8066, 0.1987, 0.9801, 0.0632, 0.998, 0.02, 0.9998, 0.0063, 1.0, 0.002, 1.0, 0.0006, 1.0], [0.1411, -0.99, 0.8126, 0.5828, 0.2955, 0.9553, 0.0947, 0.9955, 0.03, 0.9996, 0.0095, 1.0, 0.003, 1.0, 0.0009, 1.0], [-0.7568, -0.6536, 0.9536, 0.3011, 0.3894, 0.9211, 0.1262, 0.992, 0.04, 0.9992, 0.0126, 0.9999, 0.004, 1.0, 0.0013, 1.0]]", "assert pos_encoding(0, 0) == -1", "assert pos_encoding(2, -1) == -1"]}
{"id": 86, "difficulty": "easy", "category": "Machine Learning", "title": "Detect Overfitting or Underfitting", "description": "Write a Python function to determine whether a machine learning model is overfitting, underfitting, or performing well based on training and test accuracy values. The function should take two inputs: `training_accuracy` and `test_accuracy`. It should return one of three values: 1 if Overfitting, -1 if Underfitting, or 0 if a Good fit. The rules for determination are as follows:\n\n- **Overfitting**: The training accuracy is significantly higher than the test accuracy (difference > 0.2).\n- **Underfitting**: Both training and test accuracy are below 0.7.\n- **Good fit**: Neither of the above conditions is true.", "inputs": ["model_fit_quality(training_accuracy = 0.95, test_accuracy = 0.65)"], "outputs": ["1"], "reasoning": ["The training accuracy is much higher than the test accuracy (difference = 0.30 > 0.2). This indicates that the model is overfitting to the training data and generalizes poorly to unseen data."], "import_code": "", "output_constrains": "", "entry_point": "model_fit_quality", "starter_code": "def model_fit_quality(training_accuracy, test_accuracy):\n    \"\"\"\n    Determine if the model is overfitting, underfitting, or a good fit based on training and test accuracy.\n    :param training_accuracy: float, training accuracy of the model (0 <= training_accuracy <= 1)\n    :param test_accuracy: float, test accuracy of the model (0 <= test_accuracy <= 1)\n    :return: int, one of '1', '-1', or '0'.\n    \"\"\"", "reference_code": "def model_fit_quality(training_accuracy, test_accuracy):\n    \"\"\"\n    Determine if the model is overfitting, underfitting, or a good fit based on training and test accuracy.\n    :param training_accuracy: float, training accuracy of the model (0 <= training_accuracy <= 1)\n    :param test_accuracy: float, test accuracy of the model (0 <= test_accuracy <= 1)\n    :return: int, one of '1', '-1', or '0'.\n    \"\"\"\n    if training_accuracy - test_accuracy > 0.2:\n        return 1\n    elif training_accuracy < 0.7 and test_accuracy < 0.7:\n        return -1\n    else:\n        return 0", "test_cases": ["assert model_fit_quality(0.95, 0.65) == 1", "assert model_fit_quality(0.6, 0.5) == -1", "assert model_fit_quality(0.85, 0.8) == 0", "assert model_fit_quality(0.5, 0.6) == -1", "assert model_fit_quality(0.75, 0.74) == 0"]}
{"id": 87, "difficulty": "medium", "category": "Deep Learning", "title": "Adam Optimizer", "description": "Implement the Adam optimizer update step function. Your function should take the current parameter value, gradient, and moving averages as inputs, and return the updated parameter value and new moving averages. The function should also handle scalar and array inputs and include bias correction for the moving averages.", "inputs": ["adam_optimizer(parameter = 1.0, grad = 0.1, m = 0.0, v = 0.0, t = 1)"], "outputs": ["(0.999, 0.01, 0.00001)"], "reasoning": ["The Adam optimizer computes updated values for the parameter, first moment (m), and second moment (v) using bias-corrected estimates of gradients. With input values parameter=1.0, grad=0.1, m=0.0, v=0.0, and t=1, the updated parameter becomes 0.999."], "import_code": "import numpy as np", "output_constrains": "The updated parameter, first moment (m), and second moment (v) should be rounded to 5 decimal places and converted to a list using tolist() when returned.", "entry_point": "adam_optimizer", "starter_code": "def adam_optimizer(parameter, grad, m, v, t, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-8):\n    \"\"\"\n    Update parameters using the Adam optimizer.\n    Adjusts the learning rate based on the moving averages of the gradient and squared gradient.\n    :param parameter: Current parameter value\n    :param grad: Current gradient\n    :param m: First moment estimate\n    :param v: Second moment estimate\n    :param t: Current timestep\n    :param learning_rate: Learning rate (default=0.001)\n    :param beta1: First moment decay rate (default=0.9)\n    :param beta2: Second moment decay rate (default=0.999)\n    :param epsilon: Small constant for numerical stability (default=1e-8)\n    :return: tuple: (updated_parameter, updated_m, updated_v)\n    \"\"\"", "reference_code": "def adam_optimizer(parameter, grad, m, v, t, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-8):\n    \"\"\"\n    Update parameters using the Adam optimizer.\n    Adjusts the learning rate based on the moving averages of the gradient and squared gradient.\n    :param parameter: Current parameter value\n    :param grad: Current gradient\n    :param m: First moment estimate\n    :param v: Second moment estimate\n    :param t: Current timestep\n    :param learning_rate: Learning rate (default=0.001)\n    :param beta1: First moment decay rate (default=0.9)\n    :param beta2: Second moment decay rate (default=0.999)\n    :param epsilon: Small constant for numerical stability (default=1e-8)\n    :return: tuple: (updated_parameter, updated_m, updated_v)\n    \"\"\"\n    # Update biased first moment estimate\n    m = beta1 * m + (1 - beta1) * grad\n\n    # Update biased second raw moment estimate\n    v = beta2 * v + (1 - beta2) * (grad**2)\n\n    # Compute bias-corrected first moment estimate\n    m_hat = m / (1 - beta1**t)\n\n    # Compute bias-corrected second raw moment estimate\n    v_hat = v / (1 - beta2**t)\n\n    # Update parameters\n    update = learning_rate * m_hat / (np.sqrt(v_hat) + epsilon)\n    parameter = parameter - update\n\n    return np.round(parameter,5).tolist(), np.round(m,5).tolist(), np.round(v,5).tolist()", "test_cases": ["assert adam_optimizer(1.0, 0.1, 0.0, 0.0, 1) == (0.999, 0.01, 0.00001)", "assert adam_optimizer(np.array([1.0, 2.0]), np.array([0.1, 0.2]), np.zeros(2), np.zeros(2), 1) == ([0.999, 1.999], [0.01, 0.02], [1.e-05, 4.e-05])", "assert adam_optimizer(np.array([1.0, 2.0]), np.array([0.1, 0.2]), np.zeros(2), np.zeros(2), 1, 0.01, 0.8, 0.99) == ([0.99, 1.99], [0.02, 0.04], [0.0001, 0.0004])"]}
{"id": 88, "difficulty": "hard", "category": "NLP", "title": "GPT-2 Text Generation", "description": "Implement a Simplified GPT-2-like Text Generation Function\n\nYou are tasked with implementing a simplified GPT-2-like text generation function in Python. This function will incorporate the following components of a minimal GPT-2 architecture:\n\n- **Token Embeddings**: Map input tokens to dense vector representations.\n- **Positional Embeddings**: Add positional information to token embeddings.\n- **Multi-head Attention**: Attend to various parts of the sequence.\n- **Feed-Forward Network**: Process attention outputs through a dense layer.\n- **Layer Normalization**: Stabilize the training process.\n\nThe function must take in the following parameters:\n\n1. Prompt: The initial text to guide the generation process.\n2. Number of Tokens to Generate: Specify how many tokens to output.\n\nYour function should output the generated text.\n\nAdditionally, utilize the helper function `load_encoder_hparams_and_params` to retrieve:\n\n- A dummy encoder.\n- Model hyperparameters.\n- Model parameters.\n\nBuild your text generation logic around these components. This exercise is designed to help you understand the core concepts behind GPT-2's autoregressive text generation.", "inputs": ["gen_text(prompt=\"hello\", n_tokens_to_generate=5)"], "outputs": ["\"world <UNK> <UNK> <UNK> <UNK>\""], "reasoning": ["The function encodes the input \"hello\" into tokens using the dummy encoder, then runs a simplified GPT-2 forward pass to generate 5 tokens. Finally, it decodes the generated tokens back into text."], "import_code": "import numpy as np\n\ndef load_encoder_hparams_and_params(model_size: str = \"124M\", models_dir: str = \"models\"):\n    class DummyBPE:\n        def __init__(self):\n            self.encoder_dict = {\"hello\": 1, \"world\": 2, \"<UNK>\": 0}\n\n        def encode(self, text: str):\n            tokens = text.strip().split()\n            return [self.encoder_dict.get(token, self.encoder_dict[\"<UNK>\"]) for token in tokens]\n\n        def decode(self, token_ids: list):\n            reversed_dict = {v: k for k, v in self.encoder_dict.items()}\n            return \" \".join([reversed_dict.get(tok_id, \"<UNK>\") for tok_id in token_ids])\n\n    hparams = {\n        \"n_ctx\": 1024,\n        \"n_head\": 12\n    }\n\n    params = {\n        \"wte\": np.random.rand(3, 10),\n        \"wpe\": np.random.rand(1024, 10),\n        \"blocks\": [],\n        \"ln_f\": {\n            \"g\": np.ones(10),\n            \"b\": np.zeros(10),\n        }\n    }\n\n    encoder = DummyBPE()\n    return encoder, hparams, params", "output_constrains": "", "entry_point": "gen_text", "starter_code": "def gen_text(prompt: str, n_tokens_to_generate: int = 40):\n    np.random.seed(42)  # Set the random seed for reproducibility", "reference_code": "def gelu(x):\n    return 0.5 * x * (1 + np.tanh(np.sqrt(2 / np.pi) * (x + 0.044715 * x**3)))\n\ndef softmax(x):\n    exp_x = np.exp(x - np.max(x, axis=-1, keepdims=True))\n    return exp_x / np.sum(exp_x, axis=-1, keepdims=True)\n\ndef layer_norm(x, g, b, eps=1e-5):\n    mean = np.mean(x, axis=-1, keepdims=True)\n    variance = np.var(x, axis=-1, keepdims=True)\n    return g * (x - mean) / np.sqrt(variance + eps) + b\n\ndef linear(x, w, b):\n    return x @ w + b\n\ndef ffn(x, c_fc, c_proj):\n    return linear(gelu(linear(x, **c_fc)), **c_proj)\n\ndef attention(q, k, v, mask):\n    return softmax(q @ k.T / np.sqrt(q.shape[-1]) + mask) @ v\n\ndef mha(x, c_attn, c_proj, n_head):\n    x = linear(x, **c_attn)\n    qkv_heads = list(map(lambda x: np.split(x, n_head, axis=-1), np.split(x, 3, axis=-1)))\n    causal_mask = (1 - np.tri(x.shape[0], dtype=x.dtype)) * -1e10\n    out_heads = [attention(q, k, v, causal_mask) for q, k, v in zip(*qkv_heads)]\n    x = linear(np.hstack(out_heads), **c_proj)\n    return x\n\ndef transformer_block(x, mlp, attn, ln_1, ln_2, n_head):\n    x = x + mha(layer_norm(x, **ln_1), **attn, n_head=n_head)\n    x = x + ffn(layer_norm(x, **ln_2), **mlp)\n    return x\n\ndef gpt2(inputs, wte, wpe, blocks, ln_f, n_head):\n    x = wte[inputs] + wpe[range(len(inputs))]\n    for block in blocks:\n        x = transformer_block(x, **block, n_head=n_head)\n    return layer_norm(x, **ln_f) @ wte.T\n\ndef generate(inputs, params, n_head, n_tokens_to_generate):\n    for _ in range(n_tokens_to_generate):\n        logits = gpt2(inputs, **params, n_head=n_head)\n        next_id = np.argmax(logits[-1])\n        inputs.append(int(next_id))\n    return inputs[len(inputs) - n_tokens_to_generate:]\n\ndef gen_text(prompt: str, n_tokens_to_generate: int = 40):\n    np.random.seed(42)  # Set the random seed for reproducibility\n    encoder, hparams, params = load_encoder_hparams_and_params()\n    input_ids = encoder.encode(prompt)\n    assert len(input_ids) + n_tokens_to_generate < hparams[\"n_ctx\"]\n    output_ids = generate(input_ids, params, hparams[\"n_head\"], n_tokens_to_generate)\n    output_text = encoder.decode(output_ids)\n    return output_text", "test_cases": ["assert gen_text(\"hello\", 5) == \"hello hello hello <UNK> <UNK>\"", "assert gen_text(\"hello world\", 10) == \"world world world world world world world world world world\"", "assert gen_text(\"world\", 3) == \"world world world\""]}
{"id": 89, "difficulty": "medium", "category": "Deep Learning", "title": "The Pattern Weaver's Code", "description": "Deep in the Crystal Cave, the enigmatic Pattern Weaver creates stunning sequences by uncovering the intricate relationships between crystals. Each crystal is marked by a unique numeric value, and the Weaver emphasizes that the true power of any crystal depends on how it interacts with all others. You have discovered N crystals, each with a specific value, and your task is to reveal their enhanced patterns by analyzing these relationships using self-attention. Given a sequence of crystals and their values, your task is to implement a simplified self-attention mechanism. For each crystal, calculate its relationship with every other crystal, compute the attention scores using the softmax function, and derive the final weighted pattern for each crystal.", "inputs": ["pattern_weaver(n = 5, crystal_values = [4, 2, 7, 1, 9], dimension = 1)"], "outputs": ["[8.9993, 8.9638, 9.0, 8.7259, 9.0]"], "reasoning": ["The self-attention mechanism calculates relationships (attention scores) for each crystal using the given formula. These scores are converted to probabilities using the softmax function, and the final weighted pattern for each crystal is derived by summing the weighted values."], "import_code": "import numpy as np", "output_constrains": "Your code should return a list of floats, each rounded to the 4th decimal place.", "entry_point": "pattern_weaver", "starter_code": "def pattern_weaver(n, crystal_values, dimension):\n    def softmax(values):\n        # Implement the softmax function first", "reference_code": "def pattern_weaver(n, crystal_values, dimension):\n    def softmax(values):\n        # Implement the softmax function first\n        exps = np.exp(values - np.max(values))\n        return exps / np.sum(exps)\n\n    dimension_sqrt = np.sqrt(dimension)\n    final_patterns = []\n\n    for i in range(n):\n        attention_scores = []\n        for j in range(n):\n            score = crystal_values[i] * crystal_values[j] / dimension_sqrt\n            attention_scores.append(score)\n\n        softmax_scores = softmax(attention_scores)\n        weighted_sum = sum(softmax_scores[k] * crystal_values[k] for k in range(n))\n        final_patterns.append(round(weighted_sum, 4))\n\n    return final_patterns", "test_cases": ["assert pattern_weaver(5, [4, 2, 7, 1, 9], 1) == [8.9993, 8.9638, 9.0, 8.7259, 9.0]", "assert pattern_weaver(3, [1, 3, 5], 1) == [4.7019, 4.995, 4.9999]", "assert pattern_weaver(4, [2, 8, 6, 4], 1) == [7.9627, 8.0, 8.0, 7.9993]", "assert pattern_weaver(3, [9, 2, 1], 1) == [9.0, 9.0, 8.9909]", "assert pattern_weaver(3, [9, 2, 1], 2) == [9.0, 8.9996, 8.9233]"]}
{"id": 90, "difficulty": "medium", "category": "NLP", "title": "BM25 Ranking", "description": "Implement the BM25 ranking function to calculate document scores for a query in an information retrieval context. BM25 is an advanced variation of TF-IDF that incorporates term frequency saturation, document length normalization, and a configurable penalty for document length effects.", "inputs": ["calculate_bm25_scores(corpus = [['the', 'cat', 'sat'], ['the', 'dog', 'ran'], ['the', 'bird', 'flew']], query = ['the', 'cat'])"], "outputs": ["[0.693, 0., 0. ]"], "reasoning": ["BM25 calculates scores for each document in the corpus by evaluating how well the query terms match each document while considering term frequency saturation and document length normalization."], "import_code": "import numpy as np\nfrom collections import Counter", "output_constrains": "The function should output a list representing the score of each document in the corpus, with each rounded to three decimal places.", "entry_point": "calculate_bm25_scores", "starter_code": "def calculate_bm25_scores(corpus, query, k1=1.5, b=0.75):", "reference_code": "def calculate_bm25_scores(corpus, query, k1=1.5, b=0.75):\n    if not corpus or not query:\n        raise ValueError(\"Corpus and query cannot be empty\")\n\n    doc_lengths = [len(doc) for doc in corpus]\n    avg_doc_length = np.mean(doc_lengths)\n    doc_term_counts = [Counter(doc) for doc in corpus]\n    doc_freqs = Counter()\n    for doc in corpus:\n        doc_freqs.update(set(doc))\n\n    scores = np.zeros(len(corpus))\n    N = len(corpus)\n\n    for term in query:\n        df = doc_freqs.get(term, 0) + 1\n        idf = np.log((N + 1) / df)\n\n        for idx, term_counts in enumerate(doc_term_counts):\n            if term not in term_counts:\n                continue\n\n            tf = term_counts[term]\n            doc_len_norm = 1 - b + b * (doc_lengths[idx] / avg_doc_length)\n            term_score = (tf * (k1 + 1)) / (tf + k1 * doc_len_norm)\n            scores[idx] += idf * term_score\n\n    return np.round(scores, 3).tolist()", "test_cases": ["assert calculate_bm25_scores([['the', 'cat', 'sat'], ['the', 'dog', 'ran'], ['the', 'bird', 'flew']], ['the', 'cat']) == [0.693, 0., 0. ]", "assert calculate_bm25_scores([['the'] * 10, ['the']], ['the']) == [0,0]", "assert calculate_bm25_scores([['term'] * 10, ['the'] * 2], ['term'], k1=1.0) == [.705, 0]"]}
{"id": 91, "difficulty": "easy", "category": "Machine Learning", "title": "Calculate F1 Score from Predicted and True Labels", "description": "Implement a function to calculate the F1 score given predicted and true labels. The F1 score is a widely used metric in machine learning, combining precision and recall into a single measure. round your solution to the 3rd decimal place", "inputs": ["calculate_f1_score(y_true = [1, 0, 1, 1, 0], y_pred = [1, 0, 0, 1, 1])"], "outputs": ["0.667"], "reasoning": ["The true positives, false positives, and false negatives are calculated from the given labels. Precision and recall are derived, and the F1 score is computed as their harmonic mean."], "import_code": "", "output_constrains": "", "entry_point": "calculate_f1_score", "starter_code": "def calculate_f1_score(y_true, y_pred):\n    \"\"\"\n    Calculate the F1 score based on true and predicted labels.\n\n    Args:\n        y_true (list): True labels (ground truth).\n        y_pred (list): Predicted labels.\n\n    Returns:\n        float: The F1 score rounded to three decimal places.\n    \"\"\"", "reference_code": "def calculate_f1_score(y_true, y_pred):\n    \"\"\"\n    Calculate the F1 score based on true and predicted labels.\n\n    Args:\n        y_true (list): True labels (ground truth).\n        y_pred (list): Predicted labels.\n\n    Returns:\n        float: The F1 score rounded to three decimal places.\n    \"\"\"\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"Lengths of y_true and y_pred must be the same\")\n\n    tp = sum(1 for yt, yp in zip(y_true, y_pred) if yt == yp == 1)\n    fp = sum(1 for yt, yp in zip(y_true, y_pred) if yt == 0 and yp == 1)\n    fn = sum(1 for yt, yp in zip(y_true, y_pred) if yt == 1 and yp == 0)\n\n    if tp + fp == 0 or tp + fn == 0:\n        return 0.0\n\n    precision = tp / (tp + fp)\n    recall = tp / (tp + fn)\n\n    if precision + recall == 0:\n        return 0.0\n\n    f1_score = 2 * (precision * recall) / (precision + recall)\n    return round(f1_score, 3)", "test_cases": ["assert calculate_f1_score([1, 0, 1, 1, 0], [1, 0, 0, 1, 1]) == 0.667", "assert calculate_f1_score([1, 1, 0, 0], [1, 0, 0, 1]) == 0.5", "assert calculate_f1_score([0, 0, 0, 0], [1, 1, 1, 1]) == 0.0", "assert calculate_f1_score([1, 1, 1, 1, 0], [1, 1, 0, 1, 1]) == 0.75", "assert calculate_f1_score([1, 1, 1, 1, 0, 0], [1, 1, 1, 1, 1, 0]) == 0.889"]}
{"id": 92, "difficulty": "medium", "category": "Machine Learning", "title": "Linear Regression - Power Grid Optimization", "description": "It is the year 2157. Mars has its first thriving colony, and energy consumption is steadily on the rise. As the lead data scientist, you have daily power usage measurements (10 days) affected by both a growing linear trend and a daily fluctuation. The fluctuation follows the formula $f(i) = 10 \\times \\sin(2\\pi i / 10)$, where i is the day number (1 through 10). Your challenge is to remove this known fluctuation from each data point, fit a linear regression model to the detrended data, predict day 15's base consumption, add back the fluctuation for day 15, and finally include a 5% safety margin. The final answer must be an integer, ensuring you meet the colony's future needs.", "inputs": ["power_grid_forecast(consumption_data = [150, 165, 185, 195, 210, 225, 240, 260, 275, 290])"], "outputs": ["404"], "reasoning": ["For each of the 10 days, we subtract the daily fluctuation given by 10*sin(2\u03c0*i/10). We then perform linear regression on the resulting values, predict day 15\u2019s base usage, and add back the day 15 fluctuation. Finally, we apply a 5% margin. Running the provided solution code yields 404 for this dataset."], "import_code": "import math", "output_constrains": "", "entry_point": "power_grid_forecast", "starter_code": "PI = 3.14159\n\ndef power_grid_forecast(consumption_data):\n    # 1) Subtract the daily fluctuation (10 * sin(2\u03c0 * i / 10)) from each data point.\n    # 2) Perform linear regression on the detrended data.\n    # 3) Predict day 15's base consumption.\n    # 4) Add the day 15 fluctuation back.\n    # 5) Round, then add a 5% safety margin (rounded up).\n    # 6) Return the final integer.", "reference_code": "PI = 3.14159\n\ndef power_grid_forecast(consumption_data):\n    # 1) Subtract the daily fluctuation (10 * sin(2\u03c0 * i / 10)) from each data point.\n    # 2) Perform linear regression on the detrended data.\n    # 3) Predict day 15's base consumption.\n    # 4) Add the day 15 fluctuation back.\n    # 5) Round, then add a 5% safety margin (rounded up).\n    # 6) Return the final integer.\n\n    # consumption_data: list of 10 daily consumption values\n    # days: 1 through 10\n    days = list(range(1, 11))\n    n = len(days)\n\n    # 1) Remove daily fluctuation\n    detrended = []\n    for i, cons in zip(days, consumption_data):\n        fluctuation_i = 10 * math.sin((2 * PI * i) / 10)\n        detrended_value = cons - fluctuation_i\n        detrended.append(detrended_value)\n\n    # 2) Perform linear regression on the detrended data\n    sum_x = sum(days)\n    sum_y = sum(detrended)\n    sum_xy = sum(x * y for x, y in zip(days, detrended))\n    sum_x2 = sum(x**2 for x in days)\n\n    # slope (m) and intercept (b) for y = m*x + b\n    m = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x**2)\n    b = (sum_y - m * sum_x) / n\n\n    # 3) Predict day 15's base usage\n    day_15_base = m * 15 + b\n\n    # 4) Add back daily fluctuation for day 15\n    day_15_fluctuation = 10 * math.sin((2 * PI * 15) / 10)\n    day_15_prediction = day_15_base + day_15_fluctuation\n\n    # 5) Round and add 5% safety margin\n    day_15_rounded = round(day_15_prediction)\n    final_15 = math.ceil(day_15_rounded * 1.05)\n\n    return final_15", "test_cases": ["assert power_grid_forecast([150, 165, 185, 195, 210, 225, 240, 260, 275, 290]) == 404", "assert power_grid_forecast([160, 170, 190, 200, 215, 230, 245, 265, 280, 295]) == 407", "assert power_grid_forecast([140, 158, 180, 193, 205, 220, 237, 255, 270, 288]) == 404", "assert power_grid_forecast([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == 19", "assert power_grid_forecast([1, 19, 1, 20, 1, 18, 1, 19, 1, 20]) == 35"]}
{"id": 93, "difficulty": "easy", "category": "Machine Learning", "title": "Calculate Mean Absolute Error (MAE)", "description": "Implement a function to calculate the Mean Absolute Error (MAE) between two arrays of actual and predicted values. The MAE is a metric used to measure the average magnitude of errors in a set of predictions without considering their direction.", "inputs": ["mae(y_true = np.array([3, -0.5, 2, 7]), y_pred = np.array([2.5, 0.0, 2, 8]))"], "outputs": ["0.500"], "reasoning": ["The MAE is calculated by taking the mean of the absolute differences between the predicted and true values. Using the formula, the result is 0.500."], "import_code": "import numpy as np", "output_constrains": "", "entry_point": "mae", "starter_code": "def mae(y_true, y_pred):\n    \"\"\"\n    Calculate Mean Absolute Error between two arrays.\n\n    Parameters:\n    y_true (numpy.ndarray): Array of true values\n    y_pred (numpy.ndarray): Array of predicted values\n\n    Returns:\n    float: Mean Absolute Error rounded to 3 decimal places\n    \"\"\"", "reference_code": "def mae(y_true, y_pred):\n    \"\"\"\n    Calculate Mean Absolute Error between two arrays.\n\n    Parameters:\n    y_true (numpy.ndarray): Array of true values\n    y_pred (numpy.ndarray): Array of predicted values\n\n    Returns:\n    float: Mean Absolute Error rounded to 3 decimal places\n    \"\"\"\n    if y_true.shape != y_pred.shape:\n        raise ValueError(\"Arrays must have the same shape\")\n    if y_true.size == 0:\n        raise ValueError(\"Arrays cannot be empty\")\n\n    return round(np.mean(np.abs(y_true - y_pred)), 3)", "test_cases": ["assert mae(np.array([3, -0.5, 2, 7]), np.array([2.5, 0.0, 2, 8])) == 0.500", "assert mae(np.array([[0.5, 1], [-1, 1], [7, -6]]), np.array([[0, 2], [-1, 2], [8, -5]])) == 0.750", "assert mae(np.array([-1, -2, -3]), np.array([-1.5, -2.2, -2.8])) == 0.300", "assert mae(np.array([1, -1, 0]), np.array([-1, 1, 0])) == 1.333", "assert mae(np.array([1000, -1000, 0]), np.array([-1000, 1000, 0])) == 1333.333", "assert mae(np.array([1000, -1000, 0]), np.array([0, 0, 0])) == 666.667"]}
{"id": 94, "difficulty": "hard", "category": "Deep Learning", "title": "Implement Multi-Head Attention", "description": "Implement the multi-head attention mechanism, a key component in the Transformer model, via three key functions: `compute_qkv`, `self_attention`, and `multi_head_attention`.", "inputs": ["np.random.seed(42)\nm, n = 2, 2\nn_heads = 2\nX = np.arange(m*n).reshape(m,n)\nX = np.random.permutation(X.flatten()).reshape(m, n)\nW_q = np.random.randint(0,4,size=(n,n))\nW_k = np.random.randint(0,5,size=(n,n))\nW_v = np.random.randint(0,6,size=(n,n))\n\nmulti_head_attention(X, W_q, W_k, W_v, n_heads)"], "outputs": ["[[9.9852, 18.0], [7.0, 14.0]]"], "reasoning": ["Multi-head attention is computed for 2 heads using the input Q, K, and V matrices. The resulting outputs for each head are concatenated to form the final attention output."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "multi_head_attention", "starter_code": "def multi_head_attention(X: np.ndarray, W_q: np.ndarray, W_k: np.ndarray, W_v: np.ndarray, n_heads: int) -> list:\n\n    # Compute the Query (Q), Key (K), and Value (V) matrices.\n    Q, K, V = compute_qkv(X, W_q, W_k, W_v)", "reference_code": "def compute_qkv(X: np.ndarray, W_q: np.ndarray, W_k: np.ndarray, W_v: np.ndarray):\n    \"\"\"\n    Compute the Query (Q), Key (K), and Value (V) matrices.\n    \n    Args:\n    X: numpy array of shape (seq_len, d_model), input sequence\n    W_q, W_k, W_v: numpy arrays of shape (d_model, d_model), weight matrices for Q, K, and V\n    \n    Returns:\n    Q, K, V: numpy arrays of shape (seq_len, d_model)\n    \"\"\"\n\n    Q = np.dot(X, W_q)  # Compute the Query matrix Q\n    K = np.dot(X, W_k)  # Compute the Key matrix K\n    V = np.dot(X, W_v)  # Compute the Value matrix V\n    return Q, K, V\n\ndef self_attention(Q: np.ndarray, K: np.ndarray, V: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute self-attention for a single head.\n    \n    Args:\n    Q: numpy array of shape (seq_len, d_k), Query matrix\n    K: numpy array of shape (seq_len, d_k), Key matrix\n    V: numpy array of shape (seq_len, d_k), Value matrix\n    \n    Returns:\n    attention_output: numpy array of shape (seq_len, d_k), output of the self-attention mechanism\n    \"\"\"\n    \n    d_k = Q.shape[1]  # Get the dimension of the keys\n    scores = np.matmul(Q, K.T) / np.sqrt(d_k)  # Compute scaled dot-product attention scores\n    score_max = np.max(scores, axis=1, keepdims=True)  # Find the maximum score for numerical stability\n    attention_weights = np.exp(scores - score_max) / np.sum(np.exp(scores - score_max), axis=1, keepdims=True)  # Compute softmax to get attention weights\n    attention_output = np.matmul(attention_weights, V)  # Compute the final attention output\n    return attention_output\n\ndef multi_head_attention(X: np.ndarray, W_q: np.ndarray, W_k: np.ndarray, W_v: np.ndarray, n_heads: int) -> list:\n\n    # Compute the Query (Q), Key (K), and Value (V) matrices.\n    Q, K, V = compute_qkv(X, W_q, W_k, W_v)\n    \n    d_model = Q.shape[1]  # Get the model dimension\n    assert d_model % n_heads == 0  # Ensure d_model is divisible by n_heads\n    d_k = d_model // n_heads  # Dimension for each head\n\n    # Reshape Q, K, V to separate heads\n    Q_reshaped = Q.reshape(Q.shape[0], n_heads, d_k).transpose(1, 0, 2)  # Reshape and transpose to (n_heads, seq_len, d_k)\n    K_reshaped = K.reshape(K.shape[0], n_heads, d_k).transpose(1, 0, 2)  # Reshape and transpose to (n_heads, seq_len, d_k)\n    V_reshaped = V.reshape(V.shape[0], n_heads, d_k).transpose(1, 0, 2)  # Reshape and transpose to (n_heads, seq_len, d_k)\n\n    # Compute attention scores for each head\n    attentions = []  # Store attention outputs for each head\n\n    for i in range(n_heads):\n        attn = self_attention(Q_reshaped[i], K_reshaped[i], V_reshaped[i])  # Compute attention for the i-th head\n        attentions.append(attn)  # Collect attention output\n\n    # Concatenate all head outputs\n    attention_output = np.concatenate(attentions, axis=-1)  # Concatenate along the last axis (columns)\n    return np.round(attention_output, 4).tolist()", "test_cases": ["np.random.seed(42)\n\nm, n = 4, 4\nn_heads = 2\n# Generate input data\nX = np.arange(m*n).reshape(m,n)\nX = np.random.permutation(X.flatten()).reshape(m, n)\n# Generate weight matrices\nW_q = np.random.randint(0, 4, size=(n,n))\nW_k = np.random.randint(0, 5, size=(n,n))\nW_v = np.random.randint(0, 6, size=(n,n))\n\nassert multi_head_attention(X, W_q, W_k, W_v, n_heads) == [[103.0, 109.0, 46.0, 99.0], [103.0, 109.0, 46.0, 99.0], [103.0, 109.0, 46.0, 99.0], [103.0, 109.0, 46.0, 99.0]]", "np.random.seed(42)\n\nm, n = 6, 8\nn_heads = 4\n# Generate input data\nX = np.arange(m*n).reshape(m,n)\nX = np.random.permutation(X.flatten()).reshape(m, n)\n# Generate weight matrices\nW_q = np.random.randint(0, 4, size=(n,n))\nW_k = np.random.randint(0, 5, size=(n,n))\nW_v = np.random.randint(0, 6, size=(n,n))\n\nassert multi_head_attention(X, W_q, W_k, W_v, n_heads) == [[500.0, 463.0, 399.0, 495.0, 377.0, 450.0, 531.0, 362.0], [500.0, 463.0, 399.0, 495.0, 377.0, 450.0, 531.0, 362.0], [500.0, 463.0, 399.0, 495.0, 377.0, 450.0, 531.0, 362.0], [500.0, 463.0, 399.0, 495.0, 377.0, 450.0, 531.0, 362.0], [500.0, 463.0, 399.0, 495.0, 377.0, 450.0, 531.0, 362.0], [500.0, 463.0, 399.0, 495.0, 377.0, 450.0, 531.0, 362.0]]", "np.random.seed(42)\n\nm, n = 6, 8\nn_heads = 2\n# Generate input data\nX = np.arange(m*n).reshape(m,n)\nX = np.random.permutation(X.flatten()).reshape(m, n)\n# Generate weight matrices\nW_q = np.random.randint(0, 4, size=(n,n))\nW_k = np.random.randint(0, 5, size=(n,n))\nW_v = np.random.randint(0, 6, size=(n,n))\n\nassert multi_head_attention(X, W_q, W_k, W_v, n_heads) == [[547.0, 490.0, 399.0, 495.0, 377.0, 450.0, 531.0, 362.0], [547.0, 490.0, 399.0, 495.0, 377.0, 450.0, 531.0, 362.0], [547.0, 490.0, 399.0, 495.0, 377.0, 450.0, 531.0, 362.0], [547.0, 490.0, 399.0, 495.0, 377.0, 450.0, 531.0, 362.0], [547.0, 490.0, 399.0, 495.0, 377.0, 450.0, 531.0, 362.0], [547.0, 490.0, 399.0, 495.0, 377.0, 450.0, 531.0, 362.0]]"]}
{"id": 95, "difficulty": "easy", "category": "Statistics", "title": "Calculate the Phi Coefficient", "description": "Implement a function to calculate the Phi coefficient, a measure of the correlation between two binary variables. The function should take two lists of integers (0s and 1s) as input and return the Phi coefficient rounded to 4 decimal places.", "inputs": ["phi_corr(x = [1, 1, 0, 0], y = [0, 0, 1, 1])"], "outputs": ["-1.0"], "reasoning": ["The Phi coefficient measures the correlation between two binary variables. In this example, the variables have a perfect negative correlation, resulting in a Phi coefficient of -1.0."], "import_code": "", "output_constrains": "", "entry_point": "phi_corr", "starter_code": "def phi_corr(x: list[int], y: list[int]) -> float:\n    \"\"\"\n    Calculate the Phi coefficient between two binary variables.\n\n    Args:\n    x (list[int]): A list of binary values (0 or 1).\n    y (list[int]): A list of binary values (0 or 1).\n\n    Returns:\n    float: The Phi coefficient rounded to 4 decimal places.\n    \"\"\"", "reference_code": "def phi_corr(x: list[int], y: list[int]) -> float:\n    \"\"\"\n    Calculate the Phi coefficient between two binary variables.\n\n    Args:\n    x (list[int]): A list of binary values (0 or 1).\n    y (list[int]): A list of binary values (0 or 1).\n\n    Returns:\n    float: The Phi coefficient rounded to 4 decimal places.\n    \"\"\"\n    x1y1 = x1y0 = x0y1 = x0y0 = 0\n\n    # Count occurrences\n    for i in range(len(x)):\n        if x[i] == 1:\n            if y[i] == 1:\n                x1y1 += 1\n            else:\n                x1y0 += 1\n        elif x[i] == 0:\n            if y[i] == 1:\n                x0y1 += 1\n            else:\n                x0y0 += 1\n\n    # Calculate numerator and denominator\n    numerator = (x0y0 * x1y1) - (x0y1 * x1y0)\n    denominator = ((x0y0 + x0y1) * (x1y0 + x1y1) * (x0y0 + x1y0) * (x0y1 + x1y1)) ** 0.5\n\n    if denominator == 0:\n        return 0.0\n\n    phi = numerator / denominator\n    return round(phi, 4)", "test_cases": ["assert phi_corr([1, 1, 0, 0], [0, 0, 1, 1]) == -1.0", "assert phi_corr([1, 1, 0, 0], [1, 0, 1, 1]) == -0.5774", "assert phi_corr([0, 0, 1, 1], [0, 1, 0, 1]) == 0.0", "assert phi_corr([1, 0, 1, 0,1,1,0], [1, 1, 0, 0,1,1,1]) == 0.0913"]}
{"id": 96, "difficulty": "easy", "category": "Deep Learning", "title": "Implement the Hard Sigmoid Activation Function", "description": "Implement the Hard Sigmoid activation function, a computationally efficient approximation of the standard sigmoid function. Your function should take a single input value and return the corresponding output based on the Hard Sigmoid definition.", "inputs": ["hard_sigmoid(x = 0.0)"], "outputs": ["0.5"], "reasoning": ["The input 0.0 falls in the linear region of the Hard Sigmoid function. Using the formula $HardSigmoid(x) = 0.2x + 0.5$, the output is $0.2 \\times 0.0 + 0.5 = 0.5$."], "import_code": "", "output_constrains": "", "entry_point": "hard_sigmoid", "starter_code": "def hard_sigmoid(x: float) -> float:\n    \"\"\"\n    Implements the Hard Sigmoid activation function.\n\n    Args:\n        x (float): Input value\n\n    Returns:\n        float: The Hard Sigmoid of the input\n    \"\"\"", "reference_code": "def hard_sigmoid(x: float) -> float:\n    \"\"\"\n    Implements the Hard Sigmoid activation function.\n\n    Args:\n        x (float): Input value\n\n    Returns:\n        float: The Hard Sigmoid of the input\n    \"\"\"\n    if x <= -2.5:\n        return 0.0\n    elif x >= 2.5:\n        return 1.0\n    else:\n        return 0.2 * x + 0.5", "test_cases": ["assert hard_sigmoid(.56) == 0.612", "assert hard_sigmoid(3.0) == 1.0", "assert hard_sigmoid(0.0) == 0.5", "assert hard_sigmoid(1.0) == 0.7", "assert hard_sigmoid(-1.0) == 0.3", "assert hard_sigmoid(2.5) == 1.0", "assert hard_sigmoid(-2.5) == 0.0", "assert hard_sigmoid(-3.0) == 0.0"]}
{"id": 97, "difficulty": "easy", "category": "Deep Learning", "title": "Implement the ELU Activation Function", "description": "Implement the ELU (Exponential Linear Unit) activation function, which helps mitigate the limitations of ReLU by providing negative outputs for negative inputs. The function should compute the ELU activation value for a given input.", "inputs": ["elu(x = -1)"], "outputs": ["-0.6321"], "reasoning": ["For x = -1 and alpha = 1.0, the ELU activation is computed as $\\alpha \\times (e^{x} - 1)$."], "import_code": "import math", "output_constrains": "Your code should return a float rounded to the 4th decimal place.", "entry_point": "elu", "starter_code": "def elu(x: float, alpha: float = 1.0) -> float:\n    \"\"\"\n    Compute the ELU activation function.\n\n    Args:\n        x (float): Input value\n        alpha (float): ELU parameter for negative values (default: 1.0)\n\n    Returns:\n        float: ELU activation value\n    \"\"\"", "reference_code": "def elu(x: float, alpha: float = 1.0) -> float:\n    \"\"\"\n    Compute the ELU activation function.\n\n    Args:\n        x (float): Input value\n        alpha (float): ELU parameter for negative values (default: 1.0)\n\n    Returns:\n        float: ELU activation value\n    \"\"\"\n    return round(x if x > 0 else alpha * (math.exp(x) - 1), 4)", "test_cases": ["assert elu(0) == 0.0", "assert elu(1) == 1.0", "assert elu(-1) == -0.6321", "assert elu(-1, alpha=2.0) == -1.2642", "assert elu(5) == 5.0", "assert elu(-5) == -0.9933"]}
{"id": 98, "difficulty": "easy", "category": "Deep Learning", "title": "Implement the PReLU Activation Function", "description": "Implement the PReLU (Parametric ReLU) activation function, a variant of the ReLU activation function that introduces a learnable parameter for negative inputs. Your task is to compute the PReLU activation value for a given input.", "inputs": ["prelu(x = -2.0, alpha = 0.25)"], "outputs": ["-0.5"], "reasoning": ["For x = -2.0 and alpha = 0.25, the PReLU activation is calculated as $ PReLU(x) = \\alpha x = 0.25 \\times -2.0 = -0.5$."], "import_code": "", "output_constrains": "", "entry_point": "prelu", "starter_code": "def prelu(x: float, alpha: float = 0.25) -> float:\n    \"\"\"\n    Implements the PReLU (Parametric ReLU) activation function.\n\n    Args:\n        x: Input value\n        alpha: Slope parameter for negative values (default: 0.25)\n\n    Returns:\n        float: PReLU activation value\n    \"\"\"", "reference_code": "def prelu(x: float, alpha: float = 0.25) -> float:\n    \"\"\"\n    Implements the PReLU (Parametric ReLU) activation function.\n\n    Args:\n        x: Input value\n        alpha: Slope parameter for negative values (default: 0.25)\n\n    Returns:\n        float: PReLU activation value\n    \"\"\"\n    return x if x > 0 else alpha * x", "test_cases": ["assert prelu(2.0) == 2.0", "assert prelu(0.0) == 0.0", "assert prelu(-2.0) == -0.5", "assert prelu(-2.0, alpha=0.1) == -0.2", "assert prelu(-2.0, alpha=1.0) == -2.0"]}
{"id": 99, "difficulty": "easy", "category": "Deep Learning", "title": "Implement the Softplus Activation Function", "description": "Implement the Softplus activation function, a smooth approximation of the ReLU function. Your task is to compute the Softplus value for a given input, handling edge cases to prevent numerical overflow or underflow.", "inputs": ["softplus(x = 2)"], "outputs": ["2.1269"], "reasoning": ["For x = 2, the Softplus activation is calculated as $\\log(1 + e^{x})$."], "import_code": "import math", "output_constrains": "Your code should return a float rounded to the 4th decimal place.", "entry_point": "softplus", "starter_code": "def softplus(x: float) -> float:\n    \"\"\"\n    Compute the softplus activation function.\n\n    Args:\n        x: Input value\n\n    Returns:\n        The softplus value: log(1 + e^x)\n    \"\"\"", "reference_code": "def softplus(x: float) -> float:\n    \"\"\"\n    Compute the softplus activation function.\n\n    Args:\n        x: Input value\n\n    Returns:\n        The softplus value: log(1 + e^x)\n    \"\"\"\n    # To prevent overflow for large positive values\n    if x > 100:\n        return x\n    # To prevent underflow for large negative values\n    if x < -100:\n        return 0.0\n\n    return round(math.log(1.0 + math.exp(x)),4)", "test_cases": ["assert softplus(0) == 0.6931", "assert softplus(100) == 100.0", "assert softplus(-100) == 0.0", "assert softplus(2) == 2.1269", "assert softplus(-2) == 0.1269"]}
{"id": 100, "difficulty": "easy", "category": "Deep Learning", "title": "Implement the Softsign Activation Function", "description": "Implement the Softsign activation function, a smooth activation function used in neural networks. Your task is to compute the Softsign value for a given input, ensuring the output is bounded between -1 and 1.", "inputs": ["softsign(x = 1)"], "outputs": ["0.5"], "reasoning": ["For x = 1, the Softsign activation is calculated as $ \\frac{x}{1 + |x|}$."], "import_code": "", "output_constrains": "Your code should return a float rounded to the 4th decimal place.", "entry_point": "softsign", "starter_code": "def softsign(x: float) -> float:\n    \"\"\"\n    Implements the Softsign activation function.\n\n    Args:\n        x (float): Input value\n\n    Returns:\n        float: The Softsign of the input\n    \"\"\"", "reference_code": "def softsign(x: float) -> float:\n    \"\"\"\n    Implements the Softsign activation function.\n\n    Args:\n        x (float): Input value\n\n    Returns:\n        float: The Softsign of the input\n    \"\"\"\n    return round(x / (1 + abs(x)), 4)", "test_cases": ["assert softsign(0) == 0.0", "assert softsign(1) == 0.5", "assert softsign(-1) == -0.5", "assert softsign(100) == 0.9901", "assert softsign(-100) == -0.9901"]}
{"id": 101, "difficulty": "hard", "category": "Reinforcement Learning", "title": "Implement the GRPO Objective Function", "description": "Implement the GRPO (Group Relative Policy Optimization) objective function used to optimize policy parameters in reinforcement learning. Your task is to compute the GRPO objective given the likelihood ratios, advantage estimates, old policy probabilities, reference policy probabilities, and apply the clipping mechanism and KL divergence penalty correctly to maintain training stability.", "inputs": ["[1.2, 0.8, 1.1], [1.0, 1.0, 1.0], [0.9, 1.1, 1.0], [1.0, 0.5, 1.5], epsilon=0.2, beta=0.01"], "outputs": ["1.032749"], "reasoning": ["The function calculates the GRPO objective by first clipping the likelihood ratios, computing the minimum terms, averaging them, and then subtracting the KL divergence penalty scaled by beta."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 6th decimal.", "entry_point": "grpo_objective", "starter_code": "def grpo_objective(rhos, A, pi_theta_old, pi_theta_ref, epsilon=0.2, beta=0.01) -> float:\n    \"\"\"\n    Compute the GRPO objective function.\n\n    Args:\n        rhos: List of likelihood ratios (p_i) = pi_theta(o_i | q) / pi_theta_old(o_i | q).\n        A: List of advantage estimates (A_i).\n        pi_theta_old: List representing the old policy probabilities pi_theta_old(o_i | q).\n        pi_theta_ref: List representing the reference policy probabilities pi_ref(o_i | q).\n        epsilon: Clipping parameter (eps).\n        beta: KL divergence penalty coefficient (beta).\n\n    Returns:\n        The computed GRPO objective value.\n    \"\"\"", "reference_code": "def grpo_objective(rhos, A, pi_theta_old, pi_theta_ref, epsilon=0.2, beta=0.01) -> float:\n    \"\"\"\n    Compute the GRPO objective function.\n\n    Args:\n        rhos: List of likelihood ratios (p_i) = pi_theta(o_i | q) / pi_theta_old(o_i | q).\n        A: List of advantage estimates (A_i).\n        pi_theta_old: List representing the old policy probabilities pi_theta_old(o_i | q).\n        pi_theta_ref: List representing the reference policy probabilities pi_ref(o_i | q).\n        epsilon: Clipping parameter (eps).\n        beta: KL divergence penalty coefficient (beta).\n\n    Returns:\n        The computed GRPO objective value.\n    \"\"\"\n\n    G = len(rhos)\n    if not (len(A) == len(pi_theta_old) == len(pi_theta_ref) == G):\n        raise ValueError(\"All input lists must have the same length.\")\n    \n    # Compute clipped likelihood ratios\n    clipped_rhos = np.clip(rhos, 1 - epsilon, 1 + epsilon)\n    \n    # Compute the minimum terms for the objective\n    unclipped = np.array(rhos) * np.array(A)\n    clipped = clipped_rhos * np.array(A)\n    min_terms = np.minimum(unclipped, clipped)\n    average_min = np.mean(min_terms)\n    \n    # Compute pi_theta from rhos and pi_theta_old\n    pi_theta = np.array(rhos) * np.array(pi_theta_old)\n    \n    # Normalize pi_theta and pi_theta_ref to ensure they are valid probability distributions\n    pi_theta /= np.sum(pi_theta)\n    pi_theta_ref /= np.sum(pi_theta_ref)\n    \n    # Compute KL divergence D_KL(pi_theta || pi_theta_ref)\n    kl_divergence = np.sum(pi_theta * np.log(pi_theta / pi_theta_ref + 1e-10))  # Added epsilon to avoid log(0)\n    \n    # Compute the final objective\n    objective = average_min - beta * kl_divergence\n    \n    return np.round(objective, 6)", "test_cases": ["assert grpo_objective([1.2, 0.8, 1.1], [1.0, 1.0, 1.0], [0.9, 1.1, 1.0], [1.0, 0.5, 1.5], epsilon=0.2, beta=0.01) == 1.032749, \"test case failed: grpo_objective([1.2, 0.8, 1.1], [1.0, 1.0, 1.0], [0.9, 1.1, 1.0], [1.0, 0.5, 1.5], epsilon=0.2, beta=0.01)\"", "assert grpo_objective([0.9, 1.1], [1.0, 1.0], [1.0, 1.0], [0.8, 1.2], epsilon=0.1, beta=0.05) == 0.999743, \"test case failed: grpo_objective([0.9, 1.1], [1.0, 1.0], [1.0, 1.0], [0.8, 1.2], epsilon=0.1, beta=0.05)\"", "assert grpo_objective([1.5, 0.5, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.2, 0.7, 1.3], epsilon=0.15, beta=0.02) == 0.882682, \"test case failed: grpo_objective([1.5, 0.5, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.2, 0.7, 1.3], epsilon=0.15, beta=0.02)\"", "assert grpo_objective([1.0], [1.0], [1.0], [1.0], epsilon=0.1, beta=0.01) == 1.0, \"test case failed: grpo_objective([1.0], [1.0], [1.0], [1.0], epsilon=0.1, beta=0.01)\""]}
{"id": 102, "difficulty": "easy", "category": "Deep Learning", "title": "Implement the Swish Activation Function", "description": "Implement the Swish activation function, a self-gated activation function that has shown superior performance in deep neural networks compared to ReLU. Your task is to compute the Swish value for a given input.", "inputs": ["1"], "outputs": ["0.7311"], "reasoning": ["For $x=1$, the Swish activation is calculated as $\\mathit{Swish}(x)=x \times \\sigma(x)$, where $\\sigma(x)=\frac{1}{1+e^{-x}}$. Substituting the value, $\\mathit{Swish}(1)=1 \times \frac{1}{1+e^{-1}}=0.7311$."], "import_code": "import math\nimport numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.", "entry_point": "swish", "starter_code": "def swish(x: float) -> float:\n    \"\"\"\n    Implements the Swish activation function.\n\n    Args:\n        x: Input value\n\n    Returns:\n        The Swish activation value\n    \"\"\"", "reference_code": "def swish(x: float) -> float:\n    \"\"\"\n    Implements the Swish activation function.\n\n    Args:\n        x: Input value\n\n    Returns:\n        The Swish activation value\n    \"\"\"\n\n    return np.round(x * (1 / (1 + math.exp(-x))), 4)", "test_cases": ["assert swish(0) == 0.0, \"test case failed: swish(0)\"", "assert swish(1) == 0.7311, \"test case failed: swish(1)\"", "assert swish(-1) == -0.2689, \"test case failed: swish(-1)\"", "assert swish(10) == 9.9995, \"test case failed: swish(10)\"", "assert swish(-10) == -0.0005, \"test case failed: swish(-10)\""]}
{"id": 103, "difficulty": "easy", "category": "Deep Learning", "title": "Implement the SELU Activation Function", "description": "Implement the SELU (Scaled Exponential Linear Unit) activation function, a self-normalizing variant of ELU. Your task is to compute the SELU value for a given input while ensuring numerical stability.", "inputs": ["-1.0"], "outputs": ["-1.1113"], "reasoning": ["For $x=-1.0$, the SELU activation is calculated using the formula $\\mathit{SELU}(x)=$ $\\lambda \u0007lpha\\left(e^x-1\right)$. Substituting the values of $\\lambda$ and $\u0007lpha$, we get $\\mathit{SELU}(-1.0)=$ $1.0507 \times 1.6733 \times\\left(e^{-1.0}-1\right)=-1.1113$."], "import_code": "import math\nimport numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.", "entry_point": "selu", "starter_code": "def selu(x: float) -> float:\n    \"\"\"\n    Implements the SELU (Scaled Exponential Linear Unit) activation function.\n\n    Args:\n        x: Input value\n\n    Returns:\n        SELU activation value\n    \"\"\"\n    alpha = 1.6732632423543772\n    scale = 1.0507009873554804", "reference_code": "def selu(x: float) -> float:\n    \"\"\"\n    Implements the SELU (Scaled Exponential Linear Unit) activation function.\n\n    Args:\n        x: Input value\n\n    Returns:\n        SELU activation value\n    \"\"\"\n    alpha = 1.6732632423543772\n    scale = 1.0507009873554804\n\n    return np.round(scale * x if x > 0 else scale * alpha * (math.exp(x) - 1), 4)", "test_cases": ["assert selu(1.0) == 1.0507, \"test case failed: selu(1.0)\"", "assert selu(0.0) == 0.0, \"test case failed: selu(0.0)\"", "assert selu(-1.0) == -1.1113, \"test case failed: selu(-1.0)\"", "assert selu(5.0) == 5.2535, \"test case failed: selu(5.0)\"", "assert selu(-5.0) == -1.7463, \"test case failed: selu(-5.0)\""]}
{"id": 104, "difficulty": "easy", "category": "Machine Learning", "title": "Binary Classification with Logistic Regression", "description": "Implement the prediction function for binary classification using Logistic Regression. Your task is to compute class probabilities using the sigmoid function and return binary predictions based on a threshold of 0.5.", "inputs": ["np.array([[1, 1], [2, 2], [-1, -1], [-2, -2]]), np.array([1, 1]), 0"], "outputs": ["[1,1,0,0]"], "reasoning": ["Each sample's linear combination is computed using $z=X w+b$. The sigmoid function is applied, and the output is thresholded at 0.5 , resulting in binary predictions."], "import_code": "import numpy as np", "output_constrains": "Return python list after reshaping by using numpy's tolist() method.", "entry_point": "predict_logistic", "starter_code": "def predict_logistic(X: np.ndarray, weights: np.ndarray, bias: float) -> list:\n    \"\"\"\n    Implements binary classification prediction using Logistic Regression.\n\n    Args:\n        X: Input feature matrix (shape: N \u00c3\u0097 D)\n        weights: Model weights (shape: D)\n        bias: Model bias\n\n    Returns:\n        Binary predictions (0 or 1)\n    \"\"\"", "reference_code": "def predict_logistic(X: np.ndarray, weights: np.ndarray, bias: float) -> list:\n    \"\"\"\n    Implements binary classification prediction using Logistic Regression.\n\n    Args:\n        X: Input feature matrix (shape: N \u00c3\u0097 D)\n        weights: Model weights (shape: D)\n        bias: Model bias\n\n    Returns:\n        Binary predictions (0 or 1)\n    \"\"\"\n\n    z = np.dot(X, weights) + bias\n    z = np.clip(z, -500, 500)  # Prevent overflow in exp\n    probabilities = 1 / (1 + np.exp(-z))\n    return (probabilities >= 0.5).astype(int).tolist()", "test_cases": ["assert predict_logistic(np.array([[1, 1], [2, 2], [-1, -1], [-2, -2]]), np.array([1, 1]), 0) == [1,1,0,0], \"test case failed: predict_logistic(np.array([[1, 1], [2, 2], [-1, -1], [-2, -2]]), np.array([1, 1]), 0)\"", "assert predict_logistic(np.array([[0, 0], [0.1, 0.1], [-0.1, -0.1]]), np.array([1, 1]), 0) == [1,1,0], \"test case failed: predict_logistic(np.array([[0, 0], [0.1, 0.1], [-0.1, -0.1]]), np.array([1, 1]), 0)\"", "assert predict_logistic(np.array([[1, 2, 3], [-1, -2, -3], [0.5, 1, 1.5]]), np.array([0.1, 0.2, 0.3]), -1) == [1,0,0], \"test case failed: predict_logistic(np.array([[1, 2, 3], [-1, -2, -3], [0.5, 1, 1.5]]), np.array([0.1, 0.2, 0.3]), -1)\"", "assert predict_logistic(np.array([[1], [2], [-1], [-2]]), np.array([2]), 0) == [1,1,0,0], \"test case failed: predict_logistic(np.array([[1], [2], [-1], [-2]]), np.array([2]), 0)\"", "assert predict_logistic(np.array([[1000, 2000], [-1000, -2000]]), np.array([0.1, 0.1]), 0) == [1,0], \"test case failed: predict_logistic(np.array([[1000, 2000], [-1000, -2000]]), np.array([0.1, 0.1]), 0)\""]}
{"id": 105, "difficulty": "hard", "category": "Machine Learning", "title": "Train Softmax Regression with Gradient Descent", "description": "Implement a gradient descent-based training algorithm for Softmax regression. Your task is to compute model parameters using Cross Entropy loss and return the optimized coefficients along with collected loss values over iterations.", "inputs": ["np.array([[0.5, -1.2], [-0.3, 1.1], [0.8, -0.6]]), np.array([0, 1, 2]), 0.01, 10"], "outputs": ["([[-0.0011, 0.0145, -0.0921], [0.002, -0.0598, 0.1263], [-0.0009, 0.0453, -0.0342]], [3.2958, 3.2611, 3.2272, 3.1941, 3.1618, 3.1302, 3.0993, 3.0692, 3.0398, 3.011])"], "reasoning": ["The function iteratively updates the Softmax regression parameters using gradient descent and collects loss values over iterations."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "train_softmaxreg", "starter_code": "def train_softmaxreg(X: np.ndarray, y: np.ndarray, learning_rate: float, iterations: int) -> tuple[list[float], ...]:\n    \"\"\"\n    Gradient-descent training algorithm for Softmax regression, optimizing parameters with Cross Entropy loss.\n\n    Returns:\n        B : list[float], CxM updated parameter vector rounded to 4 floating points\n        losses : list[float], collected values of a Cross Entropy rounded to 4 floating points\n    \"\"\"", "reference_code": "def train_softmaxreg(X: np.ndarray, y: np.ndarray, learning_rate: float, iterations: int) -> tuple[list[float], ...]:\n    \"\"\"\n    Gradient-descent training algorithm for Softmax regression, optimizing parameters with Cross Entropy loss.\n\n    Returns:\n        B : list[float], CxM updated parameter vector rounded to 4 floating points\n        losses : list[float], collected values of a Cross Entropy rounded to 4 floating points\n    \"\"\"\n\n    def softmax(z):\n        return np.exp(z) / np.sum(np.exp(z), axis=1, keepdims=True)\n\n    def accuracy(y_pred, y_true):\n        return (np.argmax(y_true, axis=1) == np.argmax(y_pred, axis=1)).sum() / len(y_true)\n\n    def ce_loss(y_pred, y_true):\n        true_labels_idx = np.argmax(y_true, axis=1)\n        return -np.sum(np.log(y_pred)[list(range(len(y_pred))),true_labels_idx])\n\n    y = y.astype(int)\n    C = y.max()+1 # we assume that classes start from 0\n    y = np.eye(C)[y]\n    X = np.hstack((np.ones((X.shape[0], 1)), X))\n    B = np.zeros((X.shape[1], C))\n    accuracies, losses = [], []\n\n    for epoch in range(iterations):\n        y_pred = softmax(X @ B)\n        B -= learning_rate * X.T @ (y_pred - y)\n        losses.append(round(ce_loss(y_pred, y), 4))\n        accuracies.append(round(accuracy(y_pred, y), 4))\n\n    return B.T.round(4).tolist(), losses", "test_cases": ["assert train_softmaxreg(np.array([[2.5257, 2.3333, 1.7730, 0.4106, -1.6648], [1.5101, 1.3023, 1.3198, 1.3608, 0.4638], [-2.0969, -1.3596, -1.0403, -2.2548, -0.3235], [-0.9666, -0.6068, -0.7201, -1.7325, -1.1281], [-0.3809, -0.2485, 0.1878, 0.5235, 1.3072], [0.5482, 0.3315, 0.1067, 0.3069, -0.3755], [-3.0339, -2.0196, -0.6546, -0.9033, 2.8918], [0.2860, -0.1265, -0.5220, 0.2830, -0.5865], [-0.2626, 0.7601, 1.8409, -0.2324, 1.8071], [0.3028, -0.4023, -1.2955, -0.1422, -1.7812]]), np.array([2, 3, 0, 0, 1, 3, 0, 1, 2, 1]), 0.03, 10) == ([[-0.0841, -0.5693, -0.3651, -0.2423, -0.5344, 0.0339], [0.2566, 0.0535, -0.2103, -0.4004, 0.2709, -0.1461], [-0.1318, 0.211, 0.3998, 0.523, -0.1001, 0.0545], [-0.0407, 0.3049, 0.1757, 0.1197, 0.3637, 0.0576]], [13.8629, 10.7202, 9.3164, 8.4943, 7.9134, 7.4599, 7.0856, 6.7655, 6.4853, 6.236]), \"test case failed: train_softmaxreg(np.array([[2.5257, 2.3333, 1.7730, 0.4106, -1.6648], [1.5101, 1.3023, 1.3198, 1.3608, 0.4638], [-2.0969, -1.3596, -1.0403, -2.2548, -0.3235], [-0.9666, -0.6068, -0.7201, -1.7325, -1.1281], [-0.3809, -0.2485, 0.1878, 0.5235, 1.3072], [0.5482, 0.3315, 0.1067, 0.3069, -0.3755], [-3.0339, -2.0196, -0.6546, -0.9033, 2.8918], [0.2860, -0.1265, -0.5220, 0.2830, -0.5865], [-0.2626, 0.7601, 1.8409, -0.2324, 1.8071], [0.3028, -0.4023, -1.2955, -0.1422, -1.7812]]), np.array([2, 3, 0, 0, 1, 3, 0, 1, 2, 1]), 0.03, 10)\"", "assert train_softmaxreg(np.array([[0.5, -1.2], [-0.3, 1.1], [0.8, -0.6]]), np.array([0, 1, 2]), 0.01, 10) == ([[-0.0011, 0.0145, -0.0921], [0.002, -0.0598, 0.1263], [-0.0009, 0.0453, -0.0342]], [3.2958, 3.2611, 3.2272, 3.1941, 3.1618, 3.1302, 3.0993, 3.0692, 3.0398, 3.011]), \"test case failed: train_softmaxreg(np.array([[0.5, -1.2], [-0.3, 1.1], [0.8, -0.6]]), np.array([0, 1, 2]), 0.01, 10)\""]}
{"id": 106, "difficulty": "hard", "category": "Machine Learning", "title": "Train Logistic Regression with Gradient Descent", "description": "Implement a gradient descent-based training algorithm for logistic regression. Your task is to compute model parameters using Binary Cross Entropy loss and return the optimized coefficients along with collected loss values over iterations(round to the 4th decimal).", "inputs": ["np.array([[1.0, 0.5], [-0.5, -1.5], [2.0, 1.5], [-2.0, -1.0]]), np.array([1, 0, 1, 0]), 0.01, 20"], "outputs": ["([0.0037, 0.0246, 0.0202], [2.7726, 2.7373, 2.7024, 2.6678, 2.6335, 2.5995, 2.5659, 2.5327, 2.4997, 2.4671, 2.4348, 2.4029, 2.3712, 2.3399, 2.3089, 2.2783, 2.2480, 2.2180, 2.1882, 2.1588])"], "reasoning": ["The function iteratively updates the logistic regression parameters using gradient descent and collects loss values over iterations."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "train_logreg", "starter_code": "def train_logreg(X: np.ndarray, y: np.ndarray, learning_rate: float, iterations: int) -> tuple[list[float], ...]:\n    \"\"\"\n    Gradient-descent training algorithm for logistic regression, optimizing parameters with Binary Cross Entropy loss.\n    \"\"\"", "reference_code": "def train_logreg(X: np.ndarray, y: np.ndarray, learning_rate: float, iterations: int) -> tuple[list[float], ...]:\n    \"\"\"\n    Gradient-descent training algorithm for logistic regression, optimizing parameters with Binary Cross Entropy loss.\n    \"\"\"\n    def sigmoid(x):\n        return 1 / (1 + np.exp(-x))\n\n    y = y.reshape(-1, 1)\n    X = np.hstack((np.ones((X.shape[0], 1)), X))\n    B = np.zeros((X.shape[1], 1))\n    losses = []\n\n    for _ in range(iterations):\n        y_pred = sigmoid(X @ B)\n        B -= learning_rate * X.T @ (y_pred - y)\n        loss = -np.sum(y * np.log(y_pred) + (1 - y) * np.log(1 - y_pred))\n        losses.append(round(loss, 4))\n\n    return B.flatten().round(4).tolist(), losses", "test_cases": ["assert train_logreg(np.array([[0.7674, -0.2341, -0.2341, 1.5792], [-1.4123, 0.3142, -1.0128, -0.9080], [-0.4657, 0.5425, -0.4694, -0.4634], [-0.5622, -1.9132, 0.2419, -1.7249], [-1.4247, -0.2257, 1.4656, 0.0675], [1.8522, -0.2916, -0.6006, -0.6017], [0.3756, 0.1109, -0.5443, -1.1509], [0.1968, -1.9596, 0.2088, -1.3281], [1.5230, -0.1382, 0.4967, 0.6476], [-1.2208, -1.0577, -0.0134, 0.8225]]), np.array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]), 0.001, 10) == ([-0.0097, 0.0286, 0.015, 0.0135, 0.0316], [6.9315, 6.9075, 6.8837, 6.8601, 6.8367, 6.8134, 6.7904, 6.7675, 6.7448, 6.7223]), \"tese case failed: train_logreg(np.array([[0.7674, -0.2341, -0.2341, 1.5792], [-1.4123, 0.3142, -1.0128, -0.9080], [-0.4657, 0.5425, -0.4694, -0.4634], [-0.5622, -1.9132, 0.2419, -1.7249], [-1.4247, -0.2257, 1.4656, 0.0675], [1.8522, -0.2916, -0.6006, -0.6017], [0.3756, 0.1109, -0.5443, -1.1509], [0.1968, -1.9596, 0.2088, -1.3281], [1.5230, -0.1382, 0.4967, 0.6476], [-1.2208, -1.0577, -0.0134, 0.8225]]), np.array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]), 0.001, 10)\"", "assert train_logreg(np.array([[ 0.76743473, 1.57921282, -0.46947439],[-0.23415337, 1.52302986, -0.23413696],[ 0.11092259, -0.54438272, -1.15099358],[-0.60063869, 0.37569802, -0.29169375],[-1.91328024, 0.24196227, -1.72491783],[-1.01283112, -0.56228753, 0.31424733],[-0.1382643 , 0.49671415, 0.64768854],[-0.46341769, 0.54256004, -0.46572975],[-1.4123037 , -0.90802408, 1.46564877],[ 0.0675282 , -0.2257763 , -1.42474819]]), np.array([1, 1, 0, 0, 0, 0, 1, 1, 0, 0]), 0.1, 10) == ([-0.2509, 0.9325, 1.6218, 0.6336], [6.9315, 5.5073, 4.6382, 4.0609, 3.6503, 3.3432, 3.1045, 2.9134, 2.7567, 2.6258]), \"test case failed: train_logreg(np.array([[ 0.76743473, 1.57921282, -0.46947439],[-0.23415337, 1.52302986, -0.23413696],[ 0.11092259, -0.54438272, -1.15099358],[-0.60063869, 0.37569802, -0.29169375],[-1.91328024, 0.24196227, -1.72491783],[-1.01283112, -0.56228753, 0.31424733],[-0.1382643 , 0.49671415, 0.64768854],[-0.46341769, 0.54256004, -0.46572975],[-1.4123037 , -0.90802408, 1.46564877],[ 0.0675282 , -0.2257763 , -1.42474819]]), np.array([1, 1, 0, 0, 0, 0, 1, 1, 0, 0]), 0.1, 10)\""]}
{"id": 107, "difficulty": "easy", "category": "Machine Learning", "title": "Implement Masked Self-Attention", "description": "Implement masked self-attention, a variation of the attention mechanism used in sequence modeling tasks such as text generation. Your task is to compute masked self-attention using query (Q), key (K), value (V) matrices and an attention mask.", "inputs": ["Q, K, V, mask"], "outputs": ["[[547. 490. 399. 495. 485. 439. 645. 393.]\n [547. 490. 399. 495. 485. 439. 645. 393.]\n [471. 472. 429. 538. 377. 450. 531. 362.]\n [471. 472. 429. 538. 377. 450. 531. 362.]\n [471. 472. 429. 538. 377. 450. 531. 362.]\n [471. 472. 429. 538. 377. 450. 531. 362.]]"], "reasoning": ["The function computes self-attention by applying a mask to restrict information flow, ensuring causal dependencies are maintained."], "import_code": "import numpy as np\n\ndef compute_qkv(X: np.ndarray, W_q: np.ndarray, W_k: np.ndarray, W_v: np.ndarray):\n    \"\"\"\n    Compute Query (Q), Key (K), and Value (V) matrices.\n    \"\"\"\n    Q = np.dot(X, W_q)\n    K = np.dot(X, W_k)\n    V = np.dot(X, W_v)\n    return Q, K, V", "output_constrains": "Return python list after reshaping by using numpy's tolist() method.", "entry_point": "masked_attention", "starter_code": "def masked_attention(Q: np.ndarray, K: np.ndarray, V: np.ndarray, mask: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute masked self-attention.\n    \"\"\"", "reference_code": "def masked_attention(Q: np.ndarray, K: np.ndarray, V: np.ndarray, mask: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute masked self-attention.\n    \"\"\"\n    d_k = Q.shape[1]\n    scores = np.matmul(Q, K.T) / np.sqrt(d_k)\n    scores = scores + mask  # Apply mask\n    attention_weights = np.exp(scores - np.max(scores, axis=1, keepdims=True))\n    attention_weights = attention_weights / np.sum(attention_weights, axis=1, keepdims=True)\n    return np.matmul(attention_weights, V).round(4).tolist()", "test_cases": ["np.random.seed(42)\nX = np.arange(48).reshape(6,8)\nX = np.random.permutation(X.flatten()).reshape(6, 8)\nmask = np.triu(np.ones((6, 6))*(-np.inf), k=1)\nW_q = np.random.randint(0,4,size=(8,8))\nW_k = np.random.randint(0,5,size=(8,8))\nW_v = np.random.randint(0,6,size=(8,8))\nQ, K, V = compute_qkv(X, W_q, W_k, W_v)\nassert masked_attention(Q, K, V, mask) == [[547.0, 490.0, 399.0, 495.0, 485.0, 439.0, 645.0, 393.0], [547.0, 490.0, 399.0, 495.0, 485.0, 439.0, 645.0, 393.0], [471.0, 472.0, 429.0, 538.0, 377.0, 450.0, 531.0, 362.0], [471.0, 472.0, 429.0, 538.0, 377.0, 450.0, 531.0, 362.0], [471.0, 472.0, 429.0, 538.0, 377.0, 450.0, 531.0, 362.0], [471.0, 472.0, 429.0, 538.0, 377.0, 450.0, 531.0, 362.0]]", "np.random.seed(42)\nX = np.arange(16).reshape(4,4)\nX = np.random.permutation(X.flatten()).reshape(4, 4)\nmask = np.triu(np.ones((4, 4))*(-np.inf), k=1)\nW_q = np.random.randint(0,4,size=(4,4))\nW_k = np.random.randint(0,5,size=(4,4))\nW_v = np.random.randint(0,6,size=(4,4))\nQ, K, V = compute_qkv(X, W_q, W_k, W_v)\nassert masked_attention(Q, K, V, mask) == [[52.0, 63.0, 48.0, 71.0], [103.0, 109.0, 46.0, 99.0], [103.0, 109.0, 46.0, 99.0], [103.0, 109.0, 46.0, 99.0]]"]}
{"id": 108, "difficulty": "easy", "category": "Machine Learning", "title": "Measure Disorder in Apple Colors", "description": "Implement a function that calculates the disorder in a basket of apples based on their colors, where each apple color is represented by an integer. The disorder must be 0 if all apples are the same color and must increase as the variety of colors increases. In particular:\n- [0,0,0,0] should yield 0.\n- [1,1,0,0] should have a higher disorder than [0,0,0,0].\n- [0,1,2,3] should have a higher disorder than [1,1,0,0].\n- [0,0,1,1,2,2,3,3] should have a higher disorder than [0,0,0,0,0,1,2,3].\nYou may use any method to measure disorder as long as these properties are satisfied.", "inputs": ["[1,1,0,0]"], "outputs": ["0.5"], "reasoning": ["In the basket [1,1,0,0], there are two distinct colors each appearing with equal frequency (0.5)."], "import_code": "", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.", "entry_point": "disorder", "starter_code": "def disorder(apples: list) -> float:\n    \"\"\"\n    Calculates a measure of disorder in a basket of apples based on their colors.\n    \"\"\"", "reference_code": "def disorder(apples: list) -> float:\n    \"\"\"\n    Calculates a measure of disorder in a basket of apples based on their colors.\n    \"\"\"\n\n    # One valid approach is to use the Gini impurity, defined as:\n    #  G = 1 - sum((count/total)^2 for each color)\n    # This method returns 0 for a basket with all apples of the same color and increases as the variety of colors increases.\n    # While this implementation uses the Gini impurity, any method that satisfies the following properties is acceptable:\n    #   1. A single color results in a disorder of 0.\n    #   2. Baskets with more distinct colors yield a higher disorder score.\n    #   3. The ordering constraints are maintained.\n\n    if not apples:\n        return 0.0\n    total = len(apples)\n    counts = {}\n    for color in apples:\n        counts[color] = counts.get(color, 0) + 1\n    impurity = 1.0\n    for count in counts.values():\n        p = count / total\n        impurity -= p * p\n    return round(impurity, 4)", "test_cases": ["assert disorder([0,0,0,0]) == 0.0, \"test case failed: disorder([0,0,0,0])\"", "assert disorder([1,1,0,0]) == 0.5, \"test case failed: disorder([1,1,0,0])\"", "assert disorder([0,1,2,3]) == 0.75, \"test case failed: disorder([0,1,2,3])\"", "assert disorder([0,0,1,1,2,2,3,3]) == 0.75, \"test case failed: disorder([0,0,1,1,2,2,3,3])\"", "assert disorder([0,0,0,0,0,1,2,3]) == 0.5625, \"test case failed: disorder([0,0,0,0,0,1,2,3])\""]}
{"id": 109, "difficulty": "medium", "category": "Machine Learning", "title": "Implement Layer Normalization for Sequence Data", "description": "Implement a function to perform Layer Normalization on an input tensor. Given a 3D array representing batch size, sequence length, and feature dimensions, normalize the data across the feature dimension for each sequence, then apply scaling and shifting parameters.", "inputs": ["layer_normalization(X = np.random.randn(2, 2, 3), gamma = np.ones(3).reshape(1, 1, -1), beta = np.zeros(3).reshape(1, 1, -1))"], "outputs": ["[[[-0.12092, 1.2807, -1.15978], [-1.3847, 0.94123, 0.44347]], [[0.02428, -1.23669, 1.21241], [1.41034, -0.79475, -0.61559]]]"], "reasoning": ["The function computes the mean and variance across the feature dimension (d_model=3) for each sequence, normalizes the input, then applies gamma=1 and beta=0, resulting in a normalized output with zero mean and unit variance scaled as is."], "import_code": "import numpy as np", "output_constrains": "The normalized X should be rounded to 5 decimal places and converted to a list using tolist() when returned.", "entry_point": "layer_normalization", "starter_code": "def layer_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, epsilon: float = 1e-5):", "reference_code": "def layer_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, epsilon: float = 1e-5):\n\n    mean = np.mean(X, axis=-1, keepdims=True)\n    variance = np.var(X, axis=-1, keepdims=True)\n    X_norm = (X - mean) / np.sqrt(variance + epsilon)\n    norm_X = gamma * X_norm + beta\n    return np.round(norm_X, 5).tolist()", "test_cases": ["assert layer_normalization(np.array([[[0.242, -1.913, -1.725], [-0.562, -1.013, 0.314]], [[-0.908, -1.412, 1.466], [-0.226, 0.068, -1.425]]]), np.array([[[1., 1., 1.]]]), np.array([[[0., 0., 0.]]])) == [[[1.40981, -0.80136, -0.60846], [-0.25714, -1.07574, 1.33288]], [[-0.49672, -0.89835, 1.39507], [0.46714, 0.92241, -1.38955]]]", "assert layer_normalization(np.array([[[-0.544, 0.111, -1.151, 0.376], [-0.601, -0.292, -0.602, 1.852], [-0.013, -1.058, 0.823, -1.221]], [[0.209, -1.96, -1.328, 0.197], [0.738, 0.171, -0.116, -0.301], [-1.479, -0.72, -0.461, 1.057]]]), np.array([[[1., 1., 1., 1.]]]), np.array([[[0., 0., 0., 0.]]])) == [[[-0.40765, 0.6957, -1.43015, 1.1421], [-0.67306, -0.37175, -0.67403, 1.71885], [0.42738, -0.83334, 1.43595, -1.02999]], [[0.97825, -1.30451, -0.63936, 0.96562], [1.5653, 0.12217, -0.6083, -1.07917], [-1.17069, -0.34662, -0.06542, 1.58272]]]", "assert layer_normalization(np.array([[[0.344, -1.763, 0.324, -0.385], [-0.677, 0.612, 1.031, 0.931], [-0.839, -0.309, 0.331, 0.976]], [[-0.479, -0.186, -1.106, -1.196], [0.813, 1.356, -0.072, 1.004], [0.362, -0.645, 0.361, 1.538]]]), np.array([[[0.5, 0.5, 0.5, 0.5]]]), np.array([[[1., 1., 1., 1.]]])) == [[[1.41697, 0.1865, 1.40529, 0.99124], [0.15654, 1.10092, 1.4079, 1.33464], [0.35485, 0.74396, 1.21383, 1.68737]], [[1.31031, 1.65635, 0.56982, 0.46353], [1.03585, 1.5515, 0.19543, 1.21723], [0.97283, 0.32146, 0.97219, 1.73352]]]"]}
{"id": 110, "difficulty": "medium", "category": "NLP", "title": "Evaluate Translation Quality with METEOR Score", "description": "Develop a function to compute the METEOR score for evaluating machine translation quality. Given a reference translation and a candidate translation, calculate the score based on unigram matches, precision, recall, F-mean, and a penalty for word order fragmentation.", "inputs": ["meteor_score(reference = 'Rain falls gently from the sky', candidate = 'Gentle rain drops from the sky')"], "outputs": ["0.625"], "reasoning": ["The function identifies 4 unigram matches ('rain', 'gently'/'gentle', 'from', 'sky'), computes precision (4/6) and recall (4/5), calculates an F-mean, and then apply a small penalty for two chunks."], "import_code": "import numpy as np\nfrom collections import Counter", "output_constrains": "Your function should return a float value rounded to 3 decimal places.", "entry_point": "meteor_score", "starter_code": "def meteor_score(reference, candidate, alpha=0.9, beta=3, gamma=0.5):", "reference_code": "def meteor_score(reference, candidate, alpha=0.9, beta=3, gamma=0.5):\n    if not reference or not candidate:\n        raise ValueError(\"Reference and candidate cannot be empty\")\n    \n    # Tokenize and count\n    ref_tokens = reference.lower().split()\n    cand_tokens = candidate.lower().split()\n\n    # Counter for unigram for reference and candidate \n    ref_counts = Counter(ref_tokens) \n    cand_counts = Counter(cand_tokens)\n    \n    # Calculate matches\n    num_matches = sum((ref_counts & cand_counts).values()) # Number of matching words in candidate and reference \n    ref_len = len(ref_tokens)\n    cand_len = len(cand_tokens)  \n\n    # Unigram Precision and Recall \n    precision = num_matches / cand_len if cand_len > 0 else 0 # Avoiding Division by zero\n    recall = num_matches / ref_len if ref_len > 0 else 0 # Avoiding Division by zero \n    \n    if num_matches == 0:\n        return 0.0\n    \n    fmean = (precision * recall) / (alpha * precision + (1 - alpha) * recall)\n\n    # Chunk calculation \n    matched_positions = []\n    ref_positions = {}  # Store positions of words in reference\n    used_positions = set()  # Track already used indices\n\n    # Populate reference positions for word alignment tracking\n    for i, word in enumerate(ref_tokens):\n        ref_positions.setdefault(word, []).append(i)\n\n    # Determine the sequence of matched positions in reference\n    for word in cand_tokens:\n        if word in ref_positions:\n            for pos in ref_positions[word]:\n                if pos not in used_positions:\n                    matched_positions.append(pos)\n                    used_positions.add(pos)\n                    break  # Ensure each match is used only once\n\n    # Count chunks by detecting breaks in position sequence\n    num_chunks = 1 if matched_positions else 0\n    for i in range(1, len(matched_positions)):\n        if matched_positions[i] != matched_positions[i - 1] + 1:\n            num_chunks += 1  # Break in sequence \u00e2\u0086\u0092 new chunk\n\n    # Fragmentation penalty\n    penalty = gamma * ((num_chunks / num_matches) ** beta) if num_matches > 0 else 0\n    \n    # Final score\n    return round(fmean * (1 - penalty), 3) # Rounding to 3 Decimal places", "test_cases": ["assert meteor_score('The dog barks at the moon', 'The dog barks at the moon') == 0.998", "assert meteor_score('Rain falls gently from the sky', 'Gentle rain drops from the sky') == 0.625", "assert meteor_score('The sun shines brightly', 'Clouds cover the sky') == 0.125", "assert meteor_score('Birds sing in the trees', 'Birds in the trees sing') == 0.892\n\nassert meteor_score(\"The cat sits on the mat\", \"The cat on the mat sits\") == 0.938"]}
{"id": 111, "difficulty": "medium", "category": "NLP", "title": "Compute Pointwise Mutual Information", "description": "Implement a function to compute the Pointwise Mutual Information (PMI) given the joint occurrence count of two events, their individual counts, and the total number of samples. PMI measures how much the actual joint occurrence of events differs from what we would expect by chance.", "inputs": ["compute_pmi(joint_counts = 50, total_counts_x = 200, total_counts_y = 300, total_samples = 1000)"], "outputs": ["-0.263"], "reasoning": ["The PMI calculation compares the actual joint probability (50/1000 = 0.05) to the product of the individual probabilities (200/1000 * 300/1000 = 0.06). Thus, PMI = log\u2082(0.05 / (0.2 * 0.3)) \u2248 -0.263, indicating the events co-occur slightly less than expected by chance."], "import_code": "import numpy as np", "output_constrains": "Your function should return a float value rounded to 3 decimal places.", "entry_point": "compute_pmi", "starter_code": "def compute_pmi(joint_counts, total_counts_x, total_counts_y, total_samples):", "reference_code": "def compute_pmi(joint_counts, total_counts_x, total_counts_y, total_samples):\n \n    if not all(isinstance(x, (int, float)) for x in [joint_counts, total_counts_x, total_counts_y, total_samples]):\n        raise ValueError(\"All inputs must be numeric\")\n        \n    if any(x < 0 for x in [joint_counts, total_counts_x, total_counts_y, total_samples]):\n        raise ValueError(\"Counts cannot be negative\")\n        \n    if total_samples == 0:\n        raise ValueError(\"Total samples cannot be zero\")\n        \n    if joint_counts > min(total_counts_x, total_counts_y):\n        raise ValueError(\"Joint counts cannot exceed individual counts\")\n        \n    if any(x > total_samples for x in [total_counts_x, total_counts_y]):\n        raise ValueError(\"Individual counts cannot exceed total samples\")\n  \n    p_x = total_counts_x / total_samples\n    p_y = total_counts_y / total_samples\n    p_xy = joint_counts / total_samples\n    \n    # Handle edge cases where probabilities are zero\n    if p_xy == 0 or p_x == 0 or p_y == 0:\n        return float('-inf')\n  \n    pmi = np.log2(p_xy / (p_x * p_y))\n    \n    return round(pmi, 3)", "test_cases": ["assert compute_pmi(10, 50, 50, 200) == -0.322", "assert compute_pmi(100, 500, 500, 1000) == -1.322", "assert compute_pmi(100, 400, 600, 1200) == -1", "assert compute_pmi(100, 100, 100, 100) == 0.0", "assert compute_pmi(25, 50, 50, 100) == 0.0", "assert compute_pmi(10, 50, 50, 100) == -1.322", "assert compute_pmi(0, 50, 50, 100) == float('-inf')"]}
{"id": 112, "difficulty": "easy", "category": "Data Preprocessing", "title": "Min-Max Normalization of Feature Values", "description": "Implement a function that performs Min-Max Normalization on a list of integers, scaling all values to the range [0, 1]. Min-Max normalization helps ensure that all features contribute equally to a model by scaling them to a common range.", "inputs": ["min_max(x = [1, 2, 3, 4, 5])"], "outputs": ["[0.0, 0.25, 0.5, 0.75, 1.0]"], "reasoning": ["The minimum value is 1 and the maximum is 5. Each value is scaled using the formula (x - min) / (max - min)."], "import_code": "", "output_constrains": "Your function should return a list of floats rounded to 4 decimal places.", "entry_point": "min_max", "starter_code": "def min_max(x: list[int]) -> list[float]:", "reference_code": "def min_max(x: list[int]) -> list[float]:\n    largest = max(x)\n    smallest = min(x)\n    if largest == smallest:\n        return [0.0] * len(x)\n    for i in range(len(x)):\n        x[i] = round((x[i] - smallest) / (largest - smallest), 4)\n    return [round(i, 4) for i in x]", "test_cases": ["assert min_max([1, 2, 3, 4, 5]) == [0.0, 0.25, 0.5, 0.75, 1.0]", "assert min_max([30, 45, 56, 70, 88]) == [0.0, 0.2586, 0.4483, 0.6897, 1.0]", "assert min_max([5, 5, 5, 5]) == [0.0, 0.0, 0.0, 0.0]", "assert min_max([-3, -2, -1, 0, 1, 2, 3]) == [0.0, 0.1667, 0.3333, 0.5, 0.6667, 0.8333, 1.0]", "assert min_max([1,]) == [0.0]"]}
{"id": 113, "difficulty": "easy", "category": "Deep Learning", "title": "Implement a Simple Residual Block with Shortcut Connection", "description": "Implement a function that creates a simple residual block using NumPy. The block should take a 1D input array, process it through two weight layers (using matrix multiplication), apply ReLU activations, and add the original input via a shortcut connection before a final ReLU activation.", "inputs": ["residual_block(x = np.array([1.0, 2.0]), w1 = np.array([[1.0, 0.0], [0.0, 1.0]]), w2 = np.array([[0.5, 0.0], [0.0, 0.5]]))"], "outputs": ["[1.5, 3.0]"], "reasoning": ["The input x is [1.0, 2.0]. First, compute w1 @ x = [1.0, 2.0], apply ReLU to get [1.0, 2.0]. Then, compute w2 @ [1.0, 2.0] = [0.5, 1.0]. Add the shortcut x to get [0.5 + 1.0, 1.0 + 2.0] = [1.5, 3.0]. Final ReLU gives [1.5, 3.0]."], "import_code": "import numpy as np", "output_constrains": "The final output should be rounded to 4 decimal places and converted to a list using tolist() when returned.", "entry_point": "residual_block", "starter_code": "def residual_block(x: np.ndarray, w1: np.ndarray, w2: np.ndarray):", "reference_code": "def residual_block(x: np.ndarray, w1: np.ndarray, w2: np.ndarray):\n    # First weight layer\n    y = np.dot(w1, x)\n    # First ReLU\n    y = np.maximum(0, y)\n    # Second weight layer\n    y = np.dot(w2, y)\n    # Add shortcut connection (x + F(x))\n    y = y + x\n    # Final ReLU\n    y = np.maximum(0, y)\n    return np.round(y, 4).tolist()", "test_cases": ["assert residual_block(np.array([1.0, 2.0]), np.array([[1.0, 0.0], [0.0, 1.0]]), np.array([[0.5, 0.0], [0.0, 0.5]])) == [1.5, 3.0]", "assert residual_block(np.array([-1.0, 2.0]), np.array([[1.0, 0.0], [0.0, 1.0]]), np.array([[0.5, 0.0], [0.0, 0.5]])) == [0.,3.]", "assert residual_block(np.array([0.0, 0.0]), np.array([[1.0, 0.0], [0.0, 1.0]]), np.array([[0.5, 0.0], [0.0, 0.5]])) == [0., 0.]", "assert residual_block(np.array([5.0, 3.0]), np.array([[2.0, 0.0], [2.0, 1.0]]), np.array([[0.5, 0.0], [1.0, 0.5]])) == [10.0, 19.5]", "assert residual_block(np.array([-5.0, 3.0]), np.array([[2.0, 0.0], [2.0, 1.0]]), np.array([[0.5, 0.0], [1.0, 0.5]])) == [0.0, 3.0]"]}
{"id": 114, "difficulty": "easy", "category": "Deep Learning", "title": "Implement Global Average Pooling", "description": "Implement a function that performs Global Average Pooling on a 3D NumPy array representing feature maps from a convolutional layer. The function should take an input of shape (height, width, channels) and return a 1D array of shape (channels,), where each element is the average of all values in the corresponding feature map.", "inputs": ["global_avg_pool(x = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]))"], "outputs": ["[5.5, 6.5, 7.5]"], "reasoning": ["For each channel, compute the average of all elements. For channel 0: (1+4+7+10)/4 = 5.5, for channel 1: (2+5+8+11)/4 = 6.5, for channel 2: (3+6+9+12)/4 = 7.5."], "import_code": "import numpy as np", "output_constrains": "", "entry_point": "global_avg_pool", "starter_code": "def global_avg_pool(x: np.ndarray):", "reference_code": "def global_avg_pool(x: np.ndarray):\n    return np.round(np.mean(x, axis=(0, 1)), 4).tolist()", "test_cases": ["assert global_avg_pool(np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])) == [5.5,6.5,7.5]", "assert global_avg_pool(np.array([[[100, 200]]])) == [100.0, 200.0]", "assert global_avg_pool(np.ones((3, 3, 1))) == [1.0]", "assert global_avg_pool(np.array([[[-1, -2], [1, 2]], [[3, 4], [-3, -4]]])) == [0.0, 0.0]", "assert global_avg_pool(np.array([[[-1, -2], [1, 2]], [[3, 4], [-3, 4]]])) == [0.0, 2.0]"]}
{"id": 115, "difficulty": "easy", "category": "Deep Learning", "title": "Implement Batch Normalization for BCHW Input", "description": "Implement a function that performs Batch Normalization on a 4D NumPy array representing a batch of feature maps in the BCHW format (batch, channels, height, width). The function should normalize the input across the batch and spatial dimensions for each channel, then apply scale (gamma) and shift (beta) parameters. Use the provided epsilon value to ensure numerical stability.", "inputs": ["batch_normalization(X = np.array([[[[ 0.4967, -0.1383], [ 0.6477,  1.523 ]], [[-0.2342, -0.2341], [ 1.5792,  0.7674]]], [[[-0.4695,  0.5426], [-0.4634, -0.4657]], [[ 0.242 , -1.9133], [-1.7249, -0.5623]]]]), gamma = np.array([[[[1.]], [[1.]]]]), beta = np.array([[[[0.]], [[0.]]]]))"], "outputs": ["[[[[0.4286, -0.5178], [0.6536, 1.9582]], [[0.0235, 0.0236], [1.6735, 0.9349]]], [[[-1.0114, 0.497], [-1.0023, -1.0058]], [[0.4568, -1.5043], [-1.3329, -0.275]]]]"], "reasoning": ["The input X is a 2x2x2x2 array. For each channel, compute the mean and variance across the batch (B), height (H), and width (W) dimensions. Normalize X using (X - mean) / sqrt(variance + epsilon), then scale by gamma and shift by beta. The output matches the expected normalized values."], "import_code": "import numpy as np", "output_constrains": "The final output should be rounded to 4 decimal places and converted to a list using tolist() when returned.", "entry_point": "batch_normalization", "starter_code": "def batch_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, epsilon: float = 1e-5):", "reference_code": "def batch_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, epsilon: float = 1e-5):\n    # Compute mean and variance across the batch and spatial dimensions\n    mean = np.mean(X, axis=(0, 2, 3), keepdims=True)  # Mean over (B, H, W)\n    variance = np.var(X, axis=(0, 2, 3), keepdims=True)  # Variance over (B, H, W)\n    # Normalize\n    X_norm = (X - mean) / np.sqrt(variance + epsilon)\n    # Scale and shift\n    norm_X = gamma * X_norm + beta\n    return np.round(norm_X, 4).tolist()", "test_cases": ["assert batch_normalization(np.array([[[[0.4967, -0.1383], [0.6477, 1.523]], [[-0.2342, -0.2341], [1.5792, 0.7674]]], [[[-0.4695, 0.5426], [-0.4634, -0.4657]], [[0.242, -1.9133], [-1.7249, -0.5623]]]]), np.ones(2).reshape(1, 2, 1, 1), np.zeros(2).reshape(1, 2, 1, 1)) == [[[[0.4286, -0.5178], [0.6536, 1.9582]], [[0.0235, 0.0236], [1.6735, 0.9349]]], [[[-1.0114, 0.497], [-1.0023, -1.0058]], [[0.4568, -1.5043], [-1.3329, -0.275]]]]", "assert batch_normalization(np.array([[[[2.7068, 0.6281], [0.908, 0.5038]], [[0.6511, -0.3193], [-0.8481, 0.606]]], [[[-2.0182, 0.7401], [0.5288, -0.589]], [[0.1887, -0.7589], [-0.9332, 0.9551]]]]), np.ones(2).reshape(1, 2, 1, 1), np.zeros(2).reshape(1, 2, 1, 1)) == [[[[1.8177, 0.161], [0.3841, 0.062]], [[1.0043, -0.3714], [-1.121, 0.9403]]], [[[-1.948, 0.2503], [0.0819, -0.809]], [[0.3488, -0.9946], [-1.2417, 1.4352]]]]", "assert batch_normalization(np.array([[[[2.7068, 0.6281], [0.908, 0.5038]], [[0.6511, -0.3193], [-0.8481, 0.606]]], [[[-2.0182, 0.7401], [0.5288, -0.589]], [[0.1887, -0.7589], [-0.9332, 0.9551]]]]), np.ones(2).reshape(1, 2, 1, 1) * 0.5, np.ones(2).reshape(1, 2, 1, 1)) == [[[[1.9089, 1.0805], [1.1921, 1.031]], [[1.5021, 0.8143], [0.4395, 1.4702]]], [[[0.026, 1.1251], [1.0409, 0.5955]], [[1.1744, 0.5027], [0.3792, 1.7176]]]]"]}
{"id": 116, "difficulty": "easy", "category": "calculus", "title": "Derivative of a Polynomial", "description": "Implement a function that computes the derivative of a polynomial term of the form `c * x^n` at a given point `x`, where `c` is a coefficient and `n` is the exponent. The function should return the value of the derivative, accounting for the coefficient in the power rule. This is useful for understanding how polynomials change at specific points in machine learning optimization problems.", "inputs": ["poly_term_derivative(c = 2.0, x = 3.0, n = 2.0)"], "outputs": ["12.0"], "reasoning": ["For the term 2 * x^2, the derivative is 2 * 2 * x^(2-1) = 4 * x. At x = 3, this evaluates to 4 * 3 = 12.0."], "import_code": "", "output_constrains": "Your function should return a float value rounded to 4 decimal places.", "entry_point": "poly_term_derivative", "starter_code": "def poly_term_derivative(c: float, x: float, n: float) -> float:", "reference_code": "def poly_term_derivative(c: float, x: float, n: float) -> float:\n    if n == 0.0:\n        return 0.0\n    return round(c * n * (x ** (n - 1)), 4)", "test_cases": ["assert poly_term_derivative(2.0, 3.0, 2.0) == 12.0", "assert poly_term_derivative(1.5, 4.0, 0.0) == 0.0", "assert poly_term_derivative(3.0, 2.0, 3.0) == 36.0", "assert poly_term_derivative(0.5, 5.0, 1.0) == 0.5", "assert poly_term_derivative(2.0, 3.0, 4.0) == 216.0", "assert poly_term_derivative(2.0, 3.0, 0.0) == 0.0"]}
{"id": 117, "difficulty": "medium", "category": "Linear Algebra", "title": "Compute Orthonormal Basis for 2D Vectors", "description": "Implement a function that computes an orthonormal basis for the subspace spanned by a list of 2D vectors using the Gram-Schmidt process. The function should take a list of 2D vectors and a tolerance value (tol) to determine linear independence, returning a list of orthonormal vectors (unit length and orthogonal to each other) that span the same subspace. This is a fundamental concept in linear algebra with applications in machine learning, such as feature orthogonalization.", "inputs": ["orthonormal_basis(vectors = [[1, 0], [1, 1]])"], "outputs": ["[[1., 0.], [0., 1.]]"], "reasoning": ["Start with [1, 0], normalize to [1, 0]. For [1, 1], subtract its projection onto [1, 0] (which is [1, 0]), leaving [0, 1]. Check if norm > 1e-10 (it is 1), then normalize to [0, 1]. The result is an orthonormal basis."], "import_code": "import numpy as np", "output_constrains": "Every basis within your return list should be rounded to 4 decimal places and converted to a list using tolist() when returned.", "entry_point": "orthonormal_basis", "starter_code": "def orthonormal_basis(vectors: list[list[float]], tol: float = 1e-10):", "reference_code": "def orthonormal_basis(vectors: list[list[float]], tol: float = 1e-10):\n    basis = []\n    for v in vectors:\n        v = np.array(v, dtype=float)\n        for b in basis:\n            v = v - np.dot(v, b) * b\n        norm = np.sqrt(np.dot(v, v))\n        if norm > tol:\n            v = v / norm\n            basis.append(v)\n    return [np.round(b, 4).tolist() for b in basis]", "test_cases": ["assert orthonormal_basis([[1, 0], [1, 1]]) == [[1.0, 0.0], [0., 1.]]", "assert orthonormal_basis([[2, 0], [4, 0]], tol=1e-10) == [[1.0, 0.0]]", "assert orthonormal_basis([[1, 1], [1, -1]], tol=1e-5) == [[0.7071, 0.7071], [0.7071, -0.7071]]", "assert orthonormal_basis([[0, 0]], tol=1e-10) == []", "assert orthonormal_basis([[1, 3], [3, 1]], tol=1e-10) == [[0.3162, 0.9487], [0.9487, -0.3162]]", "assert orthonormal_basis([[3, 3], [3, 1]], tol=1e-10) == [[0.7071, 0.7071], [0.7071, -0.7071]]"]}
{"id": 118, "difficulty": "easy", "category": "Linear Algebra", "title": "Compute the Cross Product of Two 3D Vectors", "description": "Implement a function to compute the cross product of two 3-dimensional vectors. The cross product of two vectors results in a third vector that is perpendicular to both and follows the right-hand rule. This concept is fundamental in physics, engineering, and 3D graphics.", "inputs": ["cross_product(a = [1, 0, 0], b = [0, 1, 0])"], "outputs": ["[0, 0, 1]"], "reasoning": ["The cross product of two orthogonal unit vectors [1, 0, 0] and [0, 1, 0] is [0, 0, 1], pointing in the positive z-direction as per the right-hand rule."], "import_code": "import numpy as np", "output_constrains": "The final output should be rounded to 4 decimal places and converted to a list using tolist() when returned.", "entry_point": "cross_product", "starter_code": "def cross_product(a, b):", "reference_code": "def cross_product(a, b):\n    a = np.array(a)\n    b = np.array(b)\n\n    if a.shape != (3,) or b.shape != (3,):\n        raise ValueError(\"Both input vectors must be of length 3.\")\n\n    cross = np.array([\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ])\n    return np.round(cross, 4).tolist()", "test_cases": ["assert cross_product([1, 0, 0], [0, 1, 0]) == [0, 0, 1]", "assert cross_product([0, 1, 0], [0, 0, 1]) == [1, 0, 0]", "assert cross_product([1, 2, 3], [4, 5, 6]) == [-3, 6, -3]", "assert cross_product([1, 0, 0], [1, 0, 0]) == [0, 0, 0]", "assert cross_product([1, 2, 3], [4, 5, 6]) == [-3, 6, -3]", "assert cross_product([12, 2, 3], [4, 45, 6]) == [-123, -60, 532]", "assert cross_product([1.2, 2.3, 4.4], [-4, 4, -4]) == [-26.8, -12.8, 14.0]"]}
{"id": 119, "difficulty": "medium", "category": "Linear Algebra", "title": "Solve System of Linear Equations Using Cramer's Rule", "description": "Implement a function to solve a system of linear equations $Ax = b$ using Cramer's Rule. The function should take a square coefficient matrix $A$ and a constant vector $b$, and return the solution vector $x$. If the system has no unique solution (i.e., the determinant of $A$ is zero), return -1.", "inputs": ["cramers_rule(A = [[2, -1, 3], [4, 2, 1], [-6, 1, -2]], b = [5, 10, -3])"], "outputs": ["[0.1667 3.3333 2.6667]"], "reasoning": ["We compute the determinant of A and then replace each column with vector b to compute the determinants of modified matrices. These are then used in the formula $x_i = \frac{\\det(A_i)}{\\det(A)}$ to get the solution."], "import_code": "import numpy as np", "output_constrains": "Make sure all valid results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "cramers_rule", "starter_code": "def cramers_rule(A, b):", "reference_code": "def cramers_rule(A, b):\n    A = np.array(A, dtype=float)\n    b = np.array(b, dtype=float)\n\n    n, m = A.shape\n    if n != m or b.shape[0] != n:\n        return -1\n\n    det_A = np.linalg.det(A)\n    if np.isclose(det_A, 0):\n        return -1\n\n    x = np.zeros(n)\n    for i in range(n):\n        A_mod = A.copy()\n        A_mod[:, i] = b\n        det_A_mod = np.linalg.det(A_mod)\n        x[i] = det_A_mod / det_A\n\n    return np.round(x, 4).tolist()", "test_cases": ["assert cramers_rule([[2, -1, 3], [4, 2, 1], [-6, 1, -2]], [5, 10, -3]) == [0.1667, 3.3333, 2.6667]", "assert cramers_rule([[1, 2], [3, 4]], [5, 6]) == [-4.,4.5]", "assert cramers_rule([[1, 2], [2, 4]], [3, 6]) == -1"]}
{"id": 120, "difficulty": "easy", "category": "Statistics", "title": "Bhattacharyya Distance Between Two Distributions", "description": "Implement a function to calculate the Bhattacharyya distance between two probability distributions. The function should take two lists representing discrete probability distributions `p` and `q`, and return the Bhattacharyya distance rounded to 4 decimal places. If the inputs have different lengths or are empty, return 0.0.", "inputs": ["bhattacharyya_distance(p = [0.1, 0.2, 0.3, 0.4], q = [0.4, 0.3, 0.2, 0.1])"], "outputs": ["0.1166"], "reasoning": ["The Bhattacharyya coefficient is calculated as the sum of element-wise square roots of the product of p and q, giving BC = 0.8898. The distance is then -log(0.8898) = 0.1166."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.", "entry_point": "bhattacharyya_distance", "starter_code": "def bhattacharyya_distance(p: list[float], q: list[float]) -> float:", "reference_code": "def bhattacharyya_distance(p: list[float], q: list[float]) -> float:\n    if len(p) != len(q):\n        return 0.0\n\n    p, q = np.array(p), np.array(q)\n    BC = np.sum(np.sqrt(p * q))\n    DB = -np.log(BC)\n    return round(DB, 4)", "test_cases": ["assert bhattacharyya_distance([0.1, 0.2, 0.3, 0.4], [0.4, 0.3, 0.2, 0.1]) == 0.1166", "assert bhattacharyya_distance([0.7, 0.2, 0.1], [0.4, 0.3, 0.3]) == 0.0541", "assert bhattacharyya_distance([], [0.5, 0.4, 0.1]) == 0.0", "assert bhattacharyya_distance([0.6, 0.4], [0.1, 0.7, 0.2]) == 0.0", "assert bhattacharyya_distance([0.6, 0.2, 0.1, 0.1], [0.1, 0.2, 0.3, 0.4]) == 0.2007"]}
{"id": 121, "difficulty": "easy", "category": "Linear Algebra", "title": "Vector Element-wise Sum", "description": "Write a Python function that computes the element-wise sum of two vectors. The function should return a new vector representing the resulting sum if the operation is valid, or -1 if the vectors have incompatible dimensions. Two vectors (lists) can be summed element-wise only if they are of the same length.", "inputs": ["vector_sum(a = [1, 3], b = [4, 5])"], "outputs": ["[5, 8]"], "reasoning": ["Element-wise sum: [1+4, 3+5] = [5, 8]."], "import_code": "", "output_constrains": "", "entry_point": "vector_sum", "starter_code": "def vector_sum(a: list[int|float], b: list[int|float]) -> list[int|float]:", "reference_code": "def vector_sum(a: list[int|float], b: list[int|float]) -> list[int|float]:\n    if len(a) != len(b):\n        return -1\n    return [a[i] + b[i] for i in range(len(a))]", "test_cases": ["assert vector_sum([1, 2, 3], [4, 5, 6]) == [5, 7, 9]", "assert vector_sum([1, 2], [1, 2, 3]) == -1", "assert vector_sum([1.5, 2.5, 3.0], [2, 1, 4]) == [3.5, 3.5, 7.0]"]}
{"id": 122, "difficulty": "hard", "category": "Reinforcement Learning", "title": "Policy Gradient with REINFORCE", "description": "Implement the policy gradient estimator using the REINFORCE algorithm. The policy is parameterized by a 2D NumPy array `theta` of shape `(num_states, num_actions)`. The policy for each state is computed via softmax over `theta[s, :]`. Given a list of episodes (each a list of (state, action, reward) tuples), compute the average gradient of the log-policy multiplied by the return at each time step.", "inputs": ["compute_policy_gradient(theta = np.zeros((2,2)), episodes = [[(0,1,0), (1,0,1)], [(0,0,0)]])"], "outputs": ["[[-0.25, 0.25], [0.25, -0.25]]"], "reasoning": ["Episode 1 contributes a positive gradient from reward 1 at t=1; episode 2 adds zero. Result is averaged across episodes."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "compute_policy_gradient", "starter_code": "def compute_policy_gradient(theta: np.ndarray, episodes: list[list[tuple[int, int, float]]]):", "reference_code": "def compute_policy_gradient(theta: np.ndarray, episodes: list[list[tuple[int, int, float]]]):\n    def softmax(x):\n        x = x - np.max(x)\n        exps = np.exp(x)\n        return exps / np.sum(exps)\n\n    grad = np.zeros_like(theta)\n    for episode in episodes:\n        rewards = [step[2] for step in episode]\n        returns = np.cumsum(rewards[::-1])[::-1]\n        for t, (s, a, _), G in zip(range(len(episode)), episode, returns):\n            probs = softmax(theta[s])\n            grad_log_pi = np.zeros_like(theta)\n            grad_log_pi[s, :] = -probs\n            grad_log_pi[s, a] += 1\n            grad += grad_log_pi * G\n    return np.round(grad / len(episodes), 4).tolist()", "test_cases": ["assert compute_policy_gradient(np.zeros((2,2)), [[(0,1,0), (1,0,1)], [(0,0,0)]]) == [[-0.25, 0.25], [0.25, -0.25]]", "assert compute_policy_gradient(np.zeros((2,2)), [[(0,0,0), (0,1,0)], [(1,1,0)]]) == [[0.0, 0.0], [0.0, 0.0]]", "assert compute_policy_gradient(np.zeros((2,2)), [[(1,0,1), (1,1,1)], [(1,0,0)]]) == [[0.0, 0.0], [0.25, -0.25]]"]}
{"id": 123, "difficulty": "easy", "category": "Deep Learning", "title": "Calculate Computational Efficiency of MoE", "description": "Calculate the computational cost savings of an MoE layer compared to a dense layer, as discussed in the paper 'Outrageously Large Neural Networks: The Sparsely-Gated Mixture-of-Experts Layer.' Given the number of experts, sparsity (number of active experts), and input/output dimensions, compute the floating-point operations (FLOPs) for both and determine the savings percentage.", "inputs": ["compute_efficiency(n_experts = 1000, k_active = 2, d_in = 512, d_out = 512)"], "outputs": ["99.8"], "reasoning": ["Dense layer FLOPs: 1000 * 512 * 512 = 262,144,000. MoE FLOPs: 2 * 512 * 512 = 524,288. Savings: ((262,144,000 - 524,288) / 262,144,000) x 100 \u2248 99.8%."], "import_code": "", "output_constrains": "Make sure all results are rounded to the nearest 1th decimal.", "entry_point": "compute_efficiency", "starter_code": "def compute_efficiency(n_experts, k_active, d_in, d_out):", "reference_code": "def compute_efficiency(n_experts, k_active, d_in, d_out):\n    dense_flops = n_experts * d_in * d_out\n    moe_flops = k_active * d_in * d_out\n    savings = (dense_flops - moe_flops) / dense_flops * 100\n    return round(savings, 1)", "test_cases": ["assert compute_efficiency(1000, 2, 512, 512) == 99.8", "assert compute_efficiency(10, 2, 256, 256) == 80.0", "assert compute_efficiency(100, 4, 512, 512) == 96.0"]}
{"id": 124, "difficulty": "medium", "category": "Deep Learning", "title": "Implement the Noisy Top-K Gating Function", "description": "Implement the Noisy Top-K gating mechanism used in Mixture-of-Experts (MoE) models. Given an input matrix, weight matrices, pre-sampled noise, and a sparsity constraint k, compute the final gating probabilities matrix.", "inputs": ["noisy_topk_gating(X = np.array([[1.0, 2.0]]), W_g = np.array([[1.0, 0.0], [0.0, 1.0]]), W_noise = np.array([[0.5, 0.5], [0.5, 0.5]]), N = np.array([[1.0, -1.0]]), k = 2)"], "outputs": ["[[0.917, 0.0825]]"], "reasoning": ["This example demonstrates that the gating function produces a sparse softmax output, favoring the higher gate after noise perturbation."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "noisy_topk_gating", "starter_code": "def noisy_topk_gating(\n    X: np.ndarray,\n    W_g: np.ndarray,\n    W_noise: np.ndarray,\n    N: np.ndarray,\n    k: int\n):", "reference_code": "def noisy_topk_gating(\n    X: np.ndarray,\n    W_g: np.ndarray,\n    W_noise: np.ndarray,\n    N: np.ndarray,\n    k: int\n):\n    H_base = X @ W_g\n    H_noise = X @ W_noise\n    softplus = np.log1p(np.exp(H_noise))\n    H = H_base + N * softplus\n\n    def top_k_masked(row, k):\n        mask = np.full_like(row, -np.inf)\n        top_idx = np.argsort(row)[-k:]\n        mask[top_idx] = row[top_idx]\n        return mask\n\n    masked_H = np.vstack([top_k_masked(row, k) for row in H])\n    exps = np.exp(masked_H - np.max(masked_H, axis=1, keepdims=True))\n    return np.round(exps / np.sum(exps, axis=1, keepdims=True), 4).tolist()", "test_cases": ["assert noisy_topk_gating(np.array([[1.0, 2.0]]), np.array([[1.0, 0.0], [0.0, 1.0]]), np.zeros((2,2)), np.zeros((1,2)), k=1) == [[0., 1.]]", "assert noisy_topk_gating(np.array([[1.0, 2.0]]), np.array([[1.0, 0.0], [0.0, 1.0]]), np.array([[0.5, 0.5], [0.5, 0.5]]), np.array([[1.0, -1.0]]), k=2) == [[0.917, 0.083]]", "assert noisy_topk_gating(np.array([[1.0, 2.0]]), np.array([[1.0, 0.0], [0.0, 1.0]]), np.array([[0.25, 0.25], [0.5, 0.5]]), np.zeros((1,2)), k=2) == [[0.2689, 0.7311]]"]}
{"id": 125, "difficulty": "hard", "category": "Deep Learning", "title": "Implement a Sparse Mixture of Experts Layer", "description": "Implement a Mixture-of-Experts (MoE) layer using softmax gating and top-k routing. Given an input tensor, a set of expert weight matrices, a gating weight matrix, and parameters specifying the number of experts and the value of k, compute the final MoE output by selecting the top-k experts per token, applying their transformations, and aggregating the results weighted by the normalized gating probabilities.", "inputs": ["moe(x = np.arange(12).reshape(2, 3, 2), We = np.ones((4, 2, 2)), Wg = np.ones((2, 4)), n_experts = 4, top_k = 1)"], "outputs": ["[[[1, 1], [5, 5], [9, 9]], [[13, 13], [17, 17], [21, 21]]]"], "reasoning": ["Each token is routed to its top expert and processed using a weight matrix of ones. The result matches the input tokens due to identity transformation and weight 1."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "moe", "starter_code": "def moe(x: np.ndarray, We: np.ndarray, Wg: np.ndarray, n_experts: int, top_k: int):", "reference_code": "def softmax(x: np.ndarray, axis: int = -1) -> np.ndarray:\n    exp_x = np.exp(x - np.max(x, axis=axis, keepdims=True))\n    return exp_x / np.sum(exp_x, axis=axis, keepdims=True)\n\ndef get_top_k(arr: np.ndarray, k: int):\n    idx = np.argpartition(arr, -k)[..., -k:]\n    vals = np.take_along_axis(arr, idx, axis=-1)\n    return idx, vals\n\ndef expert(x: np.ndarray, We_i: np.ndarray):\n    # x: [n_tokens, d_model]\n    # We_i: [d_model, d_model]\n    return x @ We_i\n\ndef gate(x: np.ndarray, Wg: np.ndarray):\n    # x: [n_batch * l_seq, d_model]\n    # Wg: [n_batch * l_seq, n_experts]\n    return x @ Wg\n\ndef moe(x: np.ndarray, We: np.ndarray, Wg: np.ndarray, n_experts: int, top_k: int):\n    # x: [n_batch, l_seq, d_model]\n    # We: [n_experts, d_model, d_model]\n    # Wg: [n_batch * l_seq, n_experts]\n\n    n_batch, l_seq, d_model = x.shape\n\n    # flatten batch and sequence dimensions for easier indexing\n    # x_flat: [n_batch * l_seq, d_model]\n    x_flat = x.reshape(-1, d_model)\n    n_tokens, _ = x_flat.shape\n\n    gating_logits = gate(x_flat, Wg)\n    gating_weights = softmax(gating_logits, axis=-1)\n\n    topk_idx, topk_weights = get_top_k(gating_weights, top_k)\n    topk_idx_flat = topk_idx.flatten()  # [n_tokens * top_k]\n    # mapping from top K expert indices to token indices: [n_tokens * top_k]\n    token_idx_flat = np.arange(n_tokens).repeat(top_k)\n\n    topk_weights_norm = topk_weights / topk_weights.sum(axis=1, keepdims=True)\n    topk_weights_norm_flat = topk_weights_norm.flatten()\n\n    # prepare result memory for aggregation: [n_tokens, d_model]\n    output_flat = np.zeros_like(x_flat)\n    for i in range(n_experts):\n        mask = topk_idx_flat == i\n        tokens_expert_i = token_idx_flat[mask]\n\n        if tokens_expert_i.size > 0:\n            x_expert_i = x_flat[tokens_expert_i]\n            output_expert_i = expert(x_expert_i, We[i, ...])\n            output_expert_i *= topk_weights_norm_flat[mask, None]\n\n            # scatter add to result memory\n            np.add.at(output_flat, tokens_expert_i, output_expert_i)\n\n    return np.round(output_flat.reshape(n_batch, l_seq, d_model), 4).tolist()", "test_cases": ["np.random.seed(42)\nassert moe(np.random.rand(2, 3, 2), np.random.rand(4, 2, 2), np.random.rand(2, 4) , 4, 2) == [[[0.5148, 0.4329], [0.5554, 0.5447], [0.1285, 0.102 ]], [[0.339, 0.3046], [0.5391, 0.417 ], [0.3597, 0.3262]]]", "np.random.seed(42)\nassert moe(np.random.rand(2, 3, 2), np.zeros((4, 2, 2)), np.random.rand(2, 4), 4, 2) == [[[0., 0.], [0., 0.], [0., 0.]], [[0., 0.], [0., 0.], [0., 0.]]]", "np.random.seed(42)\nassert moe(np.random.rand(2, 3, 2), np.random.rand(4, 2, 2), np.random.rand(2, 4), 4, 1) == [[[0.5069, 0.4006], [0.6228, 0.3214], [0.141, 0.0789]], [[0.2886, 0.3254], [0.5747, 0.3433], [0.2959, 0.3582]]]"]}
{"id": 126, "difficulty": "medium", "category": "Deep Learning", "title": "Implement Group Normalization", "description": "Write a Python function to perform Group Normalization on a 4D input tensor with shape (B, C, H, W). The function should normalize over smaller groups of channels, then apply a learned scale (gamma) and shift (beta).", "inputs": ["group_normalization(X = np.array([[[[0, 1], [2, 3]], [[4, 5], [ 6, 7]]], [[[ 8, 9], [10, 11]], [[12, 13], [14, 15]]]]), gamma = np.array([1, 1]), beta = np.array([0, 0]), num_groups = 2)"], "outputs": ["[[[[-1.3416, -0.4472], [0.4472, 1.3416]], [[-1.3416, -0.4472], [0.4472, 1.3416]]], [[[-1.3416, -0.4472], [0.4472, 1.3416]], [[-1.3416, -0.4472], [0.4472, 1.3416]]]]"], "reasoning": ["First split the channels into groups, compute mean and variance per group, normalize within the group, then scale and shift with gamma and beta."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "group_normalization", "starter_code": "def group_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, num_groups: int, epsilon: float = 1e-5):", "reference_code": "def group_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, num_groups: int, epsilon: float = 1e-5):\n    batch_size, num_channels, height, width = X.shape\n    group_size = num_channels // num_groups\n\n    # Reshape X into groups\n    X_reshaped = X.reshape(batch_size, num_groups, group_size, height, width)\n\n    # Compute mean and variance for each group\n    mean = np.mean(X_reshaped, axis=(2, 3, 4), keepdims=True)\n    variance = np.var(X_reshaped, axis=(2, 3, 4), keepdims=True)\n\n    X_norm = (X_reshaped - mean) / np.sqrt(variance + epsilon)\n\n    # Reshape back to the original shape\n    X_norm = X_norm.reshape(batch_size, num_channels, height, width)\n\n    # Apply scale and shift\n    norm_X = gamma * X_norm + beta\n    return np.round(norm_X, 4).tolist()", "test_cases": ["np.random.seed(42)\nassert group_normalization(np.random.randn(2, 2, 2, 2), np.ones(2).reshape(1, 2, 1, 1), np.zeros(2).reshape(1, 2, 1, 1) , 2) == [[[[-0.2287, -1.2998], [ 0.026, 1.5025]], [[-0.926, -0.9259], [1.46, 0.3919]]], [[[-0.5848, 1.732 ], [-0.5709, -0.5762]], [[1.4005, -1.0503], [-0.8361, 0.486 ]]]]", "np.random.seed(42)\nassert group_normalization(np.random.randn(2, 2, 2, 1), np.ones(2).reshape(1, 2, 1, 1), np.zeros(2).reshape(1, 2, 1, 1) , 2) == [[[[1. ], [-1. ]], [[-1. ], [1. ]]], [[[-0.0026],[0.0026]], [[1. ], [-1.]]]]", "np.random.seed(42)\nassert group_normalization(np.random.randn(2, 2, 2, 3), np.ones(2).reshape(1, 2, 1, 1), np.zeros(2).reshape(1, 2, 1, 1) , 2) == [[[[0.2419, -0.7606, 0.4803], [1.8624, -0.912, -0.912]], [[1.7041, 0.6646, -0.9193], [0.3766, -0.9115, -0.9145]]], [[[1.173, -1.31, -1.093], [0.2464, -0.2726, 1.2563]], [[-0.4992, -1.0008, 1.8623], [0.1796, 0.4714, -1.0132]]]]"]}
{"id": 127, "difficulty": "medium", "category": "Calculus", "title": "Find Captain Redbeard's Hidden Treasure", "description": "Captain Redbeard, the most daring pirate of the seven seas, has uncovered a mysterious ancient map. Instead of islands, it shows a strange wavy curve, and the treasure lies at the lowest point of the land! (watch out for those tricky local mins)\nThe land's height at any point $x$ is given by:\nf(x) = x^4 - 3x^3 + 2\nYour Mission: Implement a Python function that finds the value of $x$ where $f(x)$ reaches its minimum, starting from any random initial position.", "inputs": ["find_treasure(start_x = 2.0)"], "outputs": ["2.1475"], "reasoning": ["Cant really give you a example without giving the solution... so ya"], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.", "entry_point": "find_treasure", "starter_code": "def find_treasure(start_x: float, learning_rate: float = 0.1, tolerance: float = 1e-6, max_iters: int = 10000) -> float:", "reference_code": "def find_treasure(start_x: float, learning_rate: float = 0.1, tolerance: float = 1e-6, max_iters: int = 10000) -> float:\n\n    def gradient(x):\n        return 4 * x**3 - 9 * x**2  # derivative of x^4 - 3x^3 + 2\n\n    x = start_x\n    for _ in range(max_iters):\n        grad = gradient(x)\n        new_x = x - learning_rate * grad\n        if abs(new_x - x) < tolerance:\n            break\n        x = new_x\n    return np.round(x, 4)", "test_cases": ["assert find_treasure(-1.0) == 2.3366", "assert find_treasure(1.0) == 2.1475", "assert find_treasure(3.0) == 2.3366"]}
{"id": 128, "difficulty": "medium", "category": "Deep Learning", "title": "Dynamic Tanh: Normalization-Free Transformer Activation", "description": "Implement the Dynamic Tanh (DyT) function, a normalization-free transformation inspired by the Tanh function. DyT replaces layer normalization in Transformer architectures while preserving squashing behavior and enabling stable training.", "inputs": ["dynamic_tanh(x = np.array([[[0.14115588, 0.00372817, 0.24126647, 0.22183601]]]), alpha = 0.5, gamma = np.ones((4,)), beta = np.zeros((4,)))"], "outputs": ["[[[0.0705, 0.0019, 0.1201, 0.1105]]]"], "reasoning": ["Each element in the input is scaled by alpha, passed through tanh, and then scaled by gamma and shifted by beta. This mimics the squashing behavior of layer normalization without explicitly using statistics."], "import_code": "import numpy as np", "output_constrains": "Make sure all results are rounded to the nearest 4th decimal.\nReturn python list after reshaping by using numpy's tolist() method.", "entry_point": "dynamic_tanh", "starter_code": "def dynamic_tanh(x: np.ndarray, alpha: float, gamma: float, beta: float) -> list[float]:", "reference_code": "def dynamic_tanh(x: np.ndarray, alpha: float, gamma: float, beta: float) -> list[float]:\n    def tanh(x: np.ndarray) -> np.ndarray:\n        return (np.exp(x) - np.exp(-x)) / (np.exp(x) + np.exp(-x))\n\n    x = tanh(alpha * x)\n    return (x * gamma + beta).round(4).tolist()", "test_cases": ["assert dynamic_tanh(np.array([[[0.94378259]],[[0.97754654]],[[0.36168351]],[[0.51821078]],[[0.76961589]]]), 0.5, np.ones((1,)), np.zeros((1,))) == [[[0.4397]], [[0.4532]], [[0.1789]], [[0.2535]], [[0.3669]]]", "assert dynamic_tanh(np.array([[[0.20793482, 0.16989285, 0.03898972], [0.17912554, 0.10962205, 0.3870742], [0.00107181, 0.35807922, 0.15861333]]]), 0.5, np.ones((3,)), np.zeros((3,))) == [[[0.1036, 0.0847, 0.0195], [0.0893, 0.0548, 0.1912], [0.0005, 0.1772, 0.0791]]]", "assert dynamic_tanh(np.array([[[0.35, 0.16, 0.42], [0.17, 0.25, 0.38], [0.71, 0.35, 0.68]]]), 0.5, np.ones((3,)), np.zeros((3,))) == [[[0.1732, 0.0798, 0.207], [0.0848, 0.1244, 0.1877], [0.3408, 0.1732, 0.3275]]]"]}
